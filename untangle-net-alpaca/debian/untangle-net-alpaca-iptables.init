#! /bin/dash

### BEGIN INIT INFO
# Provides:          untangle-net-alpaca-iptables
# Required-Start:    $local_fs $network $syslog
# Required-Stop:     $local_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Untangle Network Alpaca (iptables)
### END INIT INFO

# Author: Robert Scott <rbscott@untangle.com>

. /lib/lsb/init-functions

DESC="Untangle Net-Alpaca iptables rules"

IPTABLES_RULES=/etc/untangle-net-alpaca/scripts/iptables
HELPER_MODULES=/usr/share/untangle-net-alpaca/scripts/load-modules

## This should be a file containing all of the iptables tables
IPTABLES_NAMES=/proc/net/ip_tables_names

# Lock file
LOCK_FILE=/tmp/untangle-net-alpaca-iptables.lock

insert_rules()
{
    # make sure privileges don't persist across reboots
    if [ -f ${IPTABLES_RULES} ]; then
        sh ${IPTABLES_RULES}
    else
        /bin/echo "The file '${IPTABLES_RULES}' does not exist"
    fi
    if [ -x ${HELPER_MODULES} ]; then
        ${HELPER_MODULES}
    else
        /bin/echo "The file '${HELPER_MODULES}' does not exist"
    fi
}

remove_rules()
{
    local t_table

    if [ -f ${IPTABLES_NAMES} ]; then
        for t_table in `cat ${IPTABLES_NAMES}` ; do 
            /sbin/iptables -t ${t_table} -F || true
        done        
    else
        /bin/echo "The file '${IPTABLES_NAMES}' does not exist, unable to flush the iptables rules"
    fi

    ## Flushing the ebtables rules.
    if [ -x /sbin/ebtables ]; then
        for t_table in filter nat broute ; do 
            /sbin/ebtables -t ${t_table} --init-table || true
        done
    fi
}

case "$1" in

    ## start script includes stop/flush
    start|reload|restart|force-reload)
        log_daemon_msg "Loading $DESC"

        count=0
        while true ; do
            if ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2> /dev/null; then
                trap 'rm -f "$LOCK_FILE"; exit $?' INT TERM EXIT
            
                # critical section
                insert_rules
            
                rm -f "$LOCK_FILE"
                trap - INT TERM EXIT
                log_end_msg 0
                break
            else
                log_progress_msg "."
                sleep .2

                # timeout
                count=$(($count+1))
                if [ $count -gt 100 ] ; then 
                    rm -f "$LOCK_FILE" 
                    log_progress_msg "removing stale lock"
                fi
            fi 
        done
        ;;

    stop)
        log_daemon_msg "Removing $DESC"

        count=0
        while true ; do
            if ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2> /dev/null; then
                trap 'rm -f "$LOCK_FILE"; exit $?' INT TERM EXIT
            
                # critical section
                remove_rules
            
                rm -f "$LOCK_FILE"
                trap - INT TERM EXIT
                log_end_msg 0
                break
            else
                log_progress_msg "."
                sleep .2

                # timeout
                count=$(($count+1))
                if [ $count -gt 100 ] ; then 
                    rm -f "$LOCK_FILE" 
                    log_progress_msg "removing stale lock"
                fi
            fi 
        done
        ;;        

    *)
        /bin/echo "Usage: $0 {start|stop|restart|force-reload}" >&2
        exit 1
        ;;
esac

exit 0

