{
	"version": 3,
	"sources": [
		"pointer.ts"
	],
	"names": [
		"extend",
		"getOriginXY",
		"hypot",
		"is",
		"resolveRectLike",
		"rectToXY",
		"makeModifier",
		"snap",
		"start",
		"arg",
		"interaction",
		"interactable",
		"element",
		"rect",
		"state",
		"startOffset",
		"options",
		"origin",
		"offsetWithOrigin",
		"prepared",
		"name",
		"getOrigin",
		"x",
		"y",
		"snapOffset",
		"offset",
		"coords",
		"page",
		"offsetRect",
		"relativePoints",
		"offsets",
		"length",
		"map",
		"relativePoint",
		"index",
		"left",
		"width",
		"top",
		"height",
		"set",
		"targets",
		"relativeX",
		"relativeY",
		"len",
		"snapTarget",
		"target",
		"func",
		"_proxy",
		"push",
		"number",
		"range",
		"source",
		"closest",
		"inRange",
		"distance",
		"delta",
		"dx",
		"dy",
		"Infinity",
		"defaults",
		"endOnly",
		"enabled"
	],
	"mappings": "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",
	"sourcesContent": [
		"import Interaction, { InteractionProxy } from '@interactjs/core/Interaction'\nimport { Point, RectResolvable, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier, ModifierArg, ModifierState } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy,\n  offset: Offset,\n  index: number\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[]\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[]\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable<[Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin: RectResolvable<[Element]> | Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<SnapOptions, {\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin\n    ? getOrigin(arg)\n    : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  }\n  else  {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets = rect && relativePoints && relativePoints.length\n    ?  relativePoints.map((relativePoint, index) => ({\n      index,\n      relativePoint,\n      x: startOffset.left - (rect.width  * relativePoint.x) + snapOffset.x,\n      y: startOffset.top  - (rect.height * relativePoint.y) + snapOffset.y,\n    }))\n    : [extend({\n      index: 0,\n      relativePoint: null,\n    }, snapOffset)]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      }\n      else {\n        target = snapTarget\n      }\n\n      if (!target) { continue }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (!closest.target || (inRange\n      // is the closest target in range?\n      ? (closest.inRange && range !== Infinity\n        // the pointer is relatively deeper in this target\n        ? distance / range < closest.distance / closest.range\n        // this target has Infinite range and the closest doesn't\n        : (range === Infinity && closest.range !== Infinity) ||\n          // OR this target is closer that the previous closest\n          distance < closest.distance)\n      // The other is not in range and the pointer is closer to this target\n      : (!closest.inRange && distance < closest.distance))) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(\n    resolveRectLike(arg.state.options.origin as any, null, null, [element]),\n  )\n  const origin = optionsOrigin || getOriginXY(\n    arg.interactable,\n    element,\n    arg.interaction.prepared.name,\n  )\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range  : Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"
	]
}