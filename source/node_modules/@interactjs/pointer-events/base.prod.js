import{Interaction as t}from"../core/Interaction.prod.js";import{Scope as e,SignalArgs as n}from"../core/scope.prod.js";import*as o from"../utils/domUtils.prod.js";import r from"../utils/extend.prod.js";import i from"../utils/getOriginXY.prod.js";import{PointerEvent as a}from"./PointerEvent.prod.js";const p={id:"pointer-events/base",before:["inertia","modifiers","auto-start","actions"],install(t){t.pointerEvents=p,t.defaults.actions.pointerEvents=p.defaults,r(t.actions.phaselessTypes,p.types)},listeners:{"interactions:new"({interaction:t}){t.prevTap=null,t.tapTime=0},"interactions:update-pointer"({down:t,pointerInfo:e}){!t&&e.hold||(e.hold={duration:1/0,timeout:null})},"interactions:move"(t,e){const{interaction:n,pointer:o,event:r,eventTarget:i,duplicate:a}=t;a||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&c(t),s({interaction:n,pointer:o,event:r,eventTarget:i,type:"move"},e))},"interactions:down"(t,e){(({interaction:t,pointer:e,event:n,eventTarget:r,pointerIndex:i},a)=>{const p=t.pointers[i].hold,l=o.getPath(r),c={interaction:t,pointer:e,event:n,eventTarget:r,type:"hold",targets:[],path:l,node:null};for(const t of l)c.node=t,a.fire("pointerEvents:collect-targets",c);if(!c.targets.length)return;let d=1/0;for(const t of c.targets){const e=t.eventable.options.holdDuration;e<d&&(d=e)}p.duration=d,p.timeout=setTimeout((()=>{s({interaction:t,eventTarget:r,pointer:e,event:n,type:"hold"},a)}),d)})(t,e),s(t,e)},"interactions:up"(t,e){c(t),s(t,e),(({interaction:t,pointer:e,event:n,eventTarget:o},r)=>{t.pointerWasMoved||s({interaction:t,eventTarget:o,pointer:e,event:n,type:"tap"},r)})(t,e)},"interactions:cancel"(t,e){c(t),s(t,e)}},PointerEvent:a,fire:s,collectEventTargets:l,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function s(t,e){const{interaction:n,pointer:o,event:r,eventTarget:p,type:c,targets:d=l(t,e)}=t,v=new a(c,o,r,p,n,e.now());e.fire("pointerEvents:new",{pointerEvent:v});const u={interaction:n,pointer:o,event:r,eventTarget:p,targets:d,type:c,pointerEvent:v};for(let t=0;t<d.length;t++){const e=d[t];for(const t in e.props||{})v[t]=e.props[t];const n=i(e.eventable,e.node);if(v._subtractOrigin(n),v.eventable=e.eventable,v.currentTarget=e.node,e.eventable.fire(v),v._addOrigin(n),v.immediatePropagationStopped||v.propagationStopped&&t+1<d.length&&d[t+1].node!==v.currentTarget)break}if(e.fire("pointerEvents:fired",u),"tap"===c){const t=v.double?s({interaction:n,pointer:o,event:r,eventTarget:p,type:"doubletap"},e):v;n.prevTap=t,n.tapTime=t.timeStamp}return v}function l({interaction:t,pointer:e,event:n,eventTarget:r,type:i},a){const p=t.getPointerIndex(e),s=t.pointers[p];if("tap"===i&&(t.pointerWasMoved||!s||s.downTarget!==r))return[];const l=o.getPath(r),c={interaction:t,pointer:e,event:n,eventTarget:r,type:i,path:l,targets:[],node:null};for(const t of l)c.node=t,a.fire("pointerEvents:collect-targets",c);return"hold"===i&&(c.targets=c.targets.filter((e=>e.eventable.options.holdDuration===t.pointers[p].hold.duration))),c.targets}function c({interaction:t,pointerIndex:e}){const n=t.pointers[e].hold;n&&n.timeout&&(clearTimeout(n.timeout),n.timeout=null)}export default p;
//# sourceMappingURL=base.prod.js.map