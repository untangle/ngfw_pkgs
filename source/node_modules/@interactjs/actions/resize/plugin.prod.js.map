{
	"version": 3,
	"sources": [
		"plugin.ts"
	],
	"names": [
		"Interactable",
		"Interaction",
		"dom",
		"extend",
		"is",
		"checkResizeEdge",
		"name",
		"value",
		"page",
		"element",
		"interactableElement",
		"rect",
		"margin",
		"width",
		"number",
		"right",
		"left",
		"height",
		"bottom",
		"top",
		"Math",
		"min",
		"abs",
		"x",
		"y",
		"matchesUpTo",
		"updateEventAxes",
		"iEvent",
		"interaction",
		"prepared",
		"resizeAxes",
		"resizeEvent",
		"interactable",
		"options",
		"resize",
		"square",
		"delta",
		"axes",
		"id",
		"before",
		"install",
		"scope",
		"actions",
		"browser",
		"defaults",
		"cursors",
		"isIe9",
		"xy",
		"topleft",
		"bottomright",
		"topright",
		"bottomleft",
		"initCursors",
		"defaultMargin",
		"supportsTouch",
		"supportsPointerEvent",
		"prototype",
		"resizable",
		"object",
		"enabled",
		"setPerAction",
		"setOnEvents",
		"string",
		"axis",
		"test",
		"bool",
		"preserveAspectRatio",
		"this",
		"map",
		"methodDict",
		"listeners",
		"[object Object]",
		"arg",
		"edges",
		"_rects",
		"start",
		"corrected",
		"previous",
		"deltaRect",
		"invert",
		"invertible",
		"current",
		"startRect",
		"swap",
		"max",
		"edge",
		"move",
		"buttons",
		"coords",
		"cur",
		"resizeOptions",
		"pointerIsDown",
		"pointerType",
		"mouseButtons",
		"resizeEdges",
		"_latestPointer",
		"eventTarget",
		"action",
		"undefined",
		"NaN",
		"getCursor",
		"result",
		"cursorKey"
	],
	"mappings": "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",
	"sourcesContent": [
		"import { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport { Interactable } from '@interactjs/core/Interactable'\nimport { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport { Scope, Plugin } from '@interactjs/core/scope'\nimport { ActionMethod, ResizableOptions, FullRect, OrBoolean, Point, Rect } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod<ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent<P extends EventPhase = EventPhase> extends InteractEvent<'resize', P> {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) { return undefined }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n     /mouse|pointer/.test(interaction.pointerType) &&\n   (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin)\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  }\n  else {\n    const right  = resizeOptions.axis !== 'y' && page.x > (rect.right  - resize.defaultMargin)\n    const bottom = resizeOptions.axis !== 'x' && page.y > (rect.bottom - resize.defaultMargin)\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean<ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    }\n    else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    }\n    else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) { return false }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = is.number(rect.width) ? rect.width  : rect.right  - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if      (name === 'left')  { name = 'right' }\n      else if (name === 'right') { name = 'left'  }\n    }\n    if (height < 0) {\n      if      (name === 'top')    { name = 'bottom' }\n      else if (name === 'bottom') { name = 'top'    }\n    }\n\n    if (name === 'left') { return page.x < ((width  >= 0 ? rect.left : rect.right) + margin) }\n    if (name === 'top') { return page.y < ((height >= 0 ? rect.top : rect.bottom) + margin) }\n\n    if (name === 'right') { return page.x > ((width  >= 0 ? rect.right : rect.left) - margin) }\n    if (name === 'bottom') { return page.y > ((height >= 0 ? rect.bottom : rect.top) - margin) }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) { return false }\n\n  return is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\nfunction initCursors (browser: typeof import ('@interactjs/utils/browser').default) {\n  return (browser.isIe9 ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  })\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right : 0,\n      width : 0,\n      top : 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) { return }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top    = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left   = Math.min(current.left, startRect.right)\n    corrected.right  = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width  = corrected.right  - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) { return }\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) { return }\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    }\n    else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  }\n  else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    }\n    else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': arg => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': arg => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    }\n    else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n"
	]
}