{
	"version": 3,
	"sources": [
		"plugin.ts"
	],
	"names": [
		"Interactable",
		"is",
		"beforeMove",
		"interaction",
		"prepared",
		"name",
		"axis",
		"coords",
		"cur",
		"page",
		"y",
		"start",
		"client",
		"velocity",
		"x",
		"move",
		"iEvent",
		"opposite",
		"delta",
		"drag",
		"id",
		"install",
		"scope",
		"actions",
		"defaults",
		"prototype",
		"draggable",
		"map",
		"methodDict",
		"listeners",
		"interactions:before-action-move",
		"interactions:action-resume",
		"interactions:action-move",
		"[object Object]",
		"arg",
		"interactable",
		"buttons",
		"dragOptions",
		"options",
		"enabled",
		"pointerIsDown",
		"test",
		"pointerType",
		"mouseButtons",
		"action",
		"lockAxis",
		"startAxis",
		"object",
		"this",
		"setPerAction",
		"setOnEvents",
		"bool",
		"getCursor"
	],
	"mappings": "uBACSA,MAAoB,yCAGtBC,MAAQ,yBAuCf,SAASC,GAAYC,YAAEA,IACrB,GAAkC,SAA9BA,EAAYC,SAASC,KAAmB,OAE5C,MAAMC,EAAOH,EAAYC,SAASE,KAErB,MAATA,GACFH,EAAYI,OAAOC,IAAIC,KAAKC,EAAMP,EAAYI,OAAOI,MAAMF,KAAKC,EAChEP,EAAYI,OAAOC,IAAII,OAAOF,EAAIP,EAAYI,OAAOI,MAAMC,OAAOF,EAElEP,EAAYI,OAAOM,SAASD,OAAOF,EAAI,EACvCP,EAAYI,OAAOM,SAASJ,KAAKC,EAAM,GAEvB,MAATJ,IACPH,EAAYI,OAAOC,IAAIC,KAAKK,EAAMX,EAAYI,OAAOI,MAAMF,KAAKK,EAChEX,EAAYI,OAAOC,IAAII,OAAOE,EAAIX,EAAYI,OAAOI,MAAMC,OAAOE,EAElEX,EAAYI,OAAOM,SAASD,OAAOE,EAAI,EACvCX,EAAYI,OAAOM,SAASJ,KAAKK,EAAM,GAI3C,SAASC,GAAMC,OAAEA,EAAFb,YAAUA,IACvB,GAAkC,SAA9BA,EAAYC,SAASC,KAAmB,OAE5C,MAAMC,EAAOH,EAAYC,SAASE,KAElC,GAAa,MAATA,GAAyB,MAATA,EAAc,CAChC,MAAMW,EAAoB,MAATX,EAAe,IAAM,IAEtCU,EAAOP,KAAKQ,GAAcd,EAAYI,OAAOI,MAAMF,KAAKQ,GACxDD,EAAOJ,OAAOK,GAAYd,EAAYI,OAAOI,MAAMC,OAAOK,GAC1DD,EAAOE,MAAMD,GAAY,GA2C7B,MAyBME,EAAe,CACnBC,GAAI,eACJC,QApHgBC,GAChB,MAAMC,QACJA,EADIvB,aAEJA,EAFIwB,SAGJA,GACEF,EAEJtB,EAAayB,UAAUC,UAAYP,EAAKO,UAExCH,EAAQI,IAAIR,KAAOA,EACnBI,EAAQK,WAAWT,KAAO,YAE1BK,EAASD,QAAQJ,KAAOA,EAAKK,UAyG7BK,UAAW,CACTC,kCAAmC5B,EACnC6B,6BAA8B7B,EAG9B8B,2BAA4BjB,EAC5BkB,mBAAoBC,GAClB,MAAM/B,YAAEA,EAAFgC,aAAeA,EAAfC,QAA6BA,GAAYF,EACzCG,EAAcF,EAAaG,QAAQnB,KAEzC,GACIkB,GAAeA,EAAYE,WAE5BpC,EAAYqC,gBACZ,gBAAgBC,KAAKtC,EAAYuC,cACoB,IAAtDN,EAAUD,EAAaG,QAAQnB,KAAKwB,eAYtC,OAPAT,EAAIU,OAAS,CACXvC,KAAM,OACNC,KAAgC,UAAzB+B,EAAYQ,SACfR,EAAYS,UACZT,EAAYQ,WAGX,IAGXnB,UA1DyEY,GACzE,OAAIrC,EAAG8C,OAAOT,IACZU,KAAKV,QAAQnB,KAAKoB,SAA8B,IAApBD,EAAQC,QACpCS,KAAKC,aAAa,OAAQX,GAC1BU,KAAKE,YAAY,OAAQZ,GAErB,mBAAmBG,KAAKH,EAAQO,YAClCG,KAAKV,QAAQnB,KAAK0B,SAAWP,EAAQO,UAEnC,aAAaJ,KAAKH,EAAQQ,aAC5BE,KAAKV,QAAQnB,KAAK2B,UAAYR,EAAQQ,WAGjCE,MAGL/C,EAAGkD,KAAKb,IACVU,KAAKV,QAAQnB,KAAKoB,QAAUD,EAErBU,MAGFA,KAAKV,QAAQnB,MAqCpBjB,WAAAA,EACAa,KAAAA,EACAS,SAAU,CACRsB,UAAY,KACZD,SAAY,MAGdO,YACE,MAAO,wBAIIjC",
	"sourcesContent": [
		"import { InteractEvent } from '@interactjs/core/InteractEvent'\nimport { Interactable } from '@interactjs/core/Interactable'\nimport { Scope, Plugin } from '@interactjs/core/scope'\nimport { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent<'drag'>\n\nexport type DraggableMethod = ActionMethod<DraggableOptions>\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    Interactable,\n    defaults,\n  } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y   = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y   = 0\n  }\n  else if (axis === 'y') {\n    interaction.coords.cur.page.x   = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x   = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite]   = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (this: Interactable, options?: DraggableOptions | boolean): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': arg => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n         /mouse|pointer/.test(interaction.pointerType) &&\n       (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: (dragOptions.lockAxis === 'start'\n          ? dragOptions.startAxis\n          : dragOptions.lockAxis),\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  } as DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n"
	]
}