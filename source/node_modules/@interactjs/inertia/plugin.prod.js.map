{
	"version": 3,
	"sources": [
		"plugin.ts"
	],
	"names": [
		"Interaction",
		"SignalArgs",
		"Modification",
		"modifiers",
		"offset",
		"dom",
		"hypot",
		"is",
		"copyCoords",
		"raf",
		"InertiaState",
		"constructor",
		"interaction",
		"this",
		"active",
		"isModified",
		"smoothEnd",
		"allowResume",
		"modification",
		"modifierCount",
		"modifierArg",
		"startCoords",
		"t0",
		"v0",
		"te",
		"targetOffset",
		"modifiedOffset",
		"currentOffset",
		"lambda_v0",
		"one_ve_v0",
		"timeout",
		"start",
		"event",
		"options",
		"getOptions",
		"enabled",
		"client",
		"velocityClient",
		"coords",
		"velocity",
		"pointerSpeed",
		"x",
		"y",
		"copyFrom",
		"_now",
		"cur",
		"page",
		"interactable",
		"element",
		"rect",
		"edges",
		"pageCoords",
		"preEnd",
		"phase",
		"timeStamp",
		"minSpeed",
		"endSpeed",
		"startInertia",
		"result",
		"setAll",
		"changed",
		"startSmoothEnd",
		"offsetBy",
		"_doPhase",
		"simulation",
		"startVelocity",
		"lambda",
		"resistance",
		"inertiaDur",
		"Math",
		"log",
		"delta",
		"onNextFrame",
		"inertiaTick",
		"smoothEndTick",
		"tickFn",
		"request",
		"t",
		"progress",
		"exp",
		"newOffset",
		"cpX",
		"cpY",
		"endX",
		"endY",
		"_getQBezierValue",
		"position",
		"move",
		"end",
		"smoothEndDuration",
		"duration",
		"easeOutQuad",
		"skipModifiers",
		"resume",
		"pointer",
		"eventTarget",
		"updatePointer",
		"prev",
		"stop",
		"cancel",
		"prepared",
		"name",
		"inertia",
		"id",
		"before",
		"install",
		"scope",
		"defaults",
		"usePlugin",
		"default",
		"actions",
		"phases",
		"inertiastart",
		"perAction",
		"listeners",
		"[object Object]",
		"interactions:before-action-end",
		"_interacting",
		"arg",
		"state",
		"parentNode",
		"applyToInteraction",
		"interactions:before-action-inertiastart",
		"setAndApply",
		"interactions:action-resume",
		"addEventModifiers",
		"interactions:action-inertiastart",
		"interactions:after-action-inertiastart",
		"restoreInteractionCoords",
		"interactions:after-action-resume",
		"p1",
		"p2",
		"p3",
		"iT",
		"b",
		"c",
		"d"
	],
	"mappings": "OAAOA,MAAiC,mDACZC,MAA0B,+BAC/CC,MAAkB,8CACbC,MAAe,mCACpBC,MAAY,qCAEPC,MAAS,mCACdC,MAAW,gCACXC,MAAQ,2CACNC,MAAkB,uCACpBC,MAAS,8BA2DT,MAAMC,aAwBXC,YAAaC,GAA0BC,KAvBvCC,QAAS,EAuB8BD,KAtBvCE,YAAa,EAsB0BF,KArBvCG,WAAY,EAqB2BH,KApBvCI,aAAc,EAoByBJ,KAlBvCK,aAA6B,KAkBUL,KAjBvCM,cAAgB,EAiBuBN,KAhBvCO,YAAqC,KAgBEP,KAdvCQ,YAAqB,KAckBR,KAbvCS,GAAK,EAakCT,KAZvCU,GAAK,EAYkCV,KAVvCW,GAAK,EAUkCX,KATvCY,aAAsB,KASiBZ,KARvCa,eAAwB,KAQeb,KAPvCc,cAAuB,KAOgBd,KALvCe,UAAa,EAK0Bf,KAJvCgB,UAAa,EAI0BhB,KAHvCiB,QAAkB,KAGqBjB,KAF9BD,iBAE8B,EACrCC,KAAKD,YAAcA,EAGrBmB,MAAOC,GACL,MAAMpB,YAAEA,GAAgBC,KAClBoB,EAAUC,EAAWtB,GAE3B,IAAKqB,IAAYA,EAAQE,QACvB,OAAO,EAGT,MAAQC,OAAQC,GAAmBzB,EAAY0B,OAAOC,SAChDC,EAAelC,EAAM+B,EAAeI,EAAGJ,EAAeK,GACtDxB,EAAeL,KAAKK,eAAiBL,KAAKK,aAAe,IAAIhB,EAAaU,IA2BhF,GAzBAM,EAAayB,SAAS/B,EAAYM,cAElCL,KAAKS,GAAKV,EAAYgC,OACtB/B,KAAKI,YAAcgB,EAAQhB,YAC3BJ,KAAKU,GAAKiB,EACV3B,KAAKc,cAAgB,CAAEc,EAAG,EAAGC,EAAG,GAChC7B,KAAKQ,YAAcT,EAAY0B,OAAOO,IAAIC,KAE1CjC,KAAKO,YAAc,CACjBR,YAAAA,EACAmC,aAAcnC,EAAYmC,aAC1BC,QAASpC,EAAYoC,QACrBC,KAAMrC,EAAYqC,KAClBC,MAAOtC,EAAYsC,MACnBC,WAAYtC,KAAKQ,YACjB+B,QAAQ,EACRC,MAAO,gBAINxC,KAAKS,GAAKV,EAAY0B,OAAOO,IAAIS,UAAa,IAC/Cd,EAAeP,EAAQsB,UACvBf,EAAeP,EAAQuB,SAIvB3C,KAAK4C,mBACA,CAGL,GAFAvC,EAAawC,OAASxC,EAAayC,OAAO9C,KAAKO,cAE1CF,EAAawC,OAAOE,QACvB,OAAO,EAGT/C,KAAKgD,iBAoBP,OAhBAjD,EAAYM,aAAawC,OAAOT,KAAO,KAGvCrC,EAAYkD,SAASjD,KAAKY,cAC1Bb,EAAYmD,SAAS,CACnBnD,YAAAA,EACAoB,MAAAA,EACAqB,MAAO,iBAETzC,EAAYkD,SAAS,CAAErB,GAAI5B,KAAKY,aAAagB,EAAGC,GAAI7B,KAAKY,aAAaiB,IAEtE9B,EAAYM,aAAawC,OAAOT,KAAO,KAEvCpC,KAAKC,QAAS,EACdF,EAAYoD,WAAanD,MAElB,EAGT4C,eACE,MAAMQ,EAAgBpD,KAAKD,YAAY0B,OAAOC,SAASH,OACjDH,EAAUC,EAAWrB,KAAKD,aAC1BsD,EAASjC,EAAQkC,WACjBC,GAAcC,KAAKC,IAAIrC,EAAQuB,SAAW3C,KAAKU,IAAM2C,EAE3DrD,KAAKY,aAAe,CAClBgB,GAAIwB,EAAcxB,EAAI2B,GAAcF,EACpCxB,GAAIuB,EAAcvB,EAAI0B,GAAcF,GAGtCrD,KAAKW,GAAK4C,EACVvD,KAAKe,UAAYsC,EAASrD,KAAKU,GAC/BV,KAAKgB,UAAY,EAAII,EAAQuB,SAAW3C,KAAKU,GAE7C,MAAML,aAAEA,EAAFE,YAAgBA,GAAgBP,KAEtCO,EAAY+B,WAAa,CACvBV,EAAG5B,KAAKQ,YAAYoB,EAAI5B,KAAKY,aAAagB,EAC1CC,EAAG7B,KAAKQ,YAAYqB,EAAI7B,KAAKY,aAAaiB,GAG5CxB,EAAawC,OAASxC,EAAayC,OAAOvC,GAEtCF,EAAawC,OAAOE,UACtB/C,KAAKE,YAAa,EAClBF,KAAKa,eAAiB,CACpBe,EAAG5B,KAAKY,aAAagB,EAAIvB,EAAawC,OAAOa,MAAM9B,EACnDC,EAAG7B,KAAKY,aAAaiB,EAAIxB,EAAawC,OAAOa,MAAM7B,IAIvD7B,KAAK2D,aAAY,IAAM3D,KAAK4D,gBAG9BZ,iBACEhD,KAAKG,WAAY,EACjBH,KAAKE,YAAa,EAClBF,KAAKY,aAAe,CAClBgB,EAAG5B,KAAKK,aAAawC,OAAOa,MAAM9B,EAClCC,EAAG7B,KAAKK,aAAawC,OAAOa,MAAM7B,GAGpC7B,KAAK2D,aAAY,IAAM3D,KAAK6D,kBAG9BF,YAAaG,GACX9D,KAAKiB,QAAUrB,EAAImE,SAAQ,KACrB/D,KAAKC,QAAU6D,OAIvBF,cACE,MAAM7D,YAAEA,GAAgBC,KAElBqD,EADUhC,EAAWtB,GACJuD,WACjBU,GAAKjE,EAAYgC,OAAS/B,KAAKS,IAAM,IAE3C,GAAIuD,EAAIhE,KAAKW,GAAI,CACf,MAAMsD,EAAY,GAAKT,KAAKU,KAAKb,EAASW,GAAKhE,KAAKe,WAAaf,KAAKgB,UACtE,IAAImD,EAEAnE,KAAKE,YAEL,EAAG,EA0LqBkE,EAzLxBpE,KAAKY,aAAagB,EAyLmByC,EAzLhBrE,KAAKY,aAAaiB,EAyLWyC,EAxLlDtE,KAAKa,eAAee,EAwL4C2C,EAxLzCvE,KAAKa,eAAegB,EAH7CsC,EA4LC,CACLvC,EAAI4C,EAFgFC,EAvL9ER,EAHA,EA4LiCG,EAAKE,GAC5CzC,EAAI2C,EAAiBC,EA7LZ,EA6L8BJ,EAAKE,KAtLxCJ,EAAY,CACVvC,EAAG5B,KAAKY,aAAagB,EAAIqC,EACzBpC,EAAG7B,KAAKY,aAAaiB,EAAIoC,GAI7B,MAAMP,EAAQ,CAAE9B,EAAGuC,EAAUvC,EAAI5B,KAAKc,cAAcc,EAAGC,EAAGsC,EAAUtC,EAAI7B,KAAKc,cAAce,GAE3F7B,KAAKc,cAAcc,GAAK8B,EAAM9B,EAC9B5B,KAAKc,cAAce,GAAK6B,EAAM7B,EAE9B9B,EAAYkD,SAASS,GACrB3D,EAAY2E,OAEZ1E,KAAK2D,aAAY,IAAM3D,KAAK4D,qBAG5B7D,EAAYkD,SAAS,CACnBrB,EAAG5B,KAAKa,eAAee,EAAI5B,KAAKc,cAAcc,EAC9CC,EAAG7B,KAAKa,eAAegB,EAAI7B,KAAKc,cAAce,IAGhD7B,KAAK2E,MA4JX,IACkCP,EAAaC,EAAaC,EAAcC,EAAcE,EAzJtFZ,gBACE,MAAM9D,YAAEA,GAAgBC,KAClBgE,EAAIjE,EAAYgC,OAAS/B,KAAKS,IAC5BmE,kBAAmBC,GAAaxD,EAAWtB,GAEnD,GAAIiE,EAAIa,EAAU,CAChB,MAAMV,EAAY,CAChBvC,EAAGkD,EAAYd,EAAG,EAAGhE,KAAKY,aAAagB,EAAGiD,GAC1ChD,EAAGiD,EAAYd,EAAG,EAAGhE,KAAKY,aAAaiB,EAAGgD,IAEtCnB,EAAQ,CACZ9B,EAAGuC,EAAUvC,EAAI5B,KAAKc,cAAcc,EACpCC,EAAGsC,EAAUtC,EAAI7B,KAAKc,cAAce,GAGtC7B,KAAKc,cAAcc,GAAK8B,EAAM9B,EAC9B5B,KAAKc,cAAce,GAAK6B,EAAM7B,EAE9B9B,EAAYkD,SAASS,GACrB3D,EAAY2E,KAAK,CAAEK,cAAe/E,KAAKM,gBAEvCN,KAAK2D,aAAY,IAAM3D,KAAK6D,uBAG5B9D,EAAYkD,SAAS,CACnBrB,EAAG5B,KAAKY,aAAagB,EAAI5B,KAAKc,cAAcc,EAC5CC,EAAG7B,KAAKY,aAAaiB,EAAI7B,KAAKc,cAAce,IAG9C7B,KAAK2E,MAITK,QAAQC,QAAEA,EAAF9D,MAAWA,EAAX+D,YAAkBA,IACxB,MAAMnF,YAAEA,GAAgBC,KAGxBD,EAAYkD,SAAS,CACnBrB,GAAI5B,KAAKc,cAAcc,EACvBC,GAAI7B,KAAKc,cAAce,IAIzB9B,EAAYoF,cAAcF,EAAS9D,EAAO+D,GAAa,GAGvDnF,EAAYmD,SAAS,CACnBnD,YAAAA,EACAoB,MAAAA,EACAqB,MAAO,WAET7C,EAAWI,EAAY0B,OAAO2D,KAAMrF,EAAY0B,OAAOO,KAEvDhC,KAAKqF,OAGPV,MACE3E,KAAKD,YAAY2E,OACjB1E,KAAKD,YAAY4E,MACjB3E,KAAKqF,OAGPA,OACErF,KAAKC,OAASD,KAAKG,WAAY,EAC/BH,KAAKD,YAAYoD,WAAa,KAC9BvD,EAAI0F,OAAOtF,KAAKiB,UA6CpB,SAASI,GAAYa,aAAEA,EAAFqD,SAAgBA,IACnC,OAAOrD,GACLA,EAAad,SACbmE,EAASC,MACTtD,EAAad,QAAQmE,EAASC,MAAMC,QAGxC,MAAMA,EAAkB,CACtBC,GAAI,UACJC,OAAQ,CAAC,YAAa,WACtBC,QA9UgBC,GAChB,MAAMC,SACJA,GACED,EAEJA,EAAME,UAAUxG,GAChBsG,EAAME,UAAUzG,EAAU0G,SAC1BH,EAAMI,QAAQC,OAAOC,cAAe,EACpCN,EAAMI,QAAQC,OAAOlB,QAAS,EAE9Bc,EAASM,UAAUX,QAAU,CAC3BnE,SAAmB,EACnBgC,WAAmB,GACnBZ,SAAmB,IACnBC,SAAmB,GACnBvC,aAAmB,EACnBwE,kBAAmB,MA+TrByB,UAAW,CACTC,oBAAuBvG,YAAAA,IACrBA,EAAY0F,QAAU,IAAI5F,aAAaE,IAGzCwG,iCAzDJ,EAAgBxG,YAAEA,EAAFoB,MAAeA,OACxBpB,EAAYyG,cAAgBzG,EAAYoD,aAI7BpD,EAAY0F,QAAQvE,MAAMC,KAHjC,KAwDPmF,oBA7CaG,GACf,MAAM1G,YAAEA,EAAFmF,YAAeA,GAAgBuB,EAC/BC,EAAQ3G,EAAY0F,QAE1B,IAAKiB,EAAMzG,OAAU,OAErB,IAAIkC,EAAU+C,EAGd,KAAOxF,EAAGyC,QAAQA,IAAU,CAE1B,GAAIA,IAAYpC,EAAYoC,QAAS,CACnCuE,EAAM1B,OAAOyB,GACb,MAGFtE,EAAU3C,EAAImH,WAAWxE,KA8BzBmE,qBA1BWvG,YAAEA,IACf,MAAM2G,EAAQ3G,EAAY0F,QAEtBiB,EAAMzG,QACRyG,EAAMrB,QAwBNiB,oCAAqCG,GACnC,MAAMpG,aAAEA,GAAiBoG,EAAI1G,YAE7BM,EAAagF,KAAKoB,GAClBpG,EAAaa,MAAMuF,EAAKA,EAAI1G,YAAY0B,OAAOO,IAAIC,MACnD5B,EAAauG,mBAAmBH,IAGlCI,0CAA2CJ,GAAOA,EAAI1G,YAAYM,aAAayG,YAAYL,GAC3FM,6BAA8BzH,EAAU0H,kBACxCC,mCAAoC3H,EAAU0H,kBAC9CE,yCAA0CT,GAAOA,EAAI1G,YAAYM,aAAa8G,yBAAyBV,GACvGW,mCAAoCX,GAAOA,EAAI1G,YAAYM,aAAa8G,yBAAyBV,KAKrG,SAASjC,EAAkBR,EAAWqD,EAAYC,EAAYC,GAC5D,MAAMC,EAAK,EAAIxD,EACf,OAAOwD,EAAKA,EAAKH,EAAK,EAAIG,EAAKxD,EAAIsD,EAAKtD,EAAIA,EAAIuD,EAYlD,SAASzC,EAAad,EAAWyD,EAAWC,EAAWC,GAErD,OAAQD,GADR1D,GAAK2D,IACY3D,EAAI,GAAKyD,iBAGbhC",
	"sourcesContent": [
		"import Interaction, { DoPhaseArg } from '@interactjs/core/Interaction'\nimport { ActionName, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport offset from '@interactjs/offset/plugin'\nimport { Point, PointerEventType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number        // the lambda in exponential decay\n      minSpeed?: number          // target speed must be above this for inertia to start\n      endSpeed?: number          // the speed at which inertia is slow enough to stop\n      allowResume?: true         // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<DoPhaseArg<ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<DoPhaseArg<ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': DoPhaseArg<ActionName, 'resume'>\n    'interactions:after-action-resume': DoPhaseArg<ActionName, 'resume'>\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    defaults,\n  } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled          : false,\n    resistance       : 10,    // the lambda in exponential decay\n    minSpeed         : 100,   // target speed must be above this for inertia to start\n    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n    allowResume      : true,  // allow resuming an action in inertia phase\n    smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification: Modification = null\n  modifierCount = 0\n  modifierArg: modifiers.ModifierArg = null\n\n  startCoords: Point = null\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset: Point = null\n  modifiedOffset: Point = null\n  currentOffset: Point = null\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout: number = null\n  readonly interaction: Interaction\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = {\n      interaction,\n      interactable: interaction.interactable,\n      element: interaction.element,\n      rect: interaction.rect,\n      edges: interaction.edges,\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    }\n\n    const thrown = (\n      (this.t0 - interaction.coords.cur.timeStamp) < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n    )\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) { tickFn() }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress =  1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0, 0,\n          this.targetOffset.x, this.targetOffset.y,\n          this.modifiedOffset.x, this.modifiedOffset.y,\n          progress,\n        )\n      }\n      else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    }\n    else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    }\n    else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: DoPhaseArg<ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) { return }\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interaction) {\n  return interactable &&\n    interactable.options &&\n    prepared.name &&\n    interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': arg => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': arg => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number, startY: number, cpX: number, cpY: number, endX: number, endY: number, position: number) {\n  return {\n    x:  _getQBezierValue(position, startX, cpX, endX),\n    y:  _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n"
	]
}