import t from"../core/Interaction.prod.js";import{SignalArgs as i}from"../core/scope.prod.js";import e from"../modifiers/Modification.prod.js";import*as s from"../modifiers/base.prod.js";import o from"../offset/plugin.prod.js";import*as r from"../utils/domUtils.prod.js";import n from"../utils/hypot.prod.js";import a from"../utils/is.prod.js";import{copyCoords as f}from"../utils/pointerUtils.prod.js";import c from"../utils/raf.prod.js";export class InertiaState{constructor(t){this.active=!1,this.isModified=!1,this.smoothEnd=!1,this.allowResume=!1,this.modification=null,this.modifierCount=0,this.modifierArg=null,this.startCoords=null,this.t0=0,this.v0=0,this.te=0,this.targetOffset=null,this.modifiedOffset=null,this.currentOffset=null,this.lambda_v0=0,this.one_ve_v0=0,this.timeout=null,this.interaction=void 0,this.interaction=t}start(t){const{interaction:i}=this,s=h(i);if(!s||!s.enabled)return!1;const{client:o}=i.coords.velocity,r=n(o.x,o.y),a=this.modification||(this.modification=new e(i));if(a.copyFrom(i.modification),this.t0=i._now(),this.allowResume=s.allowResume,this.v0=r,this.currentOffset={x:0,y:0},this.startCoords=i.coords.cur.page,this.modifierArg={interaction:i,interactable:i.interactable,element:i.element,rect:i.rect,edges:i.edges,pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"},this.t0-i.coords.cur.timeStamp<50&&r>s.minSpeed&&r>s.endSpeed)this.startInertia();else{if(a.result=a.setAll(this.modifierArg),!a.result.changed)return!1;this.startSmoothEnd()}return i.modification.result.rect=null,i.offsetBy(this.targetOffset),i._doPhase({interaction:i,event:t,phase:"inertiastart"}),i.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),i.modification.result.rect=null,this.active=!0,i.simulation=this,!0}startInertia(){const t=this.interaction.coords.velocity.client,i=h(this.interaction),e=i.resistance,s=-Math.log(i.endSpeed/this.v0)/e;this.targetOffset={x:(t.x-s)/e,y:(t.y-s)/e},this.te=s,this.lambda_v0=e/this.v0,this.one_ve_v0=1-i.endSpeed/this.v0;const{modification:o,modifierArg:r}=this;r.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},o.result=o.setAll(r),o.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+o.result.delta.x,y:this.targetOffset.y+o.result.delta.y}),this.onNextFrame((()=>this.inertiaTick()))}startSmoothEnd(){this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.onNextFrame((()=>this.smoothEndTick()))}onNextFrame(t){this.timeout=c.request((()=>{this.active&&t()}))}inertiaTick(){const{interaction:t}=this,i=h(t).resistance,e=(t._now()-this.t0)/1e3;if(e<this.te){const f=1-(Math.exp(-i*e)-this.lambda_v0)/this.one_ve_v0;let c;this.isModified?(0,0,s=this.targetOffset.x,o=this.targetOffset.y,r=this.modifiedOffset.x,n=this.modifiedOffset.y,c={x:m(a=f,0,s,r),y:m(a,0,o,n)}):c={x:this.targetOffset.x*f,y:this.targetOffset.y*f};const h={x:c.x-this.currentOffset.x,y:c.y-this.currentOffset.y};this.currentOffset.x+=h.x,this.currentOffset.y+=h.y,t.offsetBy(h),t.move(),this.onNextFrame((()=>this.inertiaTick()))}else t.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end();var s,o,r,n,a}smoothEndTick(){const{interaction:t}=this,i=t._now()-this.t0,{smoothEndDuration:e}=h(t);if(i<e){const s={x:l(i,0,this.targetOffset.x,e),y:l(i,0,this.targetOffset.y,e)},o={x:s.x-this.currentOffset.x,y:s.y-this.currentOffset.y};this.currentOffset.x+=o.x,this.currentOffset.y+=o.y,t.offsetBy(o),t.move({skipModifiers:this.modifierCount}),this.onNextFrame((()=>this.smoothEndTick()))}else t.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}resume({pointer:t,event:i,eventTarget:e}){const{interaction:s}=this;s.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),s.updatePointer(t,i,e,!0),s._doPhase({interaction:s,event:i,phase:"resume"}),f(s.coords.prev,s.coords.cur),this.stop()}end(){this.interaction.move(),this.interaction.end(),this.stop()}stop(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,c.cancel(this.timeout)}}function h({interactable:t,prepared:i}){return t&&t.options&&i.name&&t.options[i.name].inertia}const d={id:"inertia",before:["modifiers","actions"],install(t){const{defaults:i}=t;t.usePlugin(o),t.usePlugin(s.default),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,i.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new"({interaction:t}){t.inertia=new InertiaState(t)},"interactions:before-action-end":({interaction:t,event:i})=>(!t._interacting||t.simulation||!t.inertia.start(i))&&null,"interactions:down"(t){const{interaction:i,eventTarget:e}=t,s=i.inertia;if(!s.active)return;let o=e;for(;a.element(o);){if(o===i.element){s.resume(t);break}o=r.parentNode(o)}},"interactions:stop"({interaction:t}){const i=t.inertia;i.active&&i.stop()},"interactions:before-action-resume"(t){const{modification:i}=t.interaction;i.stop(t),i.start(t,t.interaction.coords.cur.page),i.applyToInteraction(t)},"interactions:before-action-inertiastart":t=>t.interaction.modification.setAndApply(t),"interactions:action-resume":s.addEventModifiers,"interactions:action-inertiastart":s.addEventModifiers,"interactions:after-action-inertiastart":t=>t.interaction.modification.restoreInteractionCoords(t),"interactions:after-action-resume":t=>t.interaction.modification.restoreInteractionCoords(t)}};function m(t,i,e,s){const o=1-t;return o*o*i+2*o*t*e+t*t*s}function l(t,i,e,s){return-e*(t/=s)*(t-2)+i}export default d;
//# sourceMappingURL=plugin.prod.js.map