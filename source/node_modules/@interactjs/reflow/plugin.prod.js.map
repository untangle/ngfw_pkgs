{
	"version": 3,
	"sources": [
		"plugin.ts"
	],
	"names": [
		"Interactable",
		"Interaction",
		"arr",
		"is",
		"copyAction",
		"pointerUtils",
		"tlbrToXywh",
		"install",
		"scope",
		"actions",
		"phases",
		"reflow",
		"prototype",
		"action",
		"interactable",
		"elements",
		"string",
		"target",
		"from",
		"_context",
		"querySelectorAll",
		"Promise",
		"window",
		"promises",
		"element",
		"rect",
		"getRect",
		"runningInteraction",
		"find",
		"interactions",
		"list",
		"interaction",
		"interacting",
		"prepared",
		"name",
		"reflowPromise",
		"move",
		"_reflowPromise",
		"resolve",
		"_reflowResolve",
		"xywh",
		"coords",
		"page",
		"x",
		"y",
		"client",
		"timeStamp",
		"now",
		"event",
		"coordsToEvent",
		"startReflow",
		"push",
		"all",
		"then",
		"doReflow",
		"this",
		"new",
		"pointerType",
		"signalArg",
		"pointer",
		"eventTarget",
		"phase",
		"prevEvent",
		"updatePointer",
		"setZeroCoords",
		"delta",
		"_doPhase",
		"undefined",
		"start",
		"_interacting",
		"end",
		"stop",
		"removePointer",
		"id",
		"listeners",
		"[object Object]",
		"remove"
	],
	"mappings": "uBAASA,MAAoB,qDACQC,MAAmB,wCAG5CC,MAAS,8BACdC,MAAQ,2CACNC,MAAkB,kCACfC,MAAkB,qDACrBC,MAAkB,+BA6BpB,SAASC,QAASC,GACvB,MAAMR,aAEJA,GACEQ,EAEJA,EAAMC,QAAQC,OAAOC,QAAS,EAkB9BX,EAAaY,UAAUD,OAAS,SAAUE,GACxC,MAIJ,EAAyCC,EAA4BD,EAAwBL,KAC3F,MAAMO,EAAYZ,EAAGa,OAAOF,EAAaG,QACrCf,EAAIgB,KAAKJ,EAAaK,SAASC,iBAAiBN,EAAaG,SAC7D,CAACH,EAAaG,QAGZI,EAAWb,EAAMc,OAAeD,QAChCE,EAAwCF,EAAU,GAAK,KAE7D,IAAK,MAAMG,KAAWT,EAAU,CAC9B,MAAMU,EAAOX,EAAaY,QAAQF,GAElC,IAAKC,EAAQ,MAEb,MAAME,EAAqBzB,EAAI0B,KAC7BpB,EAAMqB,aAAaC,MAClBC,GACQA,EAAYC,eACjBD,EAAYjB,eAAiBA,GAC7BiB,EAAYP,UAAYA,GACxBO,EAAYE,SAASC,OAASrB,EAAOqB,OAE3C,IAAIC,EAEJ,GAAIR,EACFA,EAAmBS,OAEfb,IACFY,EAAgBR,EAAmBU,gBAAkB,IAAIhB,GAASiB,IAChEX,EAAmBY,eAAiBD,UAIrC,CACH,MAAME,EAAOlC,EAAWmB,GAClBgB,EAAS,CACbC,KAAW,CAAEC,EAAGH,EAAKG,EAAGC,EAAGJ,EAAKI,GAChCC,OAAW,CAAEF,EAAGH,EAAKG,EAAGC,EAAGJ,EAAKI,GAChCE,UAAWtC,EAAMuC,OAGbC,EAAQ3C,EAAa4C,cAAcR,GACzCN,EAAgBe,EAAe1C,EAAOM,EAAcU,EAASX,EAAQmC,GAGnEzB,GACFA,EAAS4B,KAAKhB,GAIlB,OAAOZ,GAAYF,EAAQ+B,IAAI7B,GAAU8B,MAAK,IAAMvC,KAtD3CwC,CAASC,KAAM1C,EAAQL,IAyDlC,SAAS0C,EAAmC1C,EAAcM,EAA4BU,EAAkBX,EAAwBmC,GAC9H,MAAMjB,EAAcvB,EAAMqB,aAAa2B,IAAI,CAAEC,YAAa,WACpDC,EAAY,CAChB3B,YAAAA,EACAiB,MAAAA,EACAW,QAASX,EACTY,YAAapC,EACbqC,MAAO,UAGT9B,EAAYjB,aAAeA,EAC3BiB,EAAYP,QAAUA,EACtBO,EAAY+B,UAAYd,EACxBjB,EAAYgC,cAAcf,EAAOA,EAAOxB,GAAS,GACjDnB,EAAa2D,cAAcjC,EAAYU,OAAOwB,OAE9C7D,EAAW2B,EAAYE,SAAUpB,GACjCkB,EAAYmC,SAASR,GAErB,MAAMrC,QAAEA,GAAab,EAAMc,OACrBa,EAAgBd,EAClB,IAAIA,GAAmBiB,IACvBP,EAAYQ,eAAiBD,UAE7B6B,EAgBJ,OAdApC,EAAYM,eAAiBF,EAC7BJ,EAAYqC,MAAMvD,EAAQC,EAAcU,GAEpCO,EAAYsC,cACdtC,EAAYK,KAAKsB,GACjB3B,EAAYuC,IAAItB,KAGhBjB,EAAYwC,OACZxC,EAAYQ,kBAGdR,EAAYyC,cAAcxB,EAAOA,GAE1Bb,EAGT,MAAMxB,EAAiB,CACrB8D,GAAI,SACJlE,QAAAA,QACAmE,UAAW,CAETC,qBAAwB5C,YAAAA,GAAevB,GACL,WAA5BuB,EAAY0B,cACV1B,EAAYQ,gBACdR,EAAYQ,iBAGdrC,EAAI0E,OAAOpE,EAAMqB,aAAaC,KAAMC,sBAM7BpB",
	"sourcesContent": [
		"import { Interactable } from '@interactjs/core/Interactable'\nimport { ActionProps, DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: <T extends ActionName>(action: ActionProps<T>) => ReturnType<typeof doReflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: (...args: unknown[]) => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow<T extends ActionName> (interactable: Interactable, action: ActionProps<T>, scope: Scope): Promise<Interactable> {\n  const elements = (is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]) as Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) { break }\n\n    const runningInteraction = arr.find(\n      scope.interactions.list,\n      (interaction: Interaction) => {\n        return interaction.interacting() &&\n          interaction.interactable === interactable &&\n          interaction.element === element &&\n          interaction.prepared.name === action.name\n      })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise = runningInteraction._reflowPromise || new Promise((resolve: any) => {\n          runningInteraction._reflowResolve = resolve\n        })\n      }\n    }\n    else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page     : { x: xywh.x, y: xywh.y },\n        client   : { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends ActionName> (scope: Scope, interactable: Interactable, element: Element, action: ActionProps<T>, event: any) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = (scope.window as unknown as { Promise: PromiseConstructor })\n  const reflowPromise = Promise\n    ? new Promise<undefined>(resolve => {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  }\n  else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n"
	]
}