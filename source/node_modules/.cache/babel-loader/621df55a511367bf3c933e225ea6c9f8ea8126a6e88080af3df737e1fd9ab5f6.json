{"ast":null,"code":"import _regeneratorRuntime from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { VContainer, VRow, VCol } from 'vuetify/lib';\nimport { ValidationObserver, ValidationProvider, extend } from 'vee-validate';\nimport cloneDeep from 'lodash/cloneDeep';\nimport i18n from '../../../plugins/vue-i18n';\nimport net from '../../../plugins/net';\nimport Ipv4PrefixAutocomplete from '../../../components/Ipv4PrefixAutocomplete';\nexport default {\n  components: {\n    VContainer: VContainer,\n    VRow: VRow,\n    VCol: VCol,\n    ValidationObserver: ValidationObserver,\n    ValidationProvider: ValidationProvider,\n    Ipv4PrefixAutocomplete: Ipv4PrefixAutocomplete\n  },\n  props: {\n    settings: {\n      type: Object,\n      required: true\n    },\n    // full geoip settings\n    index: {\n      type: String,\n      required: false,\n      \"default\": ''\n    } // index of network being edited\n  },\n  data: function data() {\n    return {\n      address: '',\n      prefix: 24,\n      description: ''\n    };\n  },\n  computed: {\n    editingNetwork: function editingNetwork() {\n      return this.settings.passedNetworks[this.index] || null;\n    },\n    suggestedNetwork: function suggestedNetwork() {\n      return net.info(this.address, this.prefix);\n    }\n  },\n  created: function created() {\n    // set network if editing\n    if (this.editingNetwork) {\n      // split host into ip/prefix\n      var _this$editingNetwork$ = this.editingNetwork.address.split('/'),\n        _this$editingNetwork$2 = _slicedToArray(_this$editingNetwork$, 2),\n        address = _this$editingNetwork$2[0],\n        prefix = _this$editingNetwork$2[1];\n      this.address = address;\n      this.prefix = parseInt(prefix);\n      this.description = this.editingNetwork.description;\n    }\n\n    // Validation rule for a network if duplicates or overlaps existing passed network\n    extend('pass_network', {\n      params: ['network', 'existingNetworks', 'index'],\n      /**\n       * @param {string} value - the host IP to be checked\n       * @param {string} network - the network to be added/edited\n       * @param {array} existingNetworks - the existing passed networks to check against\n       * @param {number} index - the index of the edited network\n       * @returns {boolean}\n       */\n      validate: function validate(value, _ref) {\n        var network = _ref.network,\n          existingNetworks = _ref.existingNetworks,\n          index = _ref.index;\n        index = Number(index);\n        if (!(network !== null && network !== void 0 && network.networkAddress)) return false;\n        var inputNetwork = \"\".concat(network.networkAddress, \"/\").concat(network.cidr);\n        var duplicateNetwork = null;\n        var overlappingNetwork = null;\n        existingNetworks.forEach(function (n, idx) {\n          // if editing a network skip duplicate or overlap check against self\n          if (index >= 0 && idx === index) return;\n          // check if duplicate\n          if (!duplicateNetwork && n.address === inputNetwork) {\n            duplicateNetwork = n.address;\n          }\n          // check if overlapping\n          if (!overlappingNetwork && net.subnetConflict(n.address, inputNetwork)) {\n            overlappingNetwork = n.address;\n          }\n        });\n        if (duplicateNetwork) {\n          return i18n.t('geoip_network_duplicate', [duplicateNetwork]);\n        }\n        if (overlappingNetwork) {\n          return i18n.t('geoip_network_overlap', [inputNetwork, overlappingNetwork]);\n        }\n        return true;\n      }\n    });\n  },\n  methods: {\n    action: function action() {\n      var _this = this;\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var isValid, networksCopy, network;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.$refs.obs.validate();\n            case 2:\n              isValid = _context.sent;\n              if (isValid) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 5:\n              networksCopy = cloneDeep(_this.settings.passedNetworks);\n              network = {\n                address: \"\".concat(_this.address.trim(), \"/\").concat(_this.prefix),\n                description: _this.description\n              };\n              if (_this.suggestedNetwork) {\n                network = {\n                  address: \"\".concat(_this.suggestedNetwork.networkAddress.trim(), \"/\").concat(_this.suggestedNetwork.cidr),\n                  description: _this.description\n                };\n              }\n              if (_this.editingNetwork) {\n                networksCopy[_this.index] = network;\n              } else {\n                networksCopy.push(network);\n              }\n              _this.$set(_this.settings, 'passedNetworks', networksCopy);\n              _this.$emit('close');\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    }\n  }\n};","map":{"version":3,"names":["VContainer","VRow","VCol","ValidationObserver","ValidationProvider","extend","cloneDeep","i18n","net","Ipv4PrefixAutocomplete","components","props","settings","type","Object","required","index","String","data","address","prefix","description","computed","editingNetwork","passedNetworks","suggestedNetwork","info","created","_this$editingNetwork$","split","_this$editingNetwork$2","_slicedToArray","parseInt","params","validate","value","_ref","network","existingNetworks","Number","networkAddress","inputNetwork","concat","cidr","duplicateNetwork","overlappingNetwork","forEach","n","idx","subnetConflict","t","methods","action","_this","_asyncToGenerator","_regeneratorRuntime","mark","_callee","isValid","networksCopy","wrap","_callee$","_context","prev","next","$refs","obs","sent","abrupt","trim","push","$set","$emit","stop"],"sources":["node_modules/vuntangle/src/shared/SettingsGeoipFilter/components/NetworkDialog.vue"],"sourcesContent":["<template>\n  <v-container class=\"px-0\">\n    <ValidationObserver ref=\"obs\">\n      <v-row>\n        <v-col>\n          <ValidationProvider\n            v-slot=\"{ errors }\"\n            :rules=\"{\n              required: true,\n              ip: true,\n              pass_network: {\n                network: suggestedNetwork,\n                existingNetworks: settings.passedNetworks,\n                index,\n              },\n            }\"\n          >\n            <u-text-field v-model=\"address\" :label=\"$t('ip_address')\" :error-messages=\"errors\" @keydown.space.prevent>\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </u-text-field>\n          </ValidationProvider>\n        </v-col>\n        <v-col>\n          <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n            <ipv-4-prefix-autocomplete v-model=\"prefix\" :errors=\"errors\" />\n          </ValidationProvider>\n        </v-col>\n      </v-row>\n      <v-row>\n        <v-col>\n          <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n            <u-text-field v-model=\"description\" :label=\"$t('description')\" :error-messages=\"errors\">\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </u-text-field>\n          </ValidationProvider>\n        </v-col>\n      </v-row>\n      <v-row>\n        <v-col>\n          <u-alert v-if=\"suggestedNetwork && suggestedNetwork.networkAddress !== address\">\n            <span\n              v-html=\"\n                $t('geoip_subnet_suggested_network', [\n                  `${address}/${prefix}`,\n                  `${suggestedNetwork.networkAddress}/${suggestedNetwork.cidr}`,\n                ])\n              \"\n            />\n          </u-alert>\n        </v-col>\n      </v-row>\n    </ValidationObserver>\n  </v-container>\n</template>\n<script>\n  import { VContainer, VRow, VCol } from 'vuetify/lib'\n  import { ValidationObserver, ValidationProvider, extend } from 'vee-validate'\n  import cloneDeep from 'lodash/cloneDeep'\n  import i18n from '../../../plugins/vue-i18n'\n  import net from '../../../plugins/net'\n  import Ipv4PrefixAutocomplete from '../../../components/Ipv4PrefixAutocomplete'\n\n  export default {\n    components: { VContainer, VRow, VCol, ValidationObserver, ValidationProvider, Ipv4PrefixAutocomplete },\n    props: {\n      settings: { type: Object, required: true }, // full geoip settings\n      index: { type: String, required: false, default: '' }, // index of network being edited\n    },\n    data: () => ({\n      address: '',\n      prefix: 24,\n      description: '',\n    }),\n    computed: {\n      editingNetwork() {\n        return this.settings.passedNetworks[this.index] || null\n      },\n      suggestedNetwork() {\n        return net.info(this.address, this.prefix)\n      },\n    },\n    created() {\n      // set network if editing\n      if (this.editingNetwork) {\n        // split host into ip/prefix\n        const [address, prefix] = this.editingNetwork.address.split('/')\n\n        this.address = address\n        this.prefix = parseInt(prefix)\n        this.description = this.editingNetwork.description\n      }\n\n      // Validation rule for a network if duplicates or overlaps existing passed network\n      extend('pass_network', {\n        params: ['network', 'existingNetworks', 'index'],\n        /**\n         * @param {string} value - the host IP to be checked\n         * @param {string} network - the network to be added/edited\n         * @param {array} existingNetworks - the existing passed networks to check against\n         * @param {number} index - the index of the edited network\n         * @returns {boolean}\n         */\n        validate(value, { network, existingNetworks, index }) {\n          index = Number(index)\n          if (!network?.networkAddress) return false\n          const inputNetwork = `${network.networkAddress}/${network.cidr}`\n          let duplicateNetwork = null\n          let overlappingNetwork = null\n          existingNetworks.forEach((n, idx) => {\n            // if editing a network skip duplicate or overlap check against self\n            if (index >= 0 && idx === index) return\n            // check if duplicate\n            if (!duplicateNetwork && n.address === inputNetwork) {\n              duplicateNetwork = n.address\n            }\n            // check if overlapping\n            if (!overlappingNetwork && net.subnetConflict(n.address, inputNetwork)) {\n              overlappingNetwork = n.address\n            }\n          })\n          if (duplicateNetwork) {\n            return i18n.t('geoip_network_duplicate', [duplicateNetwork])\n          }\n          if (overlappingNetwork) {\n            return i18n.t('geoip_network_overlap', [inputNetwork, overlappingNetwork])\n          }\n          return true\n        },\n      })\n    },\n    methods: {\n      async action() {\n        const isValid = await this.$refs.obs.validate()\n        if (!isValid) {\n          return\n        }\n\n        const networksCopy = cloneDeep(this.settings.passedNetworks)\n        let network = {\n          address: `${this.address.trim()}/${this.prefix}`,\n          description: this.description,\n        }\n\n        if (this.suggestedNetwork) {\n          network = {\n            address: `${this.suggestedNetwork.networkAddress.trim()}/${this.suggestedNetwork.cidr}`,\n            description: this.description,\n          }\n        }\n\n        if (this.editingNetwork) {\n          networksCopy[this.index] = network\n        } else {\n          networksCopy.push(network)\n        }\n\n        this.$set(this.settings, 'passedNetworks', networksCopy)\n        this.$emit('close')\n      },\n    },\n  }\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}