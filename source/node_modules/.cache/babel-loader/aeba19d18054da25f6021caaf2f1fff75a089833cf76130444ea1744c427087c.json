{"ast":null,"code":"import _toConsumableArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nexport default {\n  computed: {\n    // just a shortcut to type as is reused a lot\n    type: function type(_ref) {\n      var intf = _ref.intf;\n      return intf.type;\n    },\n    /** shows `wan` checkbox  if ADDRESSED */\n    showWan: function showWan(_ref2) {\n      var intf = _ref2.intf,\n        type = _ref2.type;\n      return (intf.configType === 'ADDRESSED' || ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN', 'IPSEC', 'BRIDGE'].includes(type)) && !intf.management;\n    },\n    /** disable `wan` */\n    disableWan: function disableWan(_ref3) {\n      var type = _ref3.type;\n      return ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN', 'IPSEC', 'BRIDGE'].includes(type);\n    },\n    /** shows `natEgress` checkbox */\n    showNatEgress: function showNatEgress(_ref4) {\n      var intf = _ref4.intf,\n        type = _ref4.type;\n      return intf.wan && type !== 'IPSEC' && (intf.configType === 'ADDRESSED' || ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN'].includes(type));\n    },\n    /** shows delete interface button */\n    showDelete: function showDelete(_ref5) {\n      var intf = _ref5.intf,\n        type = _ref5.type,\n        isBridgedInterface = _ref5.isBridgedInterface;\n      return intf.device && !['NIC', 'WIFI', 'WWAN'].includes(type) && !isBridgedInterface;\n    },\n    /** shows Ipv4, Ipv6 for ADDRESSED config types */\n    showAddressed: function showAddressed(_ref6) {\n      var intf = _ref6.intf,\n        type = _ref6.type;\n      return (intf.configType === 'ADDRESSED' || type === 'BRIDGE') && !['OPENVPN', 'WIREGUARD', 'WWAN', 'IPSEC'].includes(intf.type);\n    },\n    /** shows interface config type based on interface type */\n    showConfigType: function showConfigType(_ref7) {\n      var type = _ref7.type;\n      return !['WWAN', 'OPENVPN', 'WIREGUARD', 'IPSEC', 'VLAN', 'BRIDGE'].includes(type);\n    },\n    /** shows bound to options for specific types and `configType` not `BRIDGED` */\n    showBoundToOptions: function showBoundToOptions(_ref8) {\n      var type = _ref8.type,\n        intf = _ref8.intf;\n      return ['OPENVPN', 'WIREGUARD', 'IPSEC'].includes(type) && intf.configType !== 'BRIDGED';\n    },\n    /** shows bridged to options only if `configType` is `BRIDGED` */\n    showBridgedToOptions: function showBridgedToOptions(_ref9) {\n      var type = _ref9.type,\n        intf = _ref9.intf;\n      return type === 'BRIDGE' || intf.configType === 'BRIDGED';\n    },\n    /** show tabs */\n    showTabs: function showTabs(_ref10) {\n      var tabs = _ref10.tabs,\n        intf = _ref10.intf,\n        type = _ref10.type,\n        isBridgedInterface = _ref10.isBridgedInterface;\n      return (tabs || []).length && !(intf.configType === 'BRIDGED' && type !== 'WIFI' && type !== 'BRIDGE') && !isBridgedInterface;\n    },\n    /** show DHCP Tab only if ADDRESSED interface is not WAN */\n    showDhcp: function showDhcp(_ref11) {\n      var intf = _ref11.intf,\n        showAddressed = _ref11.showAddressed;\n      return showAddressed && !intf.wan && !intf.management;\n    },\n    /** show VRRP Tab for NIC, VLAN types and interface `ADDRESSED` */\n    showVrrp: function showVrrp(_ref12) {\n      var intf = _ref12.intf,\n        type = _ref12.type,\n        features = _ref12.features;\n      return features.hasVrrp && (type === 'BRIDGE' || ['NIC', 'VLAN'].includes(type) && intf.configType === 'ADDRESSED' && !intf.management);\n    },\n    /** show NIC Options only if interface is `NIC` and `ADDRESSED` */\n    showNICOptions: function showNICOptions(_ref13) {\n      var intf = _ref13.intf,\n        status = _ref13.status;\n      return intf.type === 'NIC' && intf.configType === 'ADDRESSED' && (status === null || status === void 0 ? void 0 : status.ethSpeed) > 0;\n    },\n    /** show Qos Tab only for WANs and exclude specified interface types */\n    showQos: function showQos(_ref14) {\n      var intf = _ref14.intf;\n      return intf.wan && !['OPENVPN', 'WIREGUARD', 'WIFI', 'WWAN', 'IPSEC'].includes(intf.type);\n    },\n    /** retuns interface names used for validation against duplicate names */\n    interfaceNames: function interfaceNames(_ref15) {\n      var intf = _ref15.intf,\n        interfaces = _ref15.interfaces;\n      return interfaces.filter(function (i) {\n        return i.interfaceId !== intf.interfaceId;\n      }).map(function (i) {\n        return i.name;\n      });\n    },\n    /**\n     * interface name vaidation rules\n     * - required, max 10 alphas\n     * - no spaces\n     * - unique among the all existing interfaces names\n     */\n    interfaceNameRules: function interfaceNameRules(_ref16) {\n      var $vuntangle = _ref16.$vuntangle,\n        interfaceNames = _ref16.interfaceNames;\n      return {\n        required: true,\n        max: 10,\n        regex: [/^[a-zA-Z][a-zA-Z0-9_]*$/, $vuntangle.$t('interface_name_must_be')],\n        unique_insensitive: {\n          list: interfaceNames,\n          message: $vuntangle.$t('interface_name_already_in_use')\n        }\n      };\n    },\n    /**\n     * vaidation rules for the localGateway radio group\n     */\n    localGatewayRules: function localGatewayRules(_ref17) {\n      var ipsec = _ref17.ipsec,\n        selectedWan = _ref17.selectedWan;\n      return {\n        required: true,\n        conflicting_any_gateways: {\n          local: ipsec.local.gateway,\n          remote: ipsec.remote.gateway\n        },\n        disconnected_wan: {\n          boundWan: selectedWan\n        },\n        validate_gateways: {\n          local: ipsec.local.gateway,\n          remote: ipsec.remote.gateway\n        }\n      };\n    },\n    /**\n     * vaidation rules for the remoteGateway radio group\n     */\n    remoteGatewayRules: function remoteGatewayRules(_ref18) {\n      var ipsec = _ref18.ipsec;\n      return {\n        required: true,\n        conflicting_any_gateways: {\n          local: ipsec.local.gateway,\n          remote: ipsec.remote.gateway\n        },\n        validate_gateways: {\n          local: ipsec.local.gateway,\n          remote: ipsec.remote.gateway\n        }\n      };\n    },\n    /**\n     * boundInterfaceId vaidation rules\n     */\n    boundInterfaceIdRules: function boundInterfaceIdRules(_ref19) {\n      var interfaces = _ref19.interfaces,\n        intf = _ref19.intf;\n      return {\n        required: true,\n        vlan_duplicate: {\n          interfaces: interfaces,\n          interfaceId: intf.interfaceId,\n          // current interface id\n          boundInterfaceId: null,\n          // passed by field value\n          vlanId: intf.vlanid\n        }\n      };\n    },\n    /**\n     * vlanID vaidation rules\n     */\n    vlanIdRules: function vlanIdRules(_ref20) {\n      var interfaces = _ref20.interfaces,\n        intf = _ref20.intf;\n      return {\n        required: true,\n        numeric: true,\n        min_value: 1,\n        max_value: 4094,\n        vlan_duplicate: {\n          interfaces: interfaces,\n          interfaceId: intf.interfaceId,\n          // current interface id\n          boundInterfaceId: intf.boundInterfaceId,\n          vlanId: null // passed by field value\n        }\n      };\n    },\n    /**\n     * return possible config types for an interface\n     * - for WANs it's only `ADDRESSED`\n     * - otherwise it's `ADDRESSED` or `BRIDGED`\n     */\n    configTypes: function configTypes(_ref21) {\n      var $vuntangle = _ref21.$vuntangle,\n        intf = _ref21.intf;\n      return [{\n        text: $vuntangle.$t('addressed'),\n        value: 'ADDRESSED'\n      }].concat(_toConsumableArray(!intf.wan && !intf.management ? [{\n        text: $vuntangle.$t('bridged'),\n        value: 'BRIDGED'\n      }] : []));\n    },\n    /** returns interfaces options to be bound, based on interface type */\n    boundToOptions: function boundToOptions(_ref22) {\n      var intf = _ref22.intf,\n        type = _ref22.type,\n        getBoundableNicsOptions = _ref22.getBoundableNicsOptions,\n        getBoundableInterfacesOptions = _ref22.getBoundableInterfacesOptions;\n      if (type === 'VLAN') return getBoundableNicsOptions;\n      if (['OPENVPN', 'WIREGUARD', 'IPSEC'].includes(type)) {\n        var includeAnyWan = true;\n        if (type === 'WIREGUARD' && intf.wireguardType === 'TUNNEL') includeAnyWan = false;\n        return getBoundableInterfacesOptions(includeAnyWan);\n      }\n      return [];\n    },\n    /** returns interfaces options to be bridged */\n    bridgedToOptions: function bridgedToOptions(_ref23) {\n      var type = _ref23.type,\n        intf = _ref23.intf,\n        interfaces = _ref23.interfaces;\n      var filter = [];\n      if (type === 'BRIDGE') {\n        var alreadyBridgedToSet = new Set();\n        interfaces.filter(function (i) {\n          return i.interfaceId !== intf.interfaceId && i.type === 'BRIDGE' && i.bridgedInterfaces;\n        }).forEach(function (i) {\n          return i.bridgedInterfaces.forEach(function (i) {\n            return alreadyBridgedToSet.add(i);\n          });\n        });\n        filter = interfaces.filter(function (i) {\n          return i.interfaceId !== intf.interfaceId && ['NIC', 'VLAN', 'WIFI'].includes(i.type) && !i.wan && !alreadyBridgedToSet.has(i.interfaceId);\n        });\n      } else {\n        filter = interfaces.filter(function (i) {\n          return i.interfaceId !== intf.interfaceId && i.configType === 'ADDRESSED' && !i.wan;\n        });\n      }\n      if (!filter.length) return [];\n      return filter.map(function (i) {\n        return {\n          value: i.interfaceId,\n          text: i.name\n        };\n      });\n    },\n    /**\n     * Returns select options available for boundable interfaces having conditions:\n     * - interface type is `NIC` or `WWAN`\n     * - interface is `wan`\n     * - interface is `enabled`\n     *\n     * passing `includeAnyWan` true, adds `Any WAN` option\n     */\n    getBoundableInterfacesOptions: function getBoundableInterfacesOptions() {\n      var _this = this;\n      return function () {\n        var includeAnyWan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var enabledWans = _this.interfaces.filter(function (intf) {\n          return ['NIC', 'WWAN'].includes(intf.type) && intf.wan && intf.enabled;\n        });\n        var options = enabledWans.map(function (wan) {\n          return {\n            value: wan.interfaceId,\n            text: wan.name\n          };\n        });\n        if (includeAnyWan) options.unshift({\n          value: 0,\n          text: _this.$vuntangle.$t('any_wan')\n        });\n        return options;\n      };\n    },\n    /**\n     * Returns select options for all available NICs interfaces\n     * used for VLAN bound interface\n     * BUG? should NICs be `wan` & `enabled`\n     */\n    getBoundableNicsOptions: function getBoundableNicsOptions(_ref24) {\n      var interfaces = _ref24.interfaces;\n      var nics = interfaces.filter(function (intf) {\n        return intf.type === 'NIC' || intf.type === 'BRIDGE';\n      });\n      return nics.map(function (nic) {\n        return {\n          value: nic.interfaceId,\n          text: nic.name\n        };\n      });\n    },\n    /**\n     * checks if the given interface is part of a bridge or not\n     *\n     * @param intf\n     * @param interfaces\n     * @returns {boolean}\n     */\n    isBridgedInterface: function isBridgedInterface(_ref25) {\n      var intf = _ref25.intf,\n        interfaces = _ref25.interfaces;\n      var bridgedInterface = interfaces.filter(function (i) {\n        var _i$bridgedInterfaces;\n        return (_i$bridgedInterfaces = i.bridgedInterfaces) === null || _i$bridgedInterfaces === void 0 ? void 0 : _i$bridgedInterfaces.includes(intf.interfaceId);\n      });\n      return bridgedInterface.length > 0;\n    }\n  }\n};","map":{"version":3,"names":["computed","type","_ref","intf","showWan","_ref2","configType","includes","management","disableWan","_ref3","showNatEgress","_ref4","wan","showDelete","_ref5","isBridgedInterface","device","showAddressed","_ref6","showConfigType","_ref7","showBoundToOptions","_ref8","showBridgedToOptions","_ref9","showTabs","_ref10","tabs","length","showDhcp","_ref11","showVrrp","_ref12","features","hasVrrp","showNICOptions","_ref13","status","ethSpeed","showQos","_ref14","interfaceNames","_ref15","interfaces","filter","i","interfaceId","map","name","interfaceNameRules","_ref16","$vuntangle","required","max","regex","$t","unique_insensitive","list","message","localGatewayRules","_ref17","ipsec","selectedWan","conflicting_any_gateways","local","gateway","remote","disconnected_wan","boundWan","validate_gateways","remoteGatewayRules","_ref18","boundInterfaceIdRules","_ref19","vlan_duplicate","boundInterfaceId","vlanId","vlanid","vlanIdRules","_ref20","numeric","min_value","max_value","configTypes","_ref21","text","value","concat","_toConsumableArray","boundToOptions","_ref22","getBoundableNicsOptions","getBoundableInterfacesOptions","includeAnyWan","wireguardType","bridgedToOptions","_ref23","alreadyBridgedToSet","Set","bridgedInterfaces","forEach","add","has","_this","arguments","undefined","enabledWans","enabled","options","unshift","_ref24","nics","nic","_ref25","bridgedInterface","_i$bridgedInterfaces"],"sources":["/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/vuntangle/src/shared/SettingsInterface/components/mixin.js"],"sourcesContent":["export default {\n  computed: {\n    // just a shortcut to type as is reused a lot\n    type: ({ intf }) => intf.type,\n\n    /** shows `wan` checkbox  if ADDRESSED */\n    showWan: ({ intf, type }) =>\n      (intf.configType === 'ADDRESSED' || ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN', 'IPSEC', 'BRIDGE'].includes(type)) &&\n      !intf.management,\n\n    /** disable `wan` */\n    disableWan: ({ type }) => ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN', 'IPSEC', 'BRIDGE'].includes(type),\n\n    /** shows `natEgress` checkbox */\n    showNatEgress: ({ intf, type }) =>\n      intf.wan &&\n      type !== 'IPSEC' &&\n      (intf.configType === 'ADDRESSED' || ['WWAN', 'VLAN', 'WIREGUARD', 'OPENVPN'].includes(type)),\n\n    /** shows delete interface button */\n    showDelete: ({ intf, type, isBridgedInterface }) =>\n      intf.device && !['NIC', 'WIFI', 'WWAN'].includes(type) && !isBridgedInterface,\n\n    /** shows Ipv4, Ipv6 for ADDRESSED config types */\n    showAddressed: ({ intf, type }) => {\n      return (\n        (intf.configType === 'ADDRESSED' || type === 'BRIDGE') &&\n        !['OPENVPN', 'WIREGUARD', 'WWAN', 'IPSEC'].includes(intf.type)\n      )\n    },\n\n    /** shows interface config type based on interface type */\n    showConfigType: ({ type }) => !['WWAN', 'OPENVPN', 'WIREGUARD', 'IPSEC', 'VLAN', 'BRIDGE'].includes(type),\n\n    /** shows bound to options for specific types and `configType` not `BRIDGED` */\n    showBoundToOptions: ({ type, intf }) =>\n      ['OPENVPN', 'WIREGUARD', 'IPSEC'].includes(type) && intf.configType !== 'BRIDGED',\n\n    /** shows bridged to options only if `configType` is `BRIDGED` */\n    showBridgedToOptions: ({ type, intf }) => type === 'BRIDGE' || intf.configType === 'BRIDGED',\n\n    /** show tabs */\n    showTabs: ({ tabs, intf, type, isBridgedInterface }) => {\n      return (\n        (tabs || []).length &&\n        !(intf.configType === 'BRIDGED' && type !== 'WIFI' && type !== 'BRIDGE') &&\n        !isBridgedInterface\n      )\n    },\n\n    /** show DHCP Tab only if ADDRESSED interface is not WAN */\n    showDhcp: ({ intf, showAddressed }) => showAddressed && !intf.wan && !intf.management,\n\n    /** show VRRP Tab for NIC, VLAN types and interface `ADDRESSED` */\n    showVrrp: ({ intf, type, features }) =>\n      features.hasVrrp &&\n      (type === 'BRIDGE' || (['NIC', 'VLAN'].includes(type) && intf.configType === 'ADDRESSED' && !intf.management)),\n\n    /** show NIC Options only if interface is `NIC` and `ADDRESSED` */\n    showNICOptions: ({ intf, status }) =>\n      intf.type === 'NIC' && intf.configType === 'ADDRESSED' && status?.ethSpeed > 0,\n\n    /** show Qos Tab only for WANs and exclude specified interface types */\n    showQos: ({ intf }) => intf.wan && !['OPENVPN', 'WIREGUARD', 'WIFI', 'WWAN', 'IPSEC'].includes(intf.type),\n\n    /** retuns interface names used for validation against duplicate names */\n    interfaceNames: ({ intf, interfaces }) =>\n      interfaces.filter(i => i.interfaceId !== intf.interfaceId).map(i => i.name),\n\n    /**\n     * interface name vaidation rules\n     * - required, max 10 alphas\n     * - no spaces\n     * - unique among the all existing interfaces names\n     */\n    interfaceNameRules: ({ $vuntangle, interfaceNames }) => ({\n      required: true,\n      max: 10,\n      regex: [/^[a-zA-Z][a-zA-Z0-9_]*$/, $vuntangle.$t('interface_name_must_be')],\n      unique_insensitive: { list: interfaceNames, message: $vuntangle.$t('interface_name_already_in_use') },\n    }),\n\n    /**\n     * vaidation rules for the localGateway radio group\n     */\n    localGatewayRules: ({ ipsec, selectedWan }) => ({\n      required: true,\n      conflicting_any_gateways: { local: ipsec.local.gateway, remote: ipsec.remote.gateway },\n      disconnected_wan: { boundWan: selectedWan },\n      validate_gateways: { local: ipsec.local.gateway, remote: ipsec.remote.gateway },\n    }),\n\n    /**\n     * vaidation rules for the remoteGateway radio group\n     */\n    remoteGatewayRules: ({ ipsec }) => ({\n      required: true,\n      conflicting_any_gateways: { local: ipsec.local.gateway, remote: ipsec.remote.gateway },\n      validate_gateways: { local: ipsec.local.gateway, remote: ipsec.remote.gateway },\n    }),\n\n    /**\n     * boundInterfaceId vaidation rules\n     */\n    boundInterfaceIdRules: ({ interfaces, intf }) => {\n      return {\n        required: true,\n        vlan_duplicate: {\n          interfaces,\n          interfaceId: intf.interfaceId, // current interface id\n          boundInterfaceId: null, // passed by field value\n          vlanId: intf.vlanid,\n        },\n      }\n    },\n\n    /**\n     * vlanID vaidation rules\n     */\n    vlanIdRules: ({ interfaces, intf }) => {\n      return {\n        required: true,\n        numeric: true,\n        min_value: 1,\n        max_value: 4094,\n        vlan_duplicate: {\n          interfaces,\n          interfaceId: intf.interfaceId, // current interface id\n          boundInterfaceId: intf.boundInterfaceId,\n          vlanId: null, // passed by field value\n        },\n      }\n    },\n\n    /**\n     * return possible config types for an interface\n     * - for WANs it's only `ADDRESSED`\n     * - otherwise it's `ADDRESSED` or `BRIDGED`\n     */\n    configTypes: ({ $vuntangle, intf }) => {\n      return [\n        { text: $vuntangle.$t('addressed'), value: 'ADDRESSED' },\n        ...(!intf.wan && !intf.management ? [{ text: $vuntangle.$t('bridged'), value: 'BRIDGED' }] : []),\n      ]\n    },\n\n    /** returns interfaces options to be bound, based on interface type */\n    boundToOptions: ({ intf, type, getBoundableNicsOptions, getBoundableInterfacesOptions }) => {\n      if (type === 'VLAN') return getBoundableNicsOptions\n      if (['OPENVPN', 'WIREGUARD', 'IPSEC'].includes(type)) {\n        let includeAnyWan = true\n        if (type === 'WIREGUARD' && intf.wireguardType === 'TUNNEL') includeAnyWan = false\n        return getBoundableInterfacesOptions(includeAnyWan)\n      }\n      return []\n    },\n\n    /** returns interfaces options to be bridged */\n    bridgedToOptions: ({ type, intf, interfaces }) => {\n      let filter = []\n      if (type === 'BRIDGE') {\n        const alreadyBridgedToSet = new Set()\n        interfaces\n          .filter(i => i.interfaceId !== intf.interfaceId && i.type === 'BRIDGE' && i.bridgedInterfaces)\n          .forEach(i => i.bridgedInterfaces.forEach(i => alreadyBridgedToSet.add(i)))\n        filter = interfaces.filter(\n          i =>\n            i.interfaceId !== intf.interfaceId &&\n            ['NIC', 'VLAN', 'WIFI'].includes(i.type) &&\n            !i.wan &&\n            !alreadyBridgedToSet.has(i.interfaceId),\n        )\n      } else {\n        filter = interfaces.filter(i => i.interfaceId !== intf.interfaceId && i.configType === 'ADDRESSED' && !i.wan)\n      }\n      if (!filter.length) return []\n      return filter.map(i => ({ value: i.interfaceId, text: i.name }))\n    },\n\n    /**\n     * Returns select options available for boundable interfaces having conditions:\n     * - interface type is `NIC` or `WWAN`\n     * - interface is `wan`\n     * - interface is `enabled`\n     *\n     * passing `includeAnyWan` true, adds `Any WAN` option\n     */\n    getBoundableInterfacesOptions() {\n      return (includeAnyWan = false) => {\n        const enabledWans = this.interfaces.filter(\n          intf => ['NIC', 'WWAN'].includes(intf.type) && intf.wan && intf.enabled,\n        )\n        const options = enabledWans.map(wan => ({ value: wan.interfaceId, text: wan.name }))\n        if (includeAnyWan) options.unshift({ value: 0, text: this.$vuntangle.$t('any_wan') })\n        return options\n      }\n    },\n\n    /**\n     * Returns select options for all available NICs interfaces\n     * used for VLAN bound interface\n     * BUG? should NICs be `wan` & `enabled`\n     */\n    getBoundableNicsOptions: ({ interfaces }) => {\n      const nics = interfaces.filter(intf => intf.type === 'NIC' || intf.type === 'BRIDGE')\n      return nics.map(nic => ({ value: nic.interfaceId, text: nic.name }))\n    },\n\n    /**\n     * checks if the given interface is part of a bridge or not\n     *\n     * @param intf\n     * @param interfaces\n     * @returns {boolean}\n     */\n    isBridgedInterface: ({ intf, interfaces }) => {\n      const bridgedInterface = interfaces.filter(i => i.bridgedInterfaces?.includes(intf.interfaceId))\n      return bridgedInterface.length > 0\n    },\n  },\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}