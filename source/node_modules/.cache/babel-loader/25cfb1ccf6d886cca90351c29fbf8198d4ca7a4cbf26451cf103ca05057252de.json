{"ast":null,"code":"import _objectSpread from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * This plugin contains functions that deal with widget layout and storage\n */\n\nimport util from './util';\nvar widgets = {\n  breakpoints: {\n    xl: 1980,\n    lg: 1200,\n    md: 996,\n    sm: 768\n  },\n  gridSizes: {\n    xl: 4,\n    lg: 3,\n    md: 2,\n    sm: 1\n  },\n  /**\n   * Get the breakpoint of the users browsers.  Used for initial display of the grid\n   * and saving display on a change.\n   *\n   * @returns {string}\n   */\n  getBreakpoint: function getBreakpoint() {\n    var initialBreakpoint = 'sm';\n    var browserWidth = util.getBrowserWidth();\n    var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(this.breakpoints)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var breakpoint = _step.value;\n        if (browserWidth >= this.breakpoints[breakpoint]) {\n          initialBreakpoint = breakpoint;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return initialBreakpoint;\n  },\n  /**\n   * Get the layout from local storage.\n   *\n   * @param itemName {string}\n   *\n   * @returns {null|Object}\n   */\n  getStoredLayout: function getStoredLayout(itemName) {\n    var dashboardLayout = window.sessionStorage.getItem(itemName);\n    if (dashboardLayout === null) {\n      return null;\n    }\n    return JSON.parse(dashboardLayout);\n  },\n  /**\n   *\n   * Set the new layout into storage.\n   *\n   * @param itemName  {string}\n   * @param newLayout {Object}\n   *\n   * @returns {void}\n   */\n  setStoredLayout: function setStoredLayout(itemName, newLayout) {\n    return window.sessionStorage.setItem(itemName, JSON.stringify(newLayout));\n  },\n  /**\n   * Get a layout for vue-grid.  Will return breakpoint sizes with x,y widgets fit into the grid\n   * based on the size of widgets and columns available.\n   *\n   * @param gridSizes          {Object} Object of key/values like: breakpoint: columns\n   * @param enabledWidgets     {Array}  Array of widget_index's that are enabled on the page\n   * @param widgetComponentMap {Object} Object objects like: widget_index: {component: '', width: 1}\n   *\n   * @returns {{xl: [], md: [], sm: [], lg: []}}\n   */\n  getLayout: function getLayout(enabledWidgets, widgetComponentMap) {\n    var _this = this;\n    var responsiveLayouts = {\n      xl: [],\n      lg: [],\n      md: [],\n      sm: []\n    };\n\n    // inline method to reduce code when inserting rows during iteration and at the end of iteration\n    var addRow = function addRow(row, rowWidth, maxRowWidth, key) {\n      var _responsiveLayouts$ke;\n      // make sure the row has items\n      if (row.length === 0) {\n        return;\n      }\n\n      // if there is no room, make the last widget stretch the full columns\n      if (rowWidth < maxRowWidth) {\n        row[row.length - 1].w += maxRowWidth - rowWidth;\n      }\n\n      // add the row to the layout\n      (_responsiveLayouts$ke = responsiveLayouts[key]).push.apply(_responsiveLayouts$ke, _toConsumableArray(row));\n    };\n\n    // loop through grid sizes\n    var _loop = function _loop(breakpoint) {\n      var maxRowWidth = _this.gridSizes[breakpoint];\n\n      // loop through widgets, add widget to row if it fits or add it to the next row\n      var rowNumber = 0;\n      var rowWidth = 0;\n      var row = [];\n      enabledWidgets.forEach(function (id, i) {\n        // if the widget itself is wider than the max row width, like for sm breakpoint, use the max row width\n        var widgetWidth = widgetComponentMap[id].width > maxRowWidth ? maxRowWidth : widgetComponentMap[id].width;\n        var baseCell = {\n          i: i,\n          id: id,\n          cmp: widgetComponentMap[id].component,\n          w: widgetWidth,\n          h: 1,\n          resize: false\n        };\n\n        // add to the row if there is room\n        if (rowWidth + widgetWidth <= maxRowWidth) {\n          row.push(_objectSpread(_objectSpread({}, baseCell), {}, {\n            x: rowWidth,\n            y: rowNumber\n          }));\n        } else {\n          // add the last row\n          addRow(row, rowWidth, maxRowWidth, breakpoint);\n\n          // add the widget to the next row\n          rowWidth = 0;\n          rowNumber++;\n          row = [_objectSpread(_objectSpread({}, baseCell), {}, {\n            x: rowWidth,\n            y: rowNumber\n          })];\n        }\n\n        // add the widget to the current row width\n        rowWidth += widgetWidth;\n      });\n\n      // add the last row\n      addRow(row, rowWidth, maxRowWidth, breakpoint);\n    };\n    for (var breakpoint in this.gridSizes) {\n      _loop(breakpoint);\n    }\n    return responsiveLayouts;\n  }\n};\nexport default widgets;","map":{"version":3,"names":["util","widgets","breakpoints","xl","lg","md","sm","gridSizes","getBreakpoint","initialBreakpoint","browserWidth","getBrowserWidth","_iterator","_createForOfIteratorHelper","Object","getOwnPropertyNames","_step","s","n","done","breakpoint","value","err","e","f","getStoredLayout","itemName","dashboardLayout","window","sessionStorage","getItem","JSON","parse","setStoredLayout","newLayout","setItem","stringify","getLayout","enabledWidgets","widgetComponentMap","_this","responsiveLayouts","addRow","row","rowWidth","maxRowWidth","key","_responsiveLayouts$ke","length","w","push","apply","_toConsumableArray","_loop","rowNumber","forEach","id","i","widgetWidth","width","baseCell","cmp","component","h","resize","_objectSpread","x","y"],"sources":["/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/vuntangle/src/plugins/widgets.js"],"sourcesContent":["/**\n * This plugin contains functions that deal with widget layout and storage\n */\n\nimport util from './util'\n\nconst widgets = {\n  breakpoints: { xl: 1980, lg: 1200, md: 996, sm: 768 },\n  gridSizes: { xl: 4, lg: 3, md: 2, sm: 1 },\n\n  /**\n   * Get the breakpoint of the users browsers.  Used for initial display of the grid\n   * and saving display on a change.\n   *\n   * @returns {string}\n   */\n  getBreakpoint() {\n    let initialBreakpoint = 'sm'\n    const browserWidth = util.getBrowserWidth()\n    for (const breakpoint of Object.getOwnPropertyNames(this.breakpoints)) {\n      if (browserWidth >= this.breakpoints[breakpoint]) {\n        initialBreakpoint = breakpoint\n        break\n      }\n    }\n\n    return initialBreakpoint\n  },\n\n  /**\n   * Get the layout from local storage.\n   *\n   * @param itemName {string}\n   *\n   * @returns {null|Object}\n   */\n  getStoredLayout(itemName) {\n    const dashboardLayout = window.sessionStorage.getItem(itemName)\n    if (dashboardLayout === null) {\n      return null\n    }\n\n    return JSON.parse(dashboardLayout)\n  },\n\n  /**\n   *\n   * Set the new layout into storage.\n   *\n   * @param itemName  {string}\n   * @param newLayout {Object}\n   *\n   * @returns {void}\n   */\n  setStoredLayout: (itemName, newLayout) => window.sessionStorage.setItem(itemName, JSON.stringify(newLayout)),\n\n  /**\n   * Get a layout for vue-grid.  Will return breakpoint sizes with x,y widgets fit into the grid\n   * based on the size of widgets and columns available.\n   *\n   * @param gridSizes          {Object} Object of key/values like: breakpoint: columns\n   * @param enabledWidgets     {Array}  Array of widget_index's that are enabled on the page\n   * @param widgetComponentMap {Object} Object objects like: widget_index: {component: '', width: 1}\n   *\n   * @returns {{xl: [], md: [], sm: [], lg: []}}\n   */\n  getLayout(enabledWidgets, widgetComponentMap) {\n    const responsiveLayouts = { xl: [], lg: [], md: [], sm: [] }\n\n    // inline method to reduce code when inserting rows during iteration and at the end of iteration\n    const addRow = (row, rowWidth, maxRowWidth, key) => {\n      // make sure the row has items\n      if (row.length === 0) {\n        return\n      }\n\n      // if there is no room, make the last widget stretch the full columns\n      if (rowWidth < maxRowWidth) {\n        row[row.length - 1].w += maxRowWidth - rowWidth\n      }\n\n      // add the row to the layout\n      responsiveLayouts[key].push(...row)\n    }\n\n    // loop through grid sizes\n    for (const breakpoint in this.gridSizes) {\n      const maxRowWidth = this.gridSizes[breakpoint]\n\n      // loop through widgets, add widget to row if it fits or add it to the next row\n      let rowNumber = 0\n      let rowWidth = 0\n      let row = []\n      enabledWidgets.forEach((id, i) => {\n        // if the widget itself is wider than the max row width, like for sm breakpoint, use the max row width\n        const widgetWidth = widgetComponentMap[id].width > maxRowWidth ? maxRowWidth : widgetComponentMap[id].width\n\n        const baseCell = {\n          i,\n          id,\n          cmp: widgetComponentMap[id].component,\n          w: widgetWidth,\n          h: 1,\n          resize: false,\n        }\n\n        // add to the row if there is room\n        if (rowWidth + widgetWidth <= maxRowWidth) {\n          row.push({ ...baseCell, x: rowWidth, y: rowNumber })\n        } else {\n          // add the last row\n          addRow(row, rowWidth, maxRowWidth, breakpoint)\n\n          // add the widget to the next row\n          rowWidth = 0\n          rowNumber++\n          row = [{ ...baseCell, x: rowWidth, y: rowNumber }]\n        }\n\n        // add the widget to the current row width\n        rowWidth += widgetWidth\n      })\n\n      // add the last row\n      addRow(row, rowWidth, maxRowWidth, breakpoint)\n    }\n\n    return responsiveLayouts\n  },\n}\n\nexport default widgets\n"],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA,OAAOA,IAAI,MAAM,QAAQ;AAEzB,IAAMC,OAAO,GAAG;EACdC,WAAW,EAAE;IAAEC,EAAE,EAAE,IAAI;IAAEC,EAAE,EAAE,IAAI;IAAEC,EAAE,EAAE,GAAG;IAAEC,EAAE,EAAE;EAAI,CAAC;EACrDC,SAAS,EAAE;IAAEJ,EAAE,EAAE,CAAC;IAAEC,EAAE,EAAE,CAAC;IAAEC,EAAE,EAAE,CAAC;IAAEC,EAAE,EAAE;EAAE,CAAC;EAEzC;AACF;AACA;AACA;AACA;AACA;EACEE,aAAa,WAAbA,aAAaA,CAAA,EAAG;IACd,IAAIC,iBAAiB,GAAG,IAAI;IAC5B,IAAMC,YAAY,GAAGV,IAAI,CAACW,eAAe,CAAC,CAAC;IAAA,IAAAC,SAAA,GAAAC,0BAAA,CAClBC,MAAM,CAACC,mBAAmB,CAAC,IAAI,CAACb,WAAW,CAAC;MAAAc,KAAA;IAAA;MAArE,KAAAJ,SAAA,CAAAK,CAAA,MAAAD,KAAA,GAAAJ,SAAA,CAAAM,CAAA,IAAAC,IAAA,GAAuE;QAAA,IAA5DC,UAAU,GAAAJ,KAAA,CAAAK,KAAA;QACnB,IAAIX,YAAY,IAAI,IAAI,CAACR,WAAW,CAACkB,UAAU,CAAC,EAAE;UAChDX,iBAAiB,GAAGW,UAAU;UAC9B;QACF;MACF;IAAC,SAAAE,GAAA;MAAAV,SAAA,CAAAW,CAAA,CAAAD,GAAA;IAAA;MAAAV,SAAA,CAAAY,CAAA;IAAA;IAED,OAAOf,iBAAiB;EAC1B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEgB,eAAe,WAAfA,eAAeA,CAACC,QAAQ,EAAE;IACxB,IAAMC,eAAe,GAAGC,MAAM,CAACC,cAAc,CAACC,OAAO,CAACJ,QAAQ,CAAC;IAC/D,IAAIC,eAAe,KAAK,IAAI,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,OAAOI,IAAI,CAACC,KAAK,CAACL,eAAe,CAAC;EACpC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,eAAe,EAAE,SAAjBA,eAAeA,CAAGP,QAAQ,EAAEQ,SAAS;IAAA,OAAKN,MAAM,CAACC,cAAc,CAACM,OAAO,CAACT,QAAQ,EAAEK,IAAI,CAACK,SAAS,CAACF,SAAS,CAAC,CAAC;EAAA;EAE5G;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,SAAS,WAATA,SAASA,CAACC,cAAc,EAAEC,kBAAkB,EAAE;IAAA,IAAAC,KAAA;IAC5C,IAAMC,iBAAiB,GAAG;MAAEtC,EAAE,EAAE,EAAE;MAAEC,EAAE,EAAE,EAAE;MAAEC,EAAE,EAAE,EAAE;MAAEC,EAAE,EAAE;IAAG,CAAC;;IAE5D;IACA,IAAMoC,MAAM,GAAG,SAATA,MAAMA,CAAIC,GAAG,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,GAAG,EAAK;MAAA,IAAAC,qBAAA;MAClD;MACA,IAAIJ,GAAG,CAACK,MAAM,KAAK,CAAC,EAAE;QACpB;MACF;;MAEA;MACA,IAAIJ,QAAQ,GAAGC,WAAW,EAAE;QAC1BF,GAAG,CAACA,GAAG,CAACK,MAAM,GAAG,CAAC,CAAC,CAACC,CAAC,IAAIJ,WAAW,GAAGD,QAAQ;MACjD;;MAEA;MACA,CAAAG,qBAAA,GAAAN,iBAAiB,CAACK,GAAG,CAAC,EAACI,IAAI,CAAAC,KAAA,CAAAJ,qBAAA,EAAAK,kBAAA,CAAIT,GAAG,EAAC;IACrC,CAAC;;IAED;IAAA,IAAAU,KAAA,YAAAA,MAAAjC,UAAA,EACyC;MACvC,IAAMyB,WAAW,GAAGL,KAAI,CAACjC,SAAS,CAACa,UAAU,CAAC;;MAE9C;MACA,IAAIkC,SAAS,GAAG,CAAC;MACjB,IAAIV,QAAQ,GAAG,CAAC;MAChB,IAAID,GAAG,GAAG,EAAE;MACZL,cAAc,CAACiB,OAAO,CAAC,UAACC,EAAE,EAAEC,CAAC,EAAK;QAChC;QACA,IAAMC,WAAW,GAAGnB,kBAAkB,CAACiB,EAAE,CAAC,CAACG,KAAK,GAAGd,WAAW,GAAGA,WAAW,GAAGN,kBAAkB,CAACiB,EAAE,CAAC,CAACG,KAAK;QAE3G,IAAMC,QAAQ,GAAG;UACfH,CAAC,EAADA,CAAC;UACDD,EAAE,EAAFA,EAAE;UACFK,GAAG,EAAEtB,kBAAkB,CAACiB,EAAE,CAAC,CAACM,SAAS;UACrCb,CAAC,EAAES,WAAW;UACdK,CAAC,EAAE,CAAC;UACJC,MAAM,EAAE;QACV,CAAC;;QAED;QACA,IAAIpB,QAAQ,GAAGc,WAAW,IAAIb,WAAW,EAAE;UACzCF,GAAG,CAACO,IAAI,CAAAe,aAAA,CAAAA,aAAA,KAAML,QAAQ;YAAEM,CAAC,EAAEtB,QAAQ;YAAEuB,CAAC,EAAEb;UAAS,EAAE,CAAC;QACtD,CAAC,MAAM;UACL;UACAZ,MAAM,CAACC,GAAG,EAAEC,QAAQ,EAAEC,WAAW,EAAEzB,UAAU,CAAC;;UAE9C;UACAwB,QAAQ,GAAG,CAAC;UACZU,SAAS,EAAE;UACXX,GAAG,GAAG,CAAAsB,aAAA,CAAAA,aAAA,KAAML,QAAQ;YAAEM,CAAC,EAAEtB,QAAQ;YAAEuB,CAAC,EAAEb;UAAS,GAAG;QACpD;;QAEA;QACAV,QAAQ,IAAIc,WAAW;MACzB,CAAC,CAAC;;MAEF;MACAhB,MAAM,CAACC,GAAG,EAAEC,QAAQ,EAAEC,WAAW,EAAEzB,UAAU,CAAC;IAChD,CAAC;IAvCD,KAAK,IAAMA,UAAU,IAAI,IAAI,CAACb,SAAS;MAAA8C,KAAA,CAAAjC,UAAA;IAAA;IAyCvC,OAAOqB,iBAAiB;EAC1B;AACF,CAAC;AAED,eAAexC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}