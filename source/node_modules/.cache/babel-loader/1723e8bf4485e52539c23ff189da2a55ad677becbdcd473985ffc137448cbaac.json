{"ast":null,"code":"import _regeneratorRuntime from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport cloneDeep from 'lodash/cloneDeep';\nimport Ipv4PrefixAutocomplete from '../../../../components/Ipv4PrefixAutocomplete';\nexport default {\n  components: {\n    Ipv4PrefixAutocomplete: Ipv4PrefixAutocomplete\n  },\n  props: {\n    type: {\n      type: String,\n      \"default\": null\n    },\n    // 'local' or 'remote'\n    ipsec: {\n      type: Object,\n      \"default\": function _default() {\n        return null;\n      }\n    },\n    // full ipsec object\n    index: {\n      type: Number,\n      \"default\": -1\n    } // editing network index\n  },\n  data: function data() {\n    return {\n      // default network ip/prefix entry\n      entry: {\n        network: '',\n        prefix: 24\n      },\n      overlappingSubnet: null,\n      suggestedNetwork: null\n    };\n  },\n  computed: {\n    /**\n     * returns existing local/remote networks IPs\n     * used to validate against conflicting entry\n     */\n    conflictIps: function conflictIps() {\n      var _this = this;\n      var ips = [];\n      this.ipsec.local.networks.forEach(function (n) {\n        // exclude local editing IP\n        if (_this.type === 'local' && _this.index >= 0 && _this.entry.network === n.network) {\n          return;\n        }\n        ips.push(n.network);\n      });\n      this.ipsec.remote.networks.forEach(function (n) {\n        // exclude remote editing IP\n        if (_this.type === 'remote' && _this.index >= 0 && _this.entry.network === n.network) {\n          return;\n        }\n        ips.push(n.network);\n      });\n      return ips;\n    }\n  },\n  watch: {\n    entry: {\n      deep: true,\n      handler: function handler(value) {\n        // MFW-2023 when setting network 0.0.0.0, automatically set prefix to 0\n        if (value.network === '0.0.0.0') {\n          value.prefix = 0;\n        }\n        // gets the subnet of an address entry\n        this.suggestedNetwork = this.$vuntangle.net.info(value.network, value.prefix);\n      }\n    }\n  },\n  created: function created() {\n    // populate entry when editing a network\n    if (this.index >= 0) {\n      this.entry = cloneDeep(this.ipsec[this.type].networks[this.index]);\n    }\n  },\n  methods: {\n    /**\n     * Check if added/edited local/remote network conflicts (overlaps)\n     * with already defined remote/local networks\n     */\n    checkOverlappingSubnet: function checkOverlappingSubnet() {\n      var _this2 = this;\n      this.overlappingSubnet = null;\n      var networks = this.type === 'local' ? this.ipsec.remote.networks : this.ipsec.local.networks;\n      networks.forEach(function (n) {\n        // skip check if 0.0.0.0/0 network\n        if (n.network === '0.0.0.0' && n.prefix === 0) {\n          return;\n        }\n        var existingSubnet = \"\".concat(n.network, \"/\").concat(n.prefix);\n        var newSubnet = \"\".concat(_this2.entry.network, \"/\").concat(_this2.entry.prefix);\n        var conflict = _this2.$vuntangle.net.subnetConflict(existingSubnet, newSubnet);\n        if (!_this2.overlappingSubnet && conflict) {\n          _this2.overlappingSubnet = existingSubnet;\n        }\n      });\n    },\n    action: function action() {\n      var _this3 = this;\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var isValid, isFullTunnel, networksClone;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this3.$refs.obs.validate();\n            case 2:\n              isValid = _context.sent;\n              if (isValid) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 5:\n              isFullTunnel = _this3.entry.network === '0.0.0.0' && _this3.entry.prefix === 0; // check subnet conflicts, but skip 0.0.0.0/0\n              if (isFullTunnel) {\n                _context.next = 10;\n                break;\n              }\n              _this3.checkOverlappingSubnet();\n              if (!_this3.overlappingSubnet) {\n                _context.next = 10;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 10:\n              // use actual subnets instead of given addresses\n              _this3.entry.network = _this3.suggestedNetwork.networkAddress;\n              _this3.entry.prefix = parseInt(_this3.suggestedNetwork.cidr);\n\n              // cloning to be able to mutate list\n              networksClone = cloneDeep(_this3.ipsec[_this3.type].networks);\n              if (_this3.index > -1) {\n                networksClone[_this3.index] = _this3.entry; // update entry\n              } else if (isFullTunnel) {\n                networksClone.unshift(_this3.entry); // add first 0.0.0.0/0\n              } else {\n                networksClone.push(_this3.entry); // add last new entry\n              }\n              _this3.$set(_this3.ipsec[_this3.type], 'networks', networksClone);\n              _this3.$emit('close');\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    }\n  }\n};","map":{"version":3,"names":["cloneDeep","Ipv4PrefixAutocomplete","components","props","type","String","ipsec","Object","default","index","Number","data","entry","network","prefix","overlappingSubnet","suggestedNetwork","computed","conflictIps","_this","ips","local","networks","forEach","n","push","remote","watch","deep","handler","value","$vuntangle","net","info","created","methods","checkOverlappingSubnet","_this2","existingSubnet","concat","newSubnet","conflict","subnetConflict","action","_this3","_asyncToGenerator","_regeneratorRuntime","mark","_callee","isValid","isFullTunnel","networksClone","wrap","_callee$","_context","prev","next","$refs","obs","validate","sent","abrupt","networkAddress","parseInt","cidr","unshift","$set","$emit","stop"],"sources":["node_modules/vuntangle/src/shared/SettingsInterface/components/ipsec/IpsecNetworkDialog.vue"],"sourcesContent":["<!--\n  dialog component for editing IPsec local/remote networks\n-->\n<template>\n  <div>\n    <ValidationObserver ref=\"obs\">\n      <v-row class=\"my-0\">\n        <v-col>\n          <!-- IP address -->\n          <ValidationProvider\n            v-slot=\"{ errors }\"\n            :rules=\"{\n              required: true,\n              ip: true,\n              unique_insensitive: { list: conflictIps, message: $t('ipsec_network_ip_conflict') },\n            }\"\n          >\n            <u-text-field\n              v-model=\"entry.network\"\n              :label=\"$t('ip_address')\"\n              :error-messages=\"errors\"\n              class=\"mr-4\"\n              @keydown.space=\"event => event.preventDefault()\"\n            >\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </u-text-field>\n          </ValidationProvider>\n        </v-col>\n        <v-col>\n          <!-- prefix -->\n          <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n            <ipv-4-prefix-autocomplete v-model=\"entry.prefix\" :min=\"0\" :errors=\"errors\" />\n          </ValidationProvider>\n        </v-col>\n      </v-row>\n    </ValidationObserver>\n\n    <!-- suggested subnet based on user input that will be forced upon add/edit -->\n    <u-alert v-if=\"!overlappingSubnet && suggestedNetwork && suggestedNetwork.networkAddress !== entry.network\">\n      <span\n        v-html=\"$t('ipsec_subnet_suggested_network', [`${suggestedNetwork.networkAddress}/${suggestedNetwork.cidr}`])\"\n      />\n    </u-alert>\n\n    <!-- error display for conflicting networks -->\n    <u-alert v-if=\"overlappingSubnet\" error>\n      {{ $t(`ipsec_subnet_${type === 'local' ? 'remote' : 'local'}_conflict`, [overlappingSubnet]) }}\n    </u-alert>\n  </div>\n</template>\n<script>\n  import cloneDeep from 'lodash/cloneDeep'\n  import Ipv4PrefixAutocomplete from '../../../../components/Ipv4PrefixAutocomplete'\n\n  export default {\n    components: {\n      Ipv4PrefixAutocomplete,\n    },\n    props: {\n      type: { type: String, default: null }, // 'local' or 'remote'\n      ipsec: { type: Object, default: () => null }, // full ipsec object\n      index: { type: Number, default: -1 }, // editing network index\n    },\n\n    data: () => ({\n      // default network ip/prefix entry\n      entry: { network: '', prefix: 24 },\n      overlappingSubnet: null,\n      suggestedNetwork: null,\n    }),\n\n    computed: {\n      /**\n       * returns existing local/remote networks IPs\n       * used to validate against conflicting entry\n       */\n      conflictIps() {\n        const ips = []\n        this.ipsec.local.networks.forEach(n => {\n          // exclude local editing IP\n          if (this.type === 'local' && this.index >= 0 && this.entry.network === n.network) {\n            return\n          }\n          ips.push(n.network)\n        })\n        this.ipsec.remote.networks.forEach(n => {\n          // exclude remote editing IP\n          if (this.type === 'remote' && this.index >= 0 && this.entry.network === n.network) {\n            return\n          }\n          ips.push(n.network)\n        })\n        return ips\n      },\n    },\n\n    watch: {\n      entry: {\n        deep: true,\n        handler(value) {\n          // MFW-2023 when setting network 0.0.0.0, automatically set prefix to 0\n          if (value.network === '0.0.0.0') {\n            value.prefix = 0\n          }\n          // gets the subnet of an address entry\n          this.suggestedNetwork = this.$vuntangle.net.info(value.network, value.prefix)\n        },\n      },\n    },\n\n    created() {\n      // populate entry when editing a network\n      if (this.index >= 0) {\n        this.entry = cloneDeep(this.ipsec[this.type].networks[this.index])\n      }\n    },\n\n    methods: {\n      /**\n       * Check if added/edited local/remote network conflicts (overlaps)\n       * with already defined remote/local networks\n       */\n      checkOverlappingSubnet() {\n        this.overlappingSubnet = null\n        const networks = this.type === 'local' ? this.ipsec.remote.networks : this.ipsec.local.networks\n        networks.forEach(n => {\n          // skip check if 0.0.0.0/0 network\n          if (n.network === '0.0.0.0' && n.prefix === 0) {\n            return\n          }\n          const existingSubnet = `${n.network}/${n.prefix}`\n          const newSubnet = `${this.entry.network}/${this.entry.prefix}`\n\n          const conflict = this.$vuntangle.net.subnetConflict(existingSubnet, newSubnet)\n          if (!this.overlappingSubnet && conflict) {\n            this.overlappingSubnet = existingSubnet\n          }\n        })\n      },\n\n      async action() {\n        const isValid = await this.$refs.obs.validate()\n        if (!isValid) return\n\n        const isFullTunnel = this.entry.network === '0.0.0.0' && this.entry.prefix === 0\n\n        // check subnet conflicts, but skip 0.0.0.0/0\n        if (!isFullTunnel) {\n          this.checkOverlappingSubnet()\n          if (this.overlappingSubnet) {\n            return\n          }\n        }\n\n        // use actual subnets instead of given addresses\n        this.entry.network = this.suggestedNetwork.networkAddress\n        this.entry.prefix = parseInt(this.suggestedNetwork.cidr)\n\n        // cloning to be able to mutate list\n        const networksClone = cloneDeep(this.ipsec[this.type].networks)\n\n        if (this.index > -1) {\n          networksClone[this.index] = this.entry // update entry\n        } else if (isFullTunnel) {\n          networksClone.unshift(this.entry) // add first 0.0.0.0/0\n        } else {\n          networksClone.push(this.entry) // add last new entry\n        }\n\n        this.$set(this.ipsec[this.type], 'networks', networksClone)\n        this.$emit('close')\n      },\n    },\n  }\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}