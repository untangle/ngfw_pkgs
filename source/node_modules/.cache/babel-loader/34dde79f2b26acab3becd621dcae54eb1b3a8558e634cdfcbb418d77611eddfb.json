{"ast":null,"code":"import \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport draggable from 'vuedraggable';\nimport defaults from '../../defaults';\nimport mixin from '../mixin';\nimport IpsecNetworkItem from './IpsecNetworkItem.vue';\nimport IpsecNetworkDialog from './IpsecNetworkDialog.vue';\nexport default {\n  components: {\n    draggable: draggable,\n    IpsecNetworkItem: IpsecNetworkItem\n  },\n  mixins: [mixin],\n  inject: ['$intf', '$interfaces', '$onGetAllInterfaceStatus'],\n  data: function data() {\n    return {\n      remoteGatewayIp: '',\n      // keeps a copy of an existing remote gateway IP\n      selectedWan: null,\n      drag: false,\n      interfaceStatusAll: []\n    };\n  },\n  computed: {\n    intf: function intf(_ref) {\n      var $intf = _ref.$intf;\n      return $intf();\n    },\n    interfaces: function interfaces(_ref2) {\n      var $interfaces = _ref2.$interfaces;\n      return $interfaces();\n    },\n    ipsec: function ipsec(_ref3) {\n      var intf = _ref3.intf;\n      return intf.ipsec;\n    },\n    device: function device(_ref4) {\n      var intf = _ref4.intf;\n      return intf.device;\n    },\n    boundInterfaceId: function boundInterfaceId(_ref5) {\n      var intf = _ref5.intf;\n      return intf.boundInterfaceId;\n    },\n    dragOptions: function dragOptions() {\n      return {\n        animation: 200,\n        group: 'description',\n        disabled: false,\n        ghostClass: 'ghost'\n      };\n    },\n    /**\n     * localGateway is used to compute the final ipsec.local.gateway\n     * based on selection and bound interface\n     * */\n    localGateway: {\n      get: function get() {\n        var _this$selectedWan;\n        var gateway = this.ipsec.local.gateway;\n        if (gateway === '%any') return 'any';\n        if (gateway === ((_this$selectedWan = this.selectedWan) === null || _this$selectedWan === void 0 ? void 0 : _this$selectedWan.address)) return 'wan';\n        return 'custom';\n      },\n      set: function set(value) {\n        if (value === 'any') {\n          this.ipsec.local.gateway = '%any';\n        }\n        if (value === 'wan') {\n          this.ipsec.local.gateway = this.selectedWan.address;\n        }\n        if (value === 'custom') {\n          this.ipsec.local.gateway = null;\n        }\n      }\n    },\n    /**\n     * remoteGateway is used to compute the final ipsec.remote.gateway\n     * */\n    remoteGateway: {\n      get: function get() {\n        var gateway = this.ipsec.remote.gateway;\n        if (gateway === '%any') return 'any';\n        return 'custom';\n      },\n      set: function set(value) {\n        if (value === 'any') {\n          this.remoteGatewayIp = this.ipsec.remote.gateway;\n          this.ipsec.remote.gateway = '%any';\n        }\n        if (value === 'custom') {\n          this.ipsec.remote.gateway = this.remoteGatewayIp;\n        }\n      }\n    },\n    fullTunnelLocal: {\n      get: function get() {\n        return this.ipsec.local.networks.findIndex(function (n) {\n          return n.network === '0.0.0.0' && n.prefix === 0;\n        }) >= 0;\n      },\n      set: function set(value) {\n        if (value) {\n          if (this.fullTunnelRemote) {\n            this.ipsec.remote.networks.shift();\n          }\n          this.ipsec.local.networks.unshift(defaults.ipsec_network);\n        } else {\n          this.ipsec.local.networks.shift();\n        }\n      }\n    },\n    fullTunnelRemote: {\n      get: function get() {\n        return this.ipsec.remote.networks.findIndex(function (n) {\n          return n.network === '0.0.0.0' && n.prefix === 0;\n        }) >= 0;\n      },\n      set: function set(value) {\n        if (value) {\n          if (this.fullTunnelLocal) {\n            this.ipsec.local.networks.shift();\n          }\n          this.ipsec.remote.networks.unshift(defaults.ipsec_network);\n        } else {\n          this.ipsec.remote.networks.shift();\n        }\n      }\n    }\n  },\n  watch: {\n    /**\n     * MFW-2062\n     * Watcher that sets local gateway based on bound interface wan selection\n     */\n    boundInterfaceId: {\n      immediate: true,\n      /**\n       * Watcher handler\n       * @param {Number} id - the bound interface id\n       */\n      handler: function handler(id) {\n        var _this$interfaceStatus,\n          _this = this;\n        // upon creation no WAN selected\n        if (id === null || id === 0) {\n          this.ipsec.local.gateway = '%any';\n          this.selectedWan = null;\n          return;\n        }\n        var intfStatus = (_this$interfaceStatus = this.interfaceStatusAll) === null || _this$interfaceStatus === void 0 ? void 0 : _this$interfaceStatus.find(function (intf) {\n          return intf.interfaceId === id;\n        });\n        if (!intfStatus) return;\n        var wanIp = this.getWanIp(intfStatus);\n\n        // specific wan selected\n        if (id > 0) {\n          this.selectedWan = {\n            name: intfStatus === null || intfStatus === void 0 ? void 0 : intfStatus.name,\n            address: wanIp\n          };\n\n          // populate local gateway with selected wan\n          this.ipsec.local.gateway = this.selectedWan.address;\n\n          // checks if current local gateway matches one of the wans, and updates it value based on selection\n          this.boundToOptions.forEach(function (opt) {\n            var _this$interfaceStatus2;\n            var wanStatus = (_this$interfaceStatus2 = _this.interfaceStatusAll) === null || _this$interfaceStatus2 === void 0 ? void 0 : _this$interfaceStatus2.find(function (stat) {\n              return stat.name === opt.text;\n            });\n            if (_this.ipsec.local.gateway === _this.getWanIp(wanStatus)) {\n              _this.ipsec.local.gateway = _this.selectedWan.address;\n            }\n          });\n        }\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this2 = this;\n    /**\n     * if device is null than action is to add a new interface\n     * so local networks are populated from available non-WANs\n     */\n    this.$onGetAllInterfaceStatus(function (resp) {\n      _this2.interfaceStatusAll = resp;\n      if (!_this2.device) {\n        _this2.addLocalNetworks();\n      }\n    });\n\n    /**\n     * keeps a copy of an existing remote gateway IP to be reused in case\n     * of switching back and forth `%any` address\n     */\n    this.remoteGatewayIp = this.ipsec.remote.gateway !== '%any' ? this.ipsec.remote.gateway : '';\n  },\n  methods: {\n    /**\n     * Extracts IPv4 address from status of a given interface\n     * @param {Object} status\n     */\n    getWanIp: function getWanIp(status) {\n      var _status$ip4Addr, _status$ip4Addr$;\n      if (!status || !status.ip4Addr || ((_status$ip4Addr = status.ip4Addr) === null || _status$ip4Addr === void 0 ? void 0 : _status$ip4Addr.length) === 0) {\n        return '';\n      }\n      return ((_status$ip4Addr$ = status.ip4Addr[0]) === null || _status$ip4Addr$ === void 0 ? void 0 : _status$ip4Addr$.split('/')[0]) || '';\n    },\n    /**\n     * Populates Local Networks with available non-WANs for a new IPsec tunnel\n     */\n    addLocalNetworks: function addLocalNetworks() {\n      var _this$interfaceStatus3,\n        _this3 = this;\n      var localNetworks = [];\n      if (!((_this$interfaceStatus3 = this.interfaceStatusAll) !== null && _this$interfaceStatus3 !== void 0 && _this$interfaceStatus3.length)) {\n        return;\n      }\n      this.interfaceStatusAll.forEach(function (intf) {\n        var _intf$ip4Addr;\n        // exclude WANs or bridged interfaces\n        if (intf.wan || intf.configType === 'BRIDGED' || !((_intf$ip4Addr = intf.ip4Addr) !== null && _intf$ip4Addr !== void 0 && _intf$ip4Addr.length)) {\n          return;\n        }\n        var ip = intf.ip4Addr[0] || null;\n        var network = (ip === null || ip === void 0 ? void 0 : ip.split('/')[0]) || '';\n        var prefix = ip !== null && ip !== void 0 && ip.split('/')[1] ? parseInt(ip === null || ip === void 0 ? void 0 : ip.split('/')[1]) : 24;\n        if (network && prefix) {\n          // get the subnet for the address/prefix\n          var subnet = _this3.$vuntangle.net.info(network, prefix);\n          localNetworks.push({\n            network: subnet.networkAddress,\n            prefix: subnet.cidr\n          });\n        }\n      });\n      this.ipsec.local.networks = localNetworks;\n    },\n    /**\n     * Shows an editing dialog for network\n     * @param {Number} index - the index of the network being edited (-1 means new)\n     * @param {String} grid - for which network (local or remote)\n     */\n    onEdit: function onEdit(index, grid) {\n      this.$vuntangle.dialog.show({\n        title: index === -1 ? this.$t(\"add_\".concat(grid, \"_network\")) : this.$t(\"edit_\".concat(grid, \"_network\")),\n        component: IpsecNetworkDialog,\n        width: 600,\n        actionLabel: index === -1 ? this.$t('add') : this.$t('update'),\n        componentProps: {\n          type: grid,\n          // type: 'local' or 'remote'\n          ipsec: this.ipsec,\n          index: index\n        }\n      });\n    },\n    /**\n     * Removes a network from list\n     * @param {Number} index - the index of the network to be removed\n     * @param {String} grid - from which side (local or remote)\n     */\n    onDelete: function onDelete(index, grid) {\n      this.ipsec[grid].networks.splice(index, 1);\n    }\n  }\n};","map":{"version":3,"names":["draggable","defaults","mixin","IpsecNetworkItem","IpsecNetworkDialog","components","mixins","inject","data","remoteGatewayIp","selectedWan","drag","interfaceStatusAll","computed","intf","_ref","$intf","interfaces","_ref2","$interfaces","ipsec","_ref3","device","_ref4","boundInterfaceId","_ref5","dragOptions","animation","group","disabled","ghostClass","localGateway","get","_this$selectedWan","gateway","local","address","set","value","remoteGateway","remote","fullTunnelLocal","networks","findIndex","n","network","prefix","fullTunnelRemote","shift","unshift","ipsec_network","watch","immediate","handler","id","_this$interfaceStatus","_this","intfStatus","find","interfaceId","wanIp","getWanIp","name","boundToOptions","forEach","opt","_this$interfaceStatus2","wanStatus","stat","text","mounted","_this2","$onGetAllInterfaceStatus","resp","addLocalNetworks","methods","status","_status$ip4Addr","_status$ip4Addr$","ip4Addr","length","split","_this$interfaceStatus3","_this3","localNetworks","_intf$ip4Addr","wan","configType","ip","parseInt","subnet","$vuntangle","net","info","push","networkAddress","cidr","onEdit","index","grid","dialog","show","title","$t","concat","component","width","actionLabel","componentProps","type","onDelete","splice"],"sources":["node_modules/vuntangle/src/shared/SettingsInterface/components/ipsec/IpsecNetwork.vue"],"sourcesContent":["<!--\n  component for editing local and remote network settings for IPsec service/tunnel\n-->\n<template>\n  <div>\n    <v-checkbox\n      v-model=\"ipsec.singleSubnetNegotiation\"\n      :label=\"$t('ipsec_single_subnet_negotiation')\"\n      class=\"mb-4 mt-0\"\n      hide-details\n    />\n    <v-row class=\"mt-4\">\n      <v-col>\n        <p class=\"font-weight-bold mb-2\">{{ $t('local_gateway') }}</p>\n\n        <div class=\"d-flex align-center\">\n          <ValidationProvider v-slot=\"{ errors }\" :rules=\"localGatewayRules\">\n            <v-radio-group v-model=\"localGateway\" row hide-details class=\"my-2 py-0\">\n              <v-radio value=\"any\" :label=\"$t('any')\" />\n              <v-radio v-if=\"selectedWan\" value=\"wan\" :label=\"`${selectedWan.name}`\" />\n              <v-radio v-if=\"selectedWan\" value=\"custom\" :label=\"$t('custom')\" />\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </v-radio-group>\n          </ValidationProvider>\n\n          <v-spacer />\n\n          <span v-if=\"selectedWan && localGateway === 'wan'\">{{ selectedWan.address }}</span>\n\n          <!-- local gateway IP address -->\n          <ValidationProvider\n            v-if=\"localGateway === 'custom'\"\n            v-slot=\"{ errors }\"\n            :rules=\"{ required: localGateway === 'custom', ip: localGateway === 'custom' }\"\n            class=\"flex-grow-1\"\n          >\n            <u-text-field\n              v-model=\"ipsec.local.gateway\"\n              :error-messages=\"errors\"\n              :disabled=\"localGateway !== 'custom'\"\n              :placeholder=\"localGateway === 'custom' ? $t('ipv4_address') : ''\"\n            >\n              <template v-if=\"errors.length\" #append>\n                <u-errors-tooltip :errors=\"errors\" />\n              </template>\n            </u-text-field>\n          </ValidationProvider>\n        </div>\n\n        <br />\n        <p class=\"font-weight-bold mb-2\">{{ $t('local_networks') }}</p>\n\n        <v-checkbox v-model=\"fullTunnelLocal\" :label=\"$t('full_tunnel_mode')\" class=\"mb-4 mt-0\" hide-details />\n\n        <u-alert v-if=\"fullTunnelLocal && ipsec.local.networks.length > 1\">\n          <span>{{ $t('ipsec_full_tunnel_local_info') }}</span>\n        </u-alert>\n\n        <u-alert v-if=\"!ipsec.local.networks.length\" class=\"mb-1\">\n          <span>{{ $t('no_networks_defined') }}</span>\n        </u-alert>\n\n        <!-- MFW-1963 using a hidden component to handle validation for at least one local network to be defined -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"min_value: 1\">\n          <u-text-field v-model=\"ipsec.local.networks.length\" type=\"number\" class=\"d-none\" />\n          <!-- as the component is hidden, using an alert above the grid to show it -->\n          <u-alert v-if=\"errors.length\" error>{{ $t('ipsec_local_networks_required') }}</u-alert>\n        </ValidationProvider>\n\n        <draggable v-model=\"ipsec.local.networks\" v-bind=\"dragOptions\" @start=\"drag = true\" @end=\"drag = false\">\n          <transition-group>\n            <ipsec-network-item\n              v-for=\"(item, index) in ipsec.local.networks\"\n              :key=\"item.network + item.prefix\"\n              :ipsec=\"ipsec\"\n              :index=\"index\"\n              :item=\"item\"\n              type=\"local\"\n              :full-tunnel=\"fullTunnelLocal\"\n            />\n          </transition-group>\n        </draggable>\n\n        <div class=\"d-flex align-center\">\n          <span v-if=\"!fullTunnelLocal && ipsec.local.networks.length > 1\" class=\"caption grey--text\">\n            {{ $t('ipsec_networks_drag') }}\n          </span>\n          <v-spacer />\n          <u-btn class=\"my-2\" :disabled=\"fullTunnelLocal\" @click=\"onEdit(-1, 'local')\">\n            {{ $t('add_local_network') }}\n          </u-btn>\n        </div>\n      </v-col>\n\n      <v-divider vertical class=\"mx-8\" />\n\n      <v-col>\n        <p class=\"font-weight-bold mb-2\">{{ $t('remote_gateway') }}</p>\n\n        <div class=\"d-flex align-center\">\n          <ValidationProvider v-slot=\"{ errors }\" :rules=\"remoteGatewayRules\">\n            <v-radio-group v-model=\"remoteGateway\" row hide-details class=\"my-2 py-0\">\n              <v-radio value=\"any\" :label=\"$t('any')\" />\n              <v-radio value=\"custom\" :label=\"$t('custom')\" />\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </v-radio-group>\n          </ValidationProvider>\n\n          <!-- remote gateway IP address -->\n          <ValidationProvider\n            v-slot=\"{ errors }\"\n            :rules=\"{ required: remoteGateway === 'custom', ip: remoteGateway === 'custom' }\"\n            class=\"flex-grow-1\"\n          >\n            <u-text-field\n              v-if=\"remoteGateway !== 'any'\"\n              v-model=\"ipsec.remote.gateway\"\n              :error-messages=\"errors\"\n              :disabled=\"remoteGateway !== 'custom'\"\n              :placeholder=\"remoteGateway === 'custom' ? $t('ipv4_address') : ''\"\n            >\n              <template v-if=\"errors.length\" #append>\n                <u-errors-tooltip :errors=\"errors\" />\n              </template>\n            </u-text-field>\n          </ValidationProvider>\n        </div>\n\n        <br />\n        <p class=\"font-weight-bold mb-2\">{{ $t('remote_networks') }}</p>\n\n        <v-checkbox v-model=\"fullTunnelRemote\" :label=\"$t('full_tunnel_mode')\" class=\"mb-4 mt-0\" hide-details />\n\n        <u-alert v-if=\"fullTunnelRemote && ipsec.remote.networks.length > 1\">\n          <span class=\"body-2\">{{ $t('ipsec_full_tunnel_remote_info') }}</span>\n        </u-alert>\n\n        <u-alert v-if=\"!ipsec.remote.networks.length\" class=\"mb-1\">\n          <span>{{ $t('no_networks_defined') }}</span>\n        </u-alert>\n\n        <!-- MFW-1963 using a hidden component to handle validation for at least one remote network to be defined -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"min_value: 1\">\n          <u-text-field v-model=\"ipsec.remote.networks.length\" type=\"number\" class=\"d-none\" />\n          <!-- as the component is hidden, using an alert above the grid to show it -->\n          <u-alert v-if=\"errors.length\" error>{{ $t('ipsec_remote_networks_required') }}</u-alert>\n        </ValidationProvider>\n\n        <draggable v-model=\"ipsec.remote.networks\" v-bind=\"dragOptions\" @start=\"drag = true\" @end=\"drag = false\">\n          <transition-group>\n            <ipsec-network-item\n              v-for=\"(item, index) in ipsec.remote.networks\"\n              :key=\"item.network + item.prefix\"\n              :ipsec=\"ipsec\"\n              :index=\"index\"\n              :item=\"item\"\n              type=\"remote\"\n              :full-tunnel=\"fullTunnelRemote\"\n            />\n          </transition-group>\n        </draggable>\n\n        <div class=\"d-flex align-center\">\n          <span v-if=\"!fullTunnelRemote && ipsec.remote.networks.length > 1\" class=\"caption grey--text\">\n            {{ $t('ipsec_networks_drag') }}\n          </span>\n          <v-spacer />\n          <u-btn class=\"my-2\" :disabled=\"fullTunnelRemote\" @click=\"onEdit(-1, 'remote')\">\n            {{ $t('add_remote_network') }}\n          </u-btn>\n        </div>\n      </v-col>\n    </v-row>\n  </div>\n</template>\n<script>\n  import draggable from 'vuedraggable'\n  import defaults from '../../defaults'\n  import mixin from '../mixin'\n  import IpsecNetworkItem from './IpsecNetworkItem.vue'\n  import IpsecNetworkDialog from './IpsecNetworkDialog.vue'\n\n  export default {\n    components: { draggable, IpsecNetworkItem },\n    mixins: [mixin],\n    inject: ['$intf', '$interfaces', '$onGetAllInterfaceStatus'],\n    data() {\n      return {\n        remoteGatewayIp: '', // keeps a copy of an existing remote gateway IP\n        selectedWan: null,\n        drag: false,\n        interfaceStatusAll: [],\n      }\n    },\n\n    computed: {\n      intf: ({ $intf }) => $intf(),\n      interfaces: ({ $interfaces }) => $interfaces(),\n      ipsec: ({ intf }) => intf.ipsec,\n      device: ({ intf }) => intf.device,\n      boundInterfaceId: ({ intf }) => intf.boundInterfaceId,\n\n      dragOptions() {\n        return {\n          animation: 200,\n          group: 'description',\n          disabled: false,\n          ghostClass: 'ghost',\n        }\n      },\n\n      /**\n       * localGateway is used to compute the final ipsec.local.gateway\n       * based on selection and bound interface\n       * */\n      localGateway: {\n        get() {\n          const gateway = this.ipsec.local.gateway\n          if (gateway === '%any') return 'any'\n          if (gateway === this.selectedWan?.address) return 'wan'\n          return 'custom'\n        },\n        set(value) {\n          if (value === 'any') {\n            this.ipsec.local.gateway = '%any'\n          }\n          if (value === 'wan') {\n            this.ipsec.local.gateway = this.selectedWan.address\n          }\n          if (value === 'custom') {\n            this.ipsec.local.gateway = null\n          }\n        },\n      },\n\n      /**\n       * remoteGateway is used to compute the final ipsec.remote.gateway\n       * */\n      remoteGateway: {\n        get() {\n          const gateway = this.ipsec.remote.gateway\n          if (gateway === '%any') return 'any'\n          return 'custom'\n        },\n        set(value) {\n          if (value === 'any') {\n            this.remoteGatewayIp = this.ipsec.remote.gateway\n            this.ipsec.remote.gateway = '%any'\n          }\n          if (value === 'custom') {\n            this.ipsec.remote.gateway = this.remoteGatewayIp\n          }\n        },\n      },\n\n      fullTunnelLocal: {\n        get() {\n          return this.ipsec.local.networks.findIndex(n => n.network === '0.0.0.0' && n.prefix === 0) >= 0\n        },\n        set(value) {\n          if (value) {\n            if (this.fullTunnelRemote) {\n              this.ipsec.remote.networks.shift()\n            }\n            this.ipsec.local.networks.unshift(defaults.ipsec_network)\n          } else {\n            this.ipsec.local.networks.shift()\n          }\n        },\n      },\n\n      fullTunnelRemote: {\n        get() {\n          return this.ipsec.remote.networks.findIndex(n => n.network === '0.0.0.0' && n.prefix === 0) >= 0\n        },\n        set(value) {\n          if (value) {\n            if (this.fullTunnelLocal) {\n              this.ipsec.local.networks.shift()\n            }\n            this.ipsec.remote.networks.unshift(defaults.ipsec_network)\n          } else {\n            this.ipsec.remote.networks.shift()\n          }\n        },\n      },\n    },\n\n    watch: {\n      /**\n       * MFW-2062\n       * Watcher that sets local gateway based on bound interface wan selection\n       */\n      boundInterfaceId: {\n        immediate: true,\n        /**\n         * Watcher handler\n         * @param {Number} id - the bound interface id\n         */\n        handler(id) {\n          // upon creation no WAN selected\n          if (id === null || id === 0) {\n            this.ipsec.local.gateway = '%any'\n            this.selectedWan = null\n            return\n          }\n\n          const intfStatus = this.interfaceStatusAll?.find(intf => intf.interfaceId === id)\n          if (!intfStatus) return\n\n          const wanIp = this.getWanIp(intfStatus)\n\n          // specific wan selected\n          if (id > 0) {\n            this.selectedWan = {\n              name: intfStatus?.name,\n              address: wanIp,\n            }\n\n            // populate local gateway with selected wan\n            this.ipsec.local.gateway = this.selectedWan.address\n\n            // checks if current local gateway matches one of the wans, and updates it value based on selection\n            this.boundToOptions.forEach(opt => {\n              const wanStatus = this.interfaceStatusAll?.find(stat => stat.name === opt.text)\n              if (this.ipsec.local.gateway === this.getWanIp(wanStatus)) {\n                this.ipsec.local.gateway = this.selectedWan.address\n              }\n            })\n          }\n        },\n      },\n    },\n\n    mounted() {\n      /**\n       * if device is null than action is to add a new interface\n       * so local networks are populated from available non-WANs\n       */\n      this.$onGetAllInterfaceStatus(resp => {\n        this.interfaceStatusAll = resp\n        if (!this.device) {\n          this.addLocalNetworks()\n        }\n      })\n\n      /**\n       * keeps a copy of an existing remote gateway IP to be reused in case\n       * of switching back and forth `%any` address\n       */\n      this.remoteGatewayIp = this.ipsec.remote.gateway !== '%any' ? this.ipsec.remote.gateway : ''\n    },\n\n    methods: {\n      /**\n       * Extracts IPv4 address from status of a given interface\n       * @param {Object} status\n       */\n      getWanIp(status) {\n        if (!status || !status.ip4Addr || status.ip4Addr?.length === 0) {\n          return ''\n        }\n        return status.ip4Addr[0]?.split('/')[0] || ''\n      },\n\n      /**\n       * Populates Local Networks with available non-WANs for a new IPsec tunnel\n       */\n      addLocalNetworks() {\n        const localNetworks = []\n\n        if (!this.interfaceStatusAll?.length) {\n          return\n        }\n        this.interfaceStatusAll.forEach(intf => {\n          // exclude WANs or bridged interfaces\n          if (intf.wan || intf.configType === 'BRIDGED' || !intf.ip4Addr?.length) {\n            return\n          }\n\n          const ip = intf.ip4Addr[0] || null\n          const network = ip?.split('/')[0] || ''\n          const prefix = ip?.split('/')[1] ? parseInt(ip?.split('/')[1]) : 24\n\n          if (network && prefix) {\n            // get the subnet for the address/prefix\n            const subnet = this.$vuntangle.net.info(network, prefix)\n            localNetworks.push({\n              network: subnet.networkAddress,\n              prefix: subnet.cidr,\n            })\n          }\n        })\n        this.ipsec.local.networks = localNetworks\n      },\n\n      /**\n       * Shows an editing dialog for network\n       * @param {Number} index - the index of the network being edited (-1 means new)\n       * @param {String} grid - for which network (local or remote)\n       */\n      onEdit(index, grid) {\n        this.$vuntangle.dialog.show({\n          title: index === -1 ? this.$t(`add_${grid}_network`) : this.$t(`edit_${grid}_network`),\n          component: IpsecNetworkDialog,\n          width: 600,\n          actionLabel: index === -1 ? this.$t('add') : this.$t('update'),\n          componentProps: {\n            type: grid, // type: 'local' or 'remote'\n            ipsec: this.ipsec,\n            index,\n          },\n        })\n      },\n\n      /**\n       * Removes a network from list\n       * @param {Number} index - the index of the network to be removed\n       * @param {String} grid - from which side (local or remote)\n       */\n      onDelete(index, grid) {\n        this.ipsec[grid].networks.splice(index, 1)\n      },\n    },\n  }\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}