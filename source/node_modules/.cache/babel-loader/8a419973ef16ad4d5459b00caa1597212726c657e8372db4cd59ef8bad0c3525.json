{"ast":null,"code":"import \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * IP Subnet calculator utility\n */\n\nimport { Addr } from 'netaddr';\n\n/**\n * Converts quad dotted IP address to a 32-bit binary string representation\n * e.g. \"192.168.1.1\" => \"11000000101010000000000100000001\"\n * @param {string} ip\n * @returns binary string representation of IP address\n */\nvar decimalToBinary = function decimalToBinary(ip) {\n  var decimalOctets = ip.split('.');\n  var binaryOctets = [];\n  decimalOctets.forEach(function (dOctet) {\n    var octet = parseInt(dOctet);\n    // this condition is redundant because the ip is already validated\n    if (octet < 0 || octet > 255 || octet % 1 !== 0) return;\n    binaryOctets.push(('000000000' + octet.toString(2)).slice(-8));\n  });\n  return binaryOctets.join('');\n};\n\n/**\n * Converts a 32-bit binary string representation to a quad dotted decimal IP address\n * e.g. \"11000000101010000000000100000001\" => \"192.168.1.1\"\n * @param {string} b string\n * @returns decimal quad dotted IP address\n */\nvar binaryToDecimal = function binaryToDecimal(b) {\n  return parseInt(b.slice(0, 8), 2) + '.' + parseInt(b.slice(8, 16), 2) + '.' + parseInt(b.slice(16, 24), 2) + '.' + parseInt(b.slice(24, 32), 2);\n};\n\n/**\n * Returns the 32-bit binary string of a subnet mask\n * e.g. cidr = 24 => \"11111111111111111111111100000000\"\n * @param {number} cidr cidr integer 1 to 32\n * @returns binary subnet mask string\n */\nvar cidrToSubnetBinary = function cidrToSubnetBinary(cidr) {\n  var bin = '';\n  var c = parseInt(cidr);\n  for (var i = 0; i <= 31; i++) {\n    bin += i < c ? '1' : '0';\n  }\n  return bin;\n};\n\n/**\n * Computes a logical AND on 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\"\n * \"11111111111111111111111100000000\"\n * ----------------------------------\n * \"11000000101010000000001000000000\"\n * @param {string} b1\n * @param {string} b2\n * @returns {string}\n */\nvar binaryAnd = function binaryAnd(b1, b2) {\n  var bin = '';\n  for (var i = 0; i <= 31; i++) {\n    bin += b1[i] === '0' || b2[i] === '0' ? '0' : '1';\n  }\n  return bin;\n};\n\n/**\n * Computes a logical OR on 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\"\n * \"11111111111111111111111100000000\"\n * ----------------------------------\n * \"11111111111111111111111100000001\"\n * @param {string} b1\n * @param {string} b2\n * @returns {string}\n */\nvar binaryOr = function binaryOr(b1, b2) {\n  var bin = '';\n  for (var i = 0; i <= 31; i++) {\n    bin += b1[i] === '1' || b2[i] === '1' ? '1' : '0';\n  }\n  return bin;\n};\n\n/**\n * Inverts a 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\" to\n * \"00111111010101111111110111111110\"\n * @param {string} b\n * @returns string representing inverse binary input\n */\nvar binaryInverse = function binaryInverse(b) {\n  var bin = '';\n  for (var i = 0; i <= 31; i++) {\n    bin += b[i] === '0' ? '1' : '0';\n  }\n  return bin;\n};\n\n/**\n * Returns the IP class\n * @param {string} ip - the IP address\n * @returns IP class\n */\nvar getClass = function getClass(ip) {\n  if (ip.startsWith('0')) return 'A';\n  if (ip.startsWith('10')) return 'B';\n  if (ip.startsWith('110')) return 'C';\n  if (ip.startsWith('1110')) return 'D';\n  if (ip.startsWith('1111')) return 'E';\n};\n\n/**\n * Computes first available host for a given network address\n * @param {string} ip - the network IP address\n * @returns {string}\n */\nvar getFirstHost = function getFirstHost(ip) {\n  var decimalOctets = ip.split('.');\n  decimalOctets[3] = parseInt(decimalOctets[3]) + 1;\n  return decimalOctets.join('.');\n};\n\n/**\n * Computes last available host for a given network address\n * @param {string} ip - the broadcast IP address\n * @returns {string}\n */\nvar getLastHost = function getLastHost(ip) {\n  var decimalOctets = ip.split('.');\n  decimalOctets[3] = parseInt(decimalOctets[3]) - 1;\n  return decimalOctets.join('.');\n};\n\n/**\n * IP validator\n * @param {string} ip - the IP address\n * @returns {boolean}\n */\nvar isValidIp = function isValidIp(ip) {\n  var ipV4Regex = /^(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$/;\n  return ipV4Regex.test(ip);\n};\n\n/**\n * CIDR validator\n * @param {number} cidr - the CIDR value\n * @returns {boolean}\n */\nvar isValidCidr = function isValidCidr(cidr) {\n  if (isNaN(cidr)) return false;\n  var c = parseInt(cidr);\n  if (c < 0 || c > 32) return false;\n  return true;\n};\n\n/**\n * Returns network info for an IP/cidr combination\n * - ip - the input IP as quad dotted decimal\n * - cidr - the input CIDR value\n * - class - the IP class computed based on first binary digits of the IP\n * - networkAddress - computed as logical binary AND of the IP and subnet mask\n * - subnetMask - computed from CIDR\n * - broadcastAddress - computed as binary OR between networkAddress binary and the inverse binary of the subnet mask\n * - totalAddresses - computed as 2^(32 - cidr)\n * - usableHosts - computed from totalAddresses - 2 (network and broadcast)\n * - firstHost - computed as next address after the network address\n * - lastHost - computed as the address right before the broadcast address\n * Note: for cidr = 31 or 32, the first and last hosts are returned as null\n *\n * @param {string} ip - the IP address\n * @param {number} cidr - CIDR value 1 - 32\n * @returns {object}\n */\nvar info = function info(ip, cidr) {\n  if (!isValidIp(ip) || !isValidCidr(cidr)) return;\n  var binaryIp = decimalToBinary(ip);\n  var binarySubnet = cidrToSubnetBinary(cidr);\n  var subnetIp = binaryToDecimal(binarySubnet);\n  var binaryNetwork = binaryAnd(binaryIp, binarySubnet);\n  var networkAddress = binaryToDecimal(binaryNetwork);\n  var totalAddresses = Math.pow(2, 32 - parseInt(cidr));\n  var broadcastBinary = binaryOr(binaryNetwork, binaryInverse(binarySubnet));\n  var broadcastAddress = binaryToDecimal(broadcastBinary);\n  return {\n    ip: ip,\n    cidr: cidr,\n    \"class\": getClass(binaryIp),\n    networkAddress: networkAddress,\n    subnetMask: subnetIp,\n    broadcastAddress: broadcastAddress,\n    totalAddresses: totalAddresses,\n    usableHosts: totalAddresses - 2,\n    firstHost: cidr < 31 ? getFirstHost(networkAddress) : null,\n    lastHost: cidr < 31 ? getLastHost(broadcastAddress) : null\n  };\n};\n\n/**\n * Returns if a given host falls into network range defined by an address and prefix (cidr)\n * @param {string} ip - the network IP address\n * @param {number} cidr - the network cidr (prefix)\n * @param {string} host - the host IP to be checked if in available hosts\n * @returns {boolean}\n */\nvar isHostInRange = function isHostInRange(ip, cidr, host) {\n  if (!isValidIp(ip) || !isValidCidr(cidr) || !isValidIp(host)) return;\n  var netInfo = info(ip, cidr);\n  if (!netInfo.firstHost || !netInfo.lastHost) return false;\n  if (decimalToBinary(netInfo.firstHost) <= decimalToBinary(host) && decimalToBinary(netInfo.lastHost) >= decimalToBinary(host)) return true;\n  return false;\n};\n\n/**\n * Checks if DHCP hosts range is valid\n * @param {string} rangeStart - dhcp starting range host\n * @param {number} rangeEnd - dhcp ending range host\n * @returns {boolean}\n */\nvar isValidDhcpRange = function isValidDhcpRange(rangeStart, rangeEnd) {\n  if (!isValidIp(rangeStart) || !isValidIp(rangeEnd)) return;\n  return decimalToBinary(rangeStart) < decimalToBinary(rangeEnd);\n};\n\n/**\n * Checks if two subnets are intersecting (overlapping)\n * @param {string} subnet1 - first subnet\n * @param {string} subnet2 - second subnet\n * @returns {boolean} true/false\n */\nvar subnetConflict = function subnetConflict(subnet1, subnet2) {\n  var s1 = Addr(subnet1);\n  var s2 = Addr(subnet2);\n  var conflict = s1.intersect(s2);\n  return !!conflict;\n};\nexport default {\n  info: info,\n  isHostInRange: isHostInRange,\n  isValidDhcpRange: isValidDhcpRange,\n  subnetConflict: subnetConflict\n};","map":{"version":3,"names":["Addr","decimalToBinary","ip","decimalOctets","split","binaryOctets","forEach","dOctet","octet","parseInt","push","toString","slice","join","binaryToDecimal","b","cidrToSubnetBinary","cidr","bin","c","i","binaryAnd","b1","b2","binaryOr","binaryInverse","getClass","startsWith","getFirstHost","getLastHost","isValidIp","ipV4Regex","test","isValidCidr","isNaN","info","binaryIp","binarySubnet","subnetIp","binaryNetwork","networkAddress","totalAddresses","Math","pow","broadcastBinary","broadcastAddress","subnetMask","usableHosts","firstHost","lastHost","isHostInRange","host","netInfo","isValidDhcpRange","rangeStart","rangeEnd","subnetConflict","subnet1","subnet2","s1","s2","conflict","intersect"],"sources":["/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/vuntangle/src/plugins/net.js"],"sourcesContent":["/**\n * IP Subnet calculator utility\n */\n\nimport { Addr } from 'netaddr'\n\n/**\n * Converts quad dotted IP address to a 32-bit binary string representation\n * e.g. \"192.168.1.1\" => \"11000000101010000000000100000001\"\n * @param {string} ip\n * @returns binary string representation of IP address\n */\nconst decimalToBinary = ip => {\n  const decimalOctets = ip.split('.')\n  const binaryOctets = []\n  decimalOctets.forEach(dOctet => {\n    const octet = parseInt(dOctet)\n    // this condition is redundant because the ip is already validated\n    if (octet < 0 || octet > 255 || octet % 1 !== 0) return\n    binaryOctets.push(('000000000' + octet.toString(2)).slice(-8))\n  })\n  return binaryOctets.join('')\n}\n\n/**\n * Converts a 32-bit binary string representation to a quad dotted decimal IP address\n * e.g. \"11000000101010000000000100000001\" => \"192.168.1.1\"\n * @param {string} b string\n * @returns decimal quad dotted IP address\n */\nconst binaryToDecimal = b => {\n  return (\n    parseInt(b.slice(0, 8), 2) +\n    '.' +\n    parseInt(b.slice(8, 16), 2) +\n    '.' +\n    parseInt(b.slice(16, 24), 2) +\n    '.' +\n    parseInt(b.slice(24, 32), 2)\n  )\n}\n\n/**\n * Returns the 32-bit binary string of a subnet mask\n * e.g. cidr = 24 => \"11111111111111111111111100000000\"\n * @param {number} cidr cidr integer 1 to 32\n * @returns binary subnet mask string\n */\nconst cidrToSubnetBinary = cidr => {\n  let bin = ''\n  const c = parseInt(cidr)\n  for (let i = 0; i <= 31; i++) {\n    bin += i < c ? '1' : '0'\n  }\n  return bin\n}\n\n/**\n * Computes a logical AND on 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\"\n * \"11111111111111111111111100000000\"\n * ----------------------------------\n * \"11000000101010000000001000000000\"\n * @param {string} b1\n * @param {string} b2\n * @returns {string}\n */\nconst binaryAnd = (b1, b2) => {\n  let bin = ''\n  for (let i = 0; i <= 31; i++) {\n    bin += b1[i] === '0' || b2[i] === '0' ? '0' : '1'\n  }\n  return bin\n}\n\n/**\n * Computes a logical OR on 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\"\n * \"11111111111111111111111100000000\"\n * ----------------------------------\n * \"11111111111111111111111100000001\"\n * @param {string} b1\n * @param {string} b2\n * @returns {string}\n */\nconst binaryOr = (b1, b2) => {\n  let bin = ''\n  for (let i = 0; i <= 31; i++) {\n    bin += b1[i] === '1' || b2[i] === '1' ? '1' : '0'\n  }\n  return bin\n}\n\n/**\n * Inverts a 32-bit like strings\n * e.g.\n * \"11000000101010000000001000000001\" to\n * \"00111111010101111111110111111110\"\n * @param {string} b\n * @returns string representing inverse binary input\n */\nconst binaryInverse = b => {\n  let bin = ''\n  for (let i = 0; i <= 31; i++) {\n    bin += b[i] === '0' ? '1' : '0'\n  }\n  return bin\n}\n\n/**\n * Returns the IP class\n * @param {string} ip - the IP address\n * @returns IP class\n */\nconst getClass = ip => {\n  if (ip.startsWith('0')) return 'A'\n  if (ip.startsWith('10')) return 'B'\n  if (ip.startsWith('110')) return 'C'\n  if (ip.startsWith('1110')) return 'D'\n  if (ip.startsWith('1111')) return 'E'\n}\n\n/**\n * Computes first available host for a given network address\n * @param {string} ip - the network IP address\n * @returns {string}\n */\nconst getFirstHost = ip => {\n  const decimalOctets = ip.split('.')\n  decimalOctets[3] = parseInt(decimalOctets[3]) + 1\n  return decimalOctets.join('.')\n}\n\n/**\n * Computes last available host for a given network address\n * @param {string} ip - the broadcast IP address\n * @returns {string}\n */\nconst getLastHost = ip => {\n  const decimalOctets = ip.split('.')\n  decimalOctets[3] = parseInt(decimalOctets[3]) - 1\n  return decimalOctets.join('.')\n}\n\n/**\n * IP validator\n * @param {string} ip - the IP address\n * @returns {boolean}\n */\nconst isValidIp = ip => {\n  const ipV4Regex = /^(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$/\n  return ipV4Regex.test(ip)\n}\n\n/**\n * CIDR validator\n * @param {number} cidr - the CIDR value\n * @returns {boolean}\n */\nconst isValidCidr = cidr => {\n  if (isNaN(cidr)) return false\n  const c = parseInt(cidr)\n  if (c < 0 || c > 32) return false\n  return true\n}\n\n/**\n * Returns network info for an IP/cidr combination\n * - ip - the input IP as quad dotted decimal\n * - cidr - the input CIDR value\n * - class - the IP class computed based on first binary digits of the IP\n * - networkAddress - computed as logical binary AND of the IP and subnet mask\n * - subnetMask - computed from CIDR\n * - broadcastAddress - computed as binary OR between networkAddress binary and the inverse binary of the subnet mask\n * - totalAddresses - computed as 2^(32 - cidr)\n * - usableHosts - computed from totalAddresses - 2 (network and broadcast)\n * - firstHost - computed as next address after the network address\n * - lastHost - computed as the address right before the broadcast address\n * Note: for cidr = 31 or 32, the first and last hosts are returned as null\n *\n * @param {string} ip - the IP address\n * @param {number} cidr - CIDR value 1 - 32\n * @returns {object}\n */\nconst info = (ip, cidr) => {\n  if (!isValidIp(ip) || !isValidCidr(cidr)) return\n\n  const binaryIp = decimalToBinary(ip)\n  const binarySubnet = cidrToSubnetBinary(cidr)\n  const subnetIp = binaryToDecimal(binarySubnet)\n  const binaryNetwork = binaryAnd(binaryIp, binarySubnet)\n  const networkAddress = binaryToDecimal(binaryNetwork)\n  const totalAddresses = 2 ** (32 - parseInt(cidr))\n  const broadcastBinary = binaryOr(binaryNetwork, binaryInverse(binarySubnet))\n  const broadcastAddress = binaryToDecimal(broadcastBinary)\n\n  return {\n    ip,\n    cidr,\n    class: getClass(binaryIp),\n    networkAddress,\n    subnetMask: subnetIp,\n    broadcastAddress,\n    totalAddresses,\n    usableHosts: totalAddresses - 2,\n    firstHost: cidr < 31 ? getFirstHost(networkAddress) : null,\n    lastHost: cidr < 31 ? getLastHost(broadcastAddress) : null,\n  }\n}\n\n/**\n * Returns if a given host falls into network range defined by an address and prefix (cidr)\n * @param {string} ip - the network IP address\n * @param {number} cidr - the network cidr (prefix)\n * @param {string} host - the host IP to be checked if in available hosts\n * @returns {boolean}\n */\nconst isHostInRange = (ip, cidr, host) => {\n  if (!isValidIp(ip) || !isValidCidr(cidr) || !isValidIp(host)) return\n  const netInfo = info(ip, cidr)\n  if (!netInfo.firstHost || !netInfo.lastHost) return false\n  if (\n    decimalToBinary(netInfo.firstHost) <= decimalToBinary(host) &&\n    decimalToBinary(netInfo.lastHost) >= decimalToBinary(host)\n  )\n    return true\n  return false\n}\n\n/**\n * Checks if DHCP hosts range is valid\n * @param {string} rangeStart - dhcp starting range host\n * @param {number} rangeEnd - dhcp ending range host\n * @returns {boolean}\n */\nconst isValidDhcpRange = (rangeStart, rangeEnd) => {\n  if (!isValidIp(rangeStart) || !isValidIp(rangeEnd)) return\n  return decimalToBinary(rangeStart) < decimalToBinary(rangeEnd)\n}\n\n/**\n * Checks if two subnets are intersecting (overlapping)\n * @param {string} subnet1 - first subnet\n * @param {string} subnet2 - second subnet\n * @returns {boolean} true/false\n */\nconst subnetConflict = (subnet1, subnet2) => {\n  const s1 = Addr(subnet1)\n  const s2 = Addr(subnet2)\n  const conflict = s1.intersect(s2)\n  return !!conflict\n}\n\nexport default { info, isHostInRange, isValidDhcpRange, subnetConflict }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}