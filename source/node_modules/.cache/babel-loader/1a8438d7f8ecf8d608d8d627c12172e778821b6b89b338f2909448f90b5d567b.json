{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport cloneDeep from 'lodash/cloneDeep';\nimport { extend } from 'vee-validate';\nimport defaults from '../../defaults';\nimport Ipv4PrefixAutocomplete from '../../../../components/Ipv4PrefixAutocomplete';\nexport default {\n  components: {\n    Ipv4PrefixAutocomplete: Ipv4PrefixAutocomplete\n  },\n  inject: ['$intf', '$interfaces'],\n  props: {\n    /**\n     * the key under `interface` settings.json where aliases are going to be set\n     * e.g.\n     * `v4Aliases` for IPv4 settings\n     * `vrrpV4Aliases` for VRRP\n     * */\n    aliasKey: {\n      type: String,\n      \"default\": 'v4Aliases'\n    }\n  },\n  data: function data(_ref) {\n    var _intf$this$aliasKey;\n    var $intf = _ref.$intf;\n    var intf = $intf();\n    return {\n      adding: false,\n      // boolean telling to show the add fields\n      alias: _objectSpread({}, defaults.v4_alias),\n      // model for new v4 alias\n      list: intf !== null && intf !== void 0 && (_intf$this$aliasKey = intf[this.aliasKey]) !== null && _intf$this$aliasKey !== void 0 && _intf$this$aliasKey.length ? cloneDeep(intf[this.aliasKey]) : []\n    };\n  },\n  computed: {\n    intf: function intf(_ref2) {\n      var $intf = _ref2.$intf;\n      return $intf();\n    },\n    interfaces: function interfaces(_ref3) {\n      var $interfaces = _ref3.$interfaces;\n      return $interfaces();\n    }\n  },\n  watch: {\n    adding: function adding(value) {\n      if (!value) {\n        // reset\n        this.alias = _objectSpread({}, defaults.v4_alias);\n      }\n    },\n    list: {\n      deep: true,\n      handler: function handler(newList) {\n        // using $set to maintain reactivity in case aliasKey not existing in interface settings\n        this.$set(this.intf, this.aliasKey, newList);\n      }\n    }\n  },\n  created: function created() {\n    extend('unique_ip_address', this.validateUniqueIpAddress);\n  },\n  methods: {\n    /**\n     * Make sure the IPv4 address of the alias being added does not conflict with any other\n     * interfaces.\n     *\n     * @param {string} value\n     *\n     * @returns {string|boolean}\n     */\n    validateUniqueIpAddress: function validateUniqueIpAddress(value) {\n      // check aliases from other network interfaces\n      var _iterator = _createForOfIteratorHelper(this.interfaces),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _networkInterface$v4A;\n          var networkInterface = _step.value;\n          // ignore current interface, those will be checked from the current editable data\n          if (networkInterface.interfaceId === this.intf.interfaceId) {\n            continue;\n          }\n\n          // check v4 aliases\n          if ((_networkInterface$v4A = networkInterface.v4Aliases) !== null && _networkInterface$v4A !== void 0 && _networkInterface$v4A.length) {\n            var _iterator3 = _createForOfIteratorHelper(networkInterface.v4Aliases),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var v4Alias = _step3.value;\n                if (v4Alias.v4Address === value) {\n                  return this.$t('address_conflicts_with_interface', [networkInterface.name]);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n\n          // check v4 static address\n          if (networkInterface.v4StaticAddress === value) {\n            return this.$t('address_conflicts_with_interface', [networkInterface.name]);\n          }\n        }\n\n        // check v4 addresses that are currently being added/edited on this interface\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.list),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _v4Alias = _step2.value;\n          if (_v4Alias.v4Address === value) {\n            return this.$t('address_conflicts_with_current_interface');\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (this.intf.v4StaticAddress === value) {\n        return this.$t('address_conflicts_with_current_interface');\n      }\n      return true;\n    },\n    onAddAlias: function onAddAlias() {\n      this.list.push(this.alias);\n      this.adding = false;\n    },\n    onRemoveAlias: function onRemoveAlias(index) {\n      this.list.splice(index, 1);\n    }\n  }\n};","map":{"version":3,"names":["cloneDeep","extend","defaults","Ipv4PrefixAutocomplete","components","inject","props","aliasKey","type","String","data","_ref","_intf$this$aliasKey","$intf","intf","adding","alias","_objectSpread","v4_alias","list","length","computed","_ref2","interfaces","_ref3","$interfaces","watch","value","deep","handler","newList","$set","created","validateUniqueIpAddress","methods","_iterator","_createForOfIteratorHelper","_step","s","n","done","_networkInterface$v4A","networkInterface","interfaceId","v4Aliases","_iterator3","_step3","v4Alias","v4Address","$t","name","err","e","f","v4StaticAddress","_iterator2","_step2","onAddAlias","push","onRemoveAlias","index","splice"],"sources":["node_modules/vuntangle/src/shared/SettingsInterface/components/ipv4/Ipv4Aliases.vue"],"sourcesContent":["<template>\n  <div>\n    <p class=\"font-weight-bold mt-6 mb-2\">{{ $t('ipv4_aliases') }}</p>\n    <em v-if=\"!list || !list.length\" class=\"mr-2\">{{ $t('no_aliases') }}</em>\n    <v-chip v-for=\"(item, idx) in list\" :key=\"idx\" class=\"mr-1 mb-1\" small close @click:close=\"onRemoveAlias(idx)\">\n      {{ item.v4Address }}{{ item.v4Prefix || item.v4Prefix === 0 ? `/${item.v4Prefix}` : '' }}\n    </v-chip>\n    <v-chip v-if=\"!adding\" class=\"mb-1\" small color=\"primary\" @click=\"adding = true\">{{ $t('add_alias') }}</v-chip>\n\n    <ValidationObserver v-slot=\"{ passes }\" tag=\"div\">\n      <v-row v-if=\"adding\" no-gutters align=\"center\" class=\"mt-2\">\n        <v-col class=\"grow\">\n          <!-- v4Address -->\n          <ValidationProvider v-slot=\"{ errors }\" rules=\"required|ip|unique_ip_address\">\n            <u-text-field\n              v-model=\"alias.v4Address\"\n              :label=\"$t('address')\"\n              class=\"mr-2\"\n              :error-messages=\"errors\"\n              @keydown.space.prevent\n            >\n              <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n            </u-text-field>\n          </ValidationProvider>\n        </v-col>\n        <v-col class=\"grow\">\n          <!-- v4Prefix -->\n          <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n            <ipv-4-prefix-autocomplete v-model=\"alias.v4Prefix\" :min=\"1\" :errors=\"errors\" />\n          </ValidationProvider>\n        </v-col>\n        <v-col class=\"shrink\">\n          <u-btn icon :small=\"false\" :min-width=\"null\" class=\"primary mx-4\" @click=\"passes(onAddAlias)\">\n            <v-icon color=\"white\">mdi-check</v-icon>\n          </u-btn>\n        </v-col>\n        <v-col class=\"shrink\">\n          <u-btn icon :small=\"false\" :min-width=\"null\" @click=\"adding = false\"><v-icon>mdi-close</v-icon></u-btn>\n        </v-col>\n      </v-row>\n    </ValidationObserver>\n  </div>\n</template>\n<script>\n  import cloneDeep from 'lodash/cloneDeep'\n  import { extend } from 'vee-validate'\n  import defaults from '../../defaults'\n  import Ipv4PrefixAutocomplete from '../../../../components/Ipv4PrefixAutocomplete'\n\n  export default {\n    components: {\n      Ipv4PrefixAutocomplete,\n    },\n    inject: ['$intf', '$interfaces'],\n\n    props: {\n      /**\n       * the key under `interface` settings.json where aliases are going to be set\n       * e.g.\n       * `v4Aliases` for IPv4 settings\n       * `vrrpV4Aliases` for VRRP\n       * */\n      aliasKey: { type: String, default: 'v4Aliases' },\n    },\n\n    data({ $intf }) {\n      const intf = $intf()\n      return {\n        adding: false, // boolean telling to show the add fields\n        alias: { ...defaults.v4_alias }, // model for new v4 alias\n        list: intf?.[this.aliasKey]?.length ? cloneDeep(intf[this.aliasKey]) : [],\n      }\n    },\n    computed: {\n      intf: ({ $intf }) => $intf(),\n      interfaces: ({ $interfaces }) => $interfaces(),\n    },\n    watch: {\n      adding(value) {\n        if (!value) {\n          // reset\n          this.alias = { ...defaults.v4_alias }\n        }\n      },\n      list: {\n        deep: true,\n        handler(newList) {\n          // using $set to maintain reactivity in case aliasKey not existing in interface settings\n          this.$set(this.intf, this.aliasKey, newList)\n        },\n      },\n    },\n    created() {\n      extend('unique_ip_address', this.validateUniqueIpAddress)\n    },\n    methods: {\n      /**\n       * Make sure the IPv4 address of the alias being added does not conflict with any other\n       * interfaces.\n       *\n       * @param {string} value\n       *\n       * @returns {string|boolean}\n       */\n      validateUniqueIpAddress(value) {\n        // check aliases from other network interfaces\n        for (const networkInterface of this.interfaces) {\n          // ignore current interface, those will be checked from the current editable data\n          if (networkInterface.interfaceId === this.intf.interfaceId) {\n            continue\n          }\n\n          // check v4 aliases\n          if (networkInterface.v4Aliases?.length) {\n            for (const v4Alias of networkInterface.v4Aliases) {\n              if (v4Alias.v4Address === value) {\n                return this.$t('address_conflicts_with_interface', [networkInterface.name])\n              }\n            }\n          }\n\n          // check v4 static address\n          if (networkInterface.v4StaticAddress === value) {\n            return this.$t('address_conflicts_with_interface', [networkInterface.name])\n          }\n        }\n\n        // check v4 addresses that are currently being added/edited on this interface\n        for (const v4Alias of this.list) {\n          if (v4Alias.v4Address === value) {\n            return this.$t('address_conflicts_with_current_interface')\n          }\n        }\n        if (this.intf.v4StaticAddress === value) {\n          return this.$t('address_conflicts_with_current_interface')\n        }\n\n        return true\n      },\n      onAddAlias() {\n        this.list.push(this.alias)\n        this.adding = false\n      },\n      onRemoveAlias(index) {\n        this.list.splice(index, 1)\n      },\n    },\n  }\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}