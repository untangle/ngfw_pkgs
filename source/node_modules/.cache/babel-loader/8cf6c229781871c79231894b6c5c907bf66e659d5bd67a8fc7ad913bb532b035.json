{"ast":null,"code":"import _toConsumableArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url.to-json.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { extend, setInteractionMode } from 'vee-validate';\nimport { required, email, alpha, max, min, confirmed, excluded, min_value as minValue, max_value as maxValue, integer, numeric, regex } from 'vee-validate/dist/rules';\nimport i18n from './vue-i18n';\nimport util from './util';\nimport net from './net';\nvar digitsRegex = /^[0-9]*$/;\nvar portValidate = function portValidate(value) {\n  return digitsRegex.test(value) && minValue.validate(value, {\n    min: 1\n  }) && maxValue.validate(value, {\n    max: 65535\n  });\n};\nvar vlanTagValidate = function vlanTagValidate(value) {\n  return digitsRegex.test(value) && minValue.validate(value, {\n    min: 1\n  }) && maxValue.validate(value, {\n    max: 4094\n  });\n};\nvar macAddressRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;\nexport default function () {\n  /**\n   * Setting global validation integration mode\n   *\n   * there are 4 predefined validation integration modes\n   * - aggressive (default)\n   * - lazy\n   * - passive\n   * - eager\n   *\n   * \"eager\" mode seems to be most suitable\n   */\n  setInteractionMode('eager');\n  extend('alpha', _objectSpread(_objectSpread({}, alpha), {}, {\n    message: function message(_, values) {\n      return i18n.t('alpha', values);\n    }\n  }));\n\n  /**\n   * Check the string only contains numbers, letters, dashes, underscores, and periods.\n   */\n  extend('alpha_dash_period', {\n    validate: function validate(value) {\n      return /^[a-zA-Z0-9-_.]+$/.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('alpha_dash_period', values);\n    }\n  });\n\n  /**\n   * Check the string only contains numbers, letters, dashes, asterisks, and periods.\n   */\n  extend('alpha_star_period', {\n    validate: function validate(value) {\n      return /^[a-zA-Z0-9-.*]+$/.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('alpha_star_period', values);\n    }\n  });\n  extend('cidr', {\n    validate: function validate(value) {\n      return util.isIPv4AddressValid(value, true);\n    },\n    message: function message(_, values) {\n      return i18n.t('cidr_validation', values);\n    }\n  });\n  extend('confirmed', _objectSpread(_objectSpread({}, confirmed), {}, {\n    message: function message(_, values) {\n      return i18n.t('confirmed', values);\n    }\n  }));\n  extend('email', {\n    validate: function validate(value) {\n      return util.validateEmail(value) && !value.includes('&');\n    },\n    message: function message(_, values) {\n      return i18n.t('email', values);\n    }\n  });\n\n  /**\n   * This validates a comma separated list of emails.\n   */\n  extend('email_comma_list', {\n    validate: function validate(value) {\n      var emails = value.split(',');\n      var _iterator = _createForOfIteratorHelper(emails),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var emailInput = _step.value;\n          if (!email.validate(emailInput.trim()) || value.includes('&')) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    },\n    message: function message(_, values) {\n      return i18n.t('email_comma_list', values);\n    }\n  });\n  extend('integer', _objectSpread(_objectSpread({}, integer), {}, {\n    message: function message(_, values) {\n      return i18n.t('integer', {\n        value: values\n      });\n    }\n  }));\n  extend('numeric', _objectSpread(_objectSpread({}, numeric), {}, {\n    message: function message(_, values) {\n      return i18n.t('numeric', {\n        value: values\n      });\n    }\n  }));\n  extend('ip', {\n    params: ['multiple'],\n    validate: function validate(value, _ref) {\n      var _ref$multiple = _ref.multiple,\n        multiple = _ref$multiple === void 0 ? false : _ref$multiple;\n      var list = multiple ? value.split(',') : [value];\n      var _iterator2 = _createForOfIteratorHelper(list),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          if (!util.isIPv4AddressValid(item.trim())) {\n            return i18n.t('ip_v4_invalid');\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return true;\n    }\n  });\n  extend('ip_any', {\n    validate: function validate(value) {\n      return util.isIPv4AddressValid(value) || util.isIPv6AddressValid(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('ip_any', values);\n    }\n  });\n\n  /**\n   * Validates Ipv4 or Ipv6 with or without CIDR\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   */\n  extend('ip_any_cidr', {\n    validate: function validate(value) {\n      return util.isIPv4AddressValid(value) || util.isIPv6AddressValid(value) || util.isIPv4AddressValid(value, true) || util.isIPv6AddressValid(value, true);\n    },\n    message: function message(_, values) {\n      return i18n.t('ip_any', values);\n    }\n  });\n\n  /**\n   * Validates list Ipv4 or Ipv6 addresses with or without CIDR\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | List | 1.2.3.4,1.2.3.3/16 | matches any IP in the list |\n   */\n  extend('ip_any_cidr_list', {\n    validate: function validate(value) {\n      var list = value.split(',');\n      var _iterator3 = _createForOfIteratorHelper(list),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          var trimmedItem = item.trim();\n          var isValidIPv4 = util.isIPv4AddressValid(trimmedItem) || util.isIPv4AddressValid(trimmedItem, true);\n          var isValidIPv6 = util.isIPv6AddressValid(trimmedItem) || util.isIPv6AddressValid(trimmedItem, true);\n          if (!(isValidIPv4 || isValidIPv6)) {\n            return i18n.t('ip_any_list', [item]);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return true;\n    }\n  });\n\n  /**\n   * Validates list of IP Addresses that are Ipv4 or Ipv6.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |\n   * | List | 1.2.3.4/24,1.2.3.5,1.2.3.5-1.2.3.8,2404:0068:0000:0000:0000:0000:0000:0000-2404:0068:0000:0000:0000:0000:0000:0001  | matches any IP that matches any IPv4 or IPv6 Expression in the list |\n   */\n  extend('ip_any_expression_cidr_list', function (value) {\n    var list = value.split(',');\n    var _iterator4 = _createForOfIteratorHelper(list),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var item = _step4.value;\n        var range = item.split('-');\n        if (range.length > 2) {\n          return i18n.t('ip_range', [item]);\n        }\n        var _range = _slicedToArray(range, 2),\n          rangeStart = _range[0],\n          rangeEnd = _range[1];\n        var trimmedRangeStart = rangeStart.trim();\n        var trimmedRangeEnd = rangeEnd && rangeEnd.trim();\n\n        // validate single IP\n        if (range.length === 1) {\n          var _isStartValidIPv = util.isIPv4AddressValid(trimmedRangeStart) || util.isIPv4AddressValid(trimmedRangeStart, true);\n          var _isStartValidIPv2 = util.isIPv6AddressValid(trimmedRangeStart) || util.isIPv6AddressValid(trimmedRangeStart, true);\n          if (!(_isStartValidIPv || _isStartValidIPv2)) {\n            return i18n.t('ip_any_list', [rangeStart]);\n          }\n          continue;\n        }\n\n        // validate IP range\n\n        // start of range cannot be a CIDR address\n        if (util.isIPv4AddressValid(trimmedRangeStart, true) || util.isIPv6AddressValid(trimmedRangeStart, true)) {\n          return i18n.t('no_cidr_in_range', [rangeStart]);\n        }\n\n        // validate start ip is correct format\n        var isStartValidIPv4 = util.isIPv4AddressValid(trimmedRangeStart);\n        var isStartValidIPv6 = util.isIPv6AddressValid(trimmedRangeStart);\n        if (!(isStartValidIPv4 || isStartValidIPv6)) {\n          return i18n.t('ip_any_list', [rangeEnd]);\n        }\n\n        // end of range cannot be a CIDR address\n        if (util.isIPv4AddressValid(trimmedRangeEnd, true) || util.isIPv6AddressValid(trimmedRangeEnd, true)) {\n          return i18n.t('no_cidr_in_range', [rangeEnd]);\n        }\n\n        // validate end ip is correct format\n        var isEndValidIPv4 = util.isIPv4AddressValid(trimmedRangeEnd);\n        var isEndValidIPv6 = util.isIPv6AddressValid(trimmedRangeEnd);\n        if (!(isEndValidIPv4 || isEndValidIPv6)) {\n          return i18n.t('ip_any_list', [rangeEnd]);\n        }\n\n        // make sure start and end of range are the same version\n        if (isStartValidIPv4 && !isEndValidIPv4 || !isStartValidIPv4 && isEndValidIPv4) {\n          return i18n.t('ip_range_same_version', [rangeStart, rangeEnd]);\n        }\n\n        // make sure start IP is less than end IP\n        if (isStartValidIPv4 && isEndValidIPv4 && !util.isIPv4RangeValid(trimmedRangeStart, trimmedRangeEnd)) {\n          return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd]);\n        }\n        if (isStartValidIPv6 && isEndValidIPv6 && !util.isIPv6RangeValid(trimmedRangeStart, trimmedRangeEnd)) {\n          return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd]);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return true;\n  });\n\n  /**\n   * Ensure all IPs in a list are unique. Assumes IPs are valid\n   */\n  extend('ip_list_unique', function (value) {\n    var list = value.split(',');\n    var nonUniqueIP = '';\n    var allItemsUnique = list.every(function (ip, index) {\n      var trimmedIP = ip.trim();\n      var isUnique = list.every(function (otherIP, otherIndex) {\n        return otherIndex === index || otherIP.trim() !== trimmedIP;\n      });\n      if (!isUnique) {\n        nonUniqueIP = ip;\n      }\n      return isUnique;\n    });\n    if (!allItemsUnique) {\n      return i18n.t('ip_unique', [nonUniqueIP]);\n    }\n    return true;\n  });\n\n  /**\n   * Validates a field value against a provided list of values, to be unique (not found in the list)\n   * If not unique (found in the list) provided translated message will be shown\n   * Usage:\n   *   <ValidationProvider v-slot=\"{ errors }\" :rules=\"{ unique_insensitive: { list: [], message: $t('xx') } }\">\n   *   </ValidationProvider>\n   */\n  extend('unique_insensitive', {\n    params: ['list', 'message'],\n    validate: function validate(value, _ref2) {\n      var list = _ref2.list,\n        message = _ref2.message;\n      if (!list && !list.length) {\n        return true;\n      }\n      // convert values to lowercase so the check is not case sensitive\n      var listLowerCase = list.map(function (name) {\n        return name.toLowerCase();\n      });\n\n      // return the error message in case not unique\n      if (listLowerCase.includes(value.toLowerCase())) {\n        return message;\n      }\n      return true;\n    }\n  });\n\n  /**\n   * Validates Ipv4 expression.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | List | 1.2.3.4/24,1.2.3.5-1.2.3.8 | matches any IP that matches any IPv4 Expression in the list |\n   */\n  extend('ip_expression', {\n    params: ['multiple'],\n    /**\n     * @param {string} value - the value to validate\n     * @param {boolean} multiple - flag to control if value is comma separated or not\n     * @returns {string|boolean} - validation result\n     */\n    validate: function validate(value, _ref3) {\n      var _ref3$multiple = _ref3.multiple,\n        multiple = _ref3$multiple === void 0 ? true : _ref3$multiple;\n      var list = multiple ? value.split(',') : [value];\n      var _iterator5 = _createForOfIteratorHelper(list),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          // check for an invalid range\n          var range = item.split('-');\n          if (range.length > 2) {\n            return i18n.t('ip_range', [item]);\n          }\n\n          // check if IP was not inputted\n          var _range2 = _slicedToArray(range, 2),\n            rangeStart = _range2[0],\n            rangeEnd = _range2[1];\n          if (!rangeStart.trim()) {\n            return range.length === 2 ? i18n.t('ip_range', [item]) : i18n.t('ip_v4_invalid');\n          }\n\n          // check invalid IPv4 (with or without subnet)\n          if (!util.isIPv4AddressValid(rangeStart.trim()) && !util.isIPv4AddressValid(rangeStart.trim(), true)) {\n            return i18n.t('ip_value', [rangeStart]);\n          }\n\n          // continue if range was not entered\n          if (range.length === 1) {\n            continue;\n          }\n\n          // check if range end was not set\n          if (!rangeEnd.trim()) {\n            return i18n.t('ip_range', [item]);\n          }\n\n          // check invalid IPv4 range end (with or without subnet)\n          if (!util.isIPv4AddressValid(rangeEnd.trim()) && !util.isIPv4AddressValid(rangeEnd.trim(), true)) {\n            return i18n.t('ip_value', [rangeEnd]);\n          }\n\n          // if both range ips exists and are valid, check the range being valid rangeStart < rangeEnd\n          if (!util.isIPv4RangeValid(rangeStart.trim(), rangeEnd.trim())) {\n            return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd]);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return true;\n    }\n  });\n  extend('ip_v6', {\n    params: ['multiple'],\n    validate: function validate(value, _ref4) {\n      var _ref4$multiple = _ref4.multiple,\n        multiple = _ref4$multiple === void 0 ? false : _ref4$multiple;\n      var list = multiple ? value.split(',') : [value];\n      var _iterator6 = _createForOfIteratorHelper(list),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var item = _step6.value;\n          if (!util.isIPv6AddressValid(item.trim())) {\n            return i18n.t('ip_v6');\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return true;\n    }\n  });\n\n  /**\n   * Validates Ipv6 expression.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 2001:db8:85a3:0:0:8a2e:370:7334 | matches a single value |\n   * | Range | 2001:db8::-2001:db9:: | matches any IP in the range |\n   * | CIDR subnet | 2001:db8::/64 | matches any IP in the subnet |\n   * | List | 2001:db8::/64,2001:db8::-2001:db9:: | matches any IP that matches any IPv6 Expression in the list |\n   */\n  extend('ip_v6_expression', function (value) {\n    var list = value.split(',');\n    var _iterator7 = _createForOfIteratorHelper(list),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var item = _step7.value;\n        // check for an invalid range\n        var range = item.split('-');\n        if (range.length > 2) {\n          return i18n.t('ip_v6_range', [item]);\n        }\n\n        // check if IP was not inputted\n        var _range3 = _slicedToArray(range, 2),\n          rangeStart = _range3[0],\n          rangeEnd = _range3[1];\n        if (!rangeStart.trim()) {\n          return range.length === 2 ? i18n.t('ip_v6_range', [item]) : i18n.t('ip_v6');\n        }\n\n        // check invalid IPv6 (with or without subnet)\n        if (!util.isIPv6AddressValid(rangeStart.trim()) && !util.isIPv6AddressValid(rangeStart.trim(), true)) {\n          return i18n.t('ip_v6_value', [rangeStart]);\n        }\n\n        // continue if range was not entered\n        if (range.length === 1) {\n          continue;\n        }\n\n        // check if range end was not set\n        if (!rangeEnd.trim()) {\n          return i18n.t('ip_v6_range', [item]);\n        }\n\n        // check invalid IPv6 range end (with or without subnet)\n        if (!util.isIPv6AddressValid(rangeEnd.trim()) && !util.isIPv6AddressValid(rangeEnd.trim(), true)) {\n          return i18n.t('ip_v6_value', [rangeEnd]);\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    return true;\n  });\n  extend('mac_address', {\n    validate: function validate(value) {\n      return macAddressRegex.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('mac_address_validation', values);\n    }\n  });\n  extend('max', _objectSpread(_objectSpread({}, max), {}, {\n    message: function message(_, values) {\n      return i18n.t('max', values);\n    }\n  }));\n  extend('max_value', _objectSpread(_objectSpread({}, maxValue), {}, {\n    message: function message(_, values) {\n      return i18n.t('max_value', {\n        value: values.max\n      });\n    }\n  }));\n  extend('min', _objectSpread(_objectSpread({}, min), {}, {\n    message: function message(_, values) {\n      return i18n.t('min', values);\n    }\n  }));\n\n  /**\n   * General validation function to check the minimum and maximum of minutes and/or hours.\n   */\n  extend('min_max_hours_minutes', {\n    params: ['min', 'max', 'minutes', 'hours'],\n    /**\n     * Validate minutes and hours input are between a minimum minutes/hours and a maximum hours/minutes.  Used in\n     * the inactivity logout period user account setting.\n     *\n     * @param {string} value    value of current field being changed, not really needed\n     * @param {string} min      min value with 'M' or 'H' postfix for hours or minutes\n     * @param {string} max      max value with 'M' or 'H' postfix for hours or minutes\n     * @param {string} minutes  minutes inputted\n     * @param {string} hours    hours inputted\n     *\n     * @returns {boolean}\n     */\n    validate: function validate(value, _ref5) {\n      var min = _ref5.min,\n        max = _ref5.max,\n        minutes = _ref5.minutes,\n        hours = _ref5.hours;\n      // convert everything to minutes\n      var minMinutes = min.substr(-1).toUpperCase() === 'H' ? parseInt(min.slice(0, -1)) * 60 : parseInt(min);\n      var maxMinutes = max.substr(-1).toUpperCase() === 'H' ? parseInt(max.slice(0, -1)) * 60 : parseInt(max);\n      var inputMinutes = parseInt(hours, 10) * 60 + parseInt(minutes, 10);\n      return inputMinutes >= minMinutes && inputMinutes <= maxMinutes;\n    },\n    message: function message(_, _ref6) {\n      var min = _ref6.min,\n        max = _ref6.max;\n      var minValue = min.slice(0, -1);\n      var maxValue = max.slice(0, -1);\n      return i18n.t('min_max_hours_minutes', {\n        minValue: minValue,\n        minType: min.substr(-1).toUpperCase() === 'H' ? i18n.tc('hours', minValue).toLocaleLowerCase() : i18n.tc('minutes', minValue).toLocaleLowerCase(),\n        maxValue: maxValue,\n        maxType: max.substr(-1).toUpperCase() === 'H' ? i18n.tc('hours', maxValue).toLocaleLowerCase() : i18n.tc('minutes', maxValue).toLocaleLowerCase()\n      });\n    }\n  });\n  extend('min_value', _objectSpread(_objectSpread({}, minValue), {}, {\n    message: function message(_, values) {\n      return i18n.t('min_value', {\n        value: values.min\n      });\n    }\n  }));\n\n  /**\n   * Check the string does not start with a period.  Used for hostname.\n   */\n  extend('not_start_period', {\n    validate: function validate(value) {\n      return value.charAt(0) === '.';\n    },\n    message: function message(_, values) {\n      return i18n.t('not_start_period', values);\n    }\n  });\n  extend('phone', {\n    validate: function validate(value) {\n      // allows empty phone number\n      if (value === null || value === '') {\n        return true;\n      }\n      // Number between 7 and 18 digits and it may contain symbols like: .()+- and spaces\n      var pattern = new RegExp(\"^[0-9-.()+/'.\\\\s]{7,18}$\");\n      // trim whitespace and .()+- before and after the value\n      if (pattern.test(value)) {\n        value = value.replace(/\\D/g, '');\n        return true;\n      }\n    },\n    message: function message(_, values) {\n      return i18n.t('invalid_phone', values);\n    }\n  });\n  extend('port', {\n    validate: portValidate,\n    message: function message(_, values) {\n      return i18n.t('port_validation', values);\n    }\n  });\n\n  /**\n   * Validates that the value is a proper port value, range, or list.\n   */\n  extend('port_expression', function (value) {\n    var list = value.split(',');\n    var _iterator8 = _createForOfIteratorHelper(list),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var item = _step8.value;\n        // check for an invalid range\n        var range = item.split('-');\n        var _range4 = _slicedToArray(range, 2),\n          rangeStart = _range4[0],\n          rangeEnd = _range4[1];\n        if (range.length > 2) {\n          return i18n.t('port_range', [item]);\n        }\n\n        // check if range start or port was not set\n        if (!rangeStart.trim()) {\n          return range.length === 2 ? i18n.t('port_range', [item]) : i18n.t('port_validation');\n        }\n\n        // check invalid starting port\n        if (!portValidate(rangeStart.trim())) {\n          return i18n.t('port_value', [rangeStart]);\n        }\n\n        // continue if range was not entered\n        if (range.length === 1) {\n          continue;\n        }\n\n        // check if range end was not set\n        if (!rangeEnd.trim()) {\n          return i18n.t('port_range', [item]);\n        }\n\n        // check invalid port range end\n        if (!portValidate(rangeEnd.trim())) {\n          return i18n.t('port_value', [rangeEnd]);\n        }\n\n        // check if start range value greater than end range value\n        if (parseInt(rangeStart) > parseInt(rangeEnd)) {\n          return i18n.t('port_range', [item]);\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    return true;\n  });\n  extend('regex', {\n    params: [].concat(_toConsumableArray(regex.params), ['translationKey']),\n    validate: regex.validate,\n    message: function message(_, _ref7) {\n      var translationKey = _ref7.translationKey;\n      return i18n.t(translationKey);\n    }\n  });\n\n  /**\n   * As opposed to the above, this simply checks if the text can be turned into a regular expression without errors.\n   * It returns nothing about the regular expression itself (assuming it is valid)\n   */\n  extend('valid_regex', {\n    validate: function validate(value) {\n      var isValid = true;\n      try {\n        RegExp(value);\n      } catch (e) {\n        isValid = false;\n      }\n      return isValid;\n    },\n    message: i18n.t('valid_regex')\n  });\n  extend('required', _objectSpread(_objectSpread({}, required), {}, {\n    message: function message(_, values) {\n      return i18n.t('required', values);\n    }\n  }));\n\n  /**\n   * This validates an appliance UID\n   */\n  extend('uid', {\n    validate: function validate(value) {\n      // format validation for adding a ngfw appliance via uid\n      var uidMatch = new RegExp(/\\b([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})\\b/g);\n      // format validation for adding a MRW or WAF appliances via uid\n      var guidMatch = new RegExp(/\\b([A-Fa-f0-9]{8})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{12})\\b/g);\n      return uidMatch.test(value) || guidMatch.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('uid', values);\n    }\n  });\n  extend('unique', _objectSpread(_objectSpread({}, excluded), {}, {\n    message: function message(_, values) {\n      return i18n.t('unique', values);\n    }\n  }));\n  extend('url', {\n    validate: function validate(value) {\n      // format validation that accepts URL with user:password in it\n      var urlMatch = new RegExp(/^(https?:\\/\\/)?((([a-zA-Z0-9_\\-.]+):([a-zA-Z0-9_\\-.]+)@)?([a-zA-Z0-9_\\-.]+))(:\\d+)?(\\/[^\\s]*)?$/);\n      return urlMatch.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('url', values);\n    }\n  });\n  extend('domain', {\n    validate: function validate(value) {\n      var re = /^(?!-)(?!.*-\\.)([a-zA-Z0-9-]{1,63}(?<!-)\\.)+[a-zA-Z]{2,}$/;\n      return re.test(value);\n    },\n    message: function message(_, values) {\n      return i18n.t('domain_validation', values);\n    }\n  });\n  extend('serial', {\n    validate: function validate(value) {\n      if (value.length < 11) {\n        // Serial numbers are either 11 (q series) characters or 14 (all others)\n        return false;\n      }\n      // format validation for adding a Q Series via serial number\n      var qSeriesMatch = new RegExp(/^CTW+\\d{8}$/g, 'i');\n      if (qSeriesMatch.test(value)) {\n        return true;\n      }\n      // if not a q series, check for formatting of others\n      var val = value.replace(/-/g, ''); // replace dashes that were used for old serial numbers\n      if (val.length !== 14) {\n        // Serial numbers length is exactly 14 characters\n        return false;\n      }\n      if (!new RegExp('^0[1-9]|1[0-2]$').test(val.substring(0, 2))) {\n        // First 2 characters represent the month. Allowed: 01-12 / for zSeries, first 2 chars are 02\n        return false;\n      }\n      if (!new RegExp('^[0-9]{2}$').test(val.substring(2, 4))) {\n        // Characters 3-4 represent the year. / for zSeries, they are 01\n        return false;\n      }\n      if (!new RegExp('^[1-9A-H]$').test(val.substring(4, 5))) {\n        // Fifth character represents the model. Allowed: 1-9, and A-H\n        return false;\n      }\n      if (val.substring(5, 6) !== 'L' && val.substring(5, 6) !== 'W' && val.substring(5, 6) !== 'P' &&\n      // added for Z4Plus SN\n      val.substring(5, 6) !== 'w' && val.substring(5, 6) !== '0') {\n        // Sixth character is the wireless flag. Allowed: L, W, w, 0 or P\n        return false;\n      }\n      if (!new RegExp('^[a-zA-Z]$').test(val.substring(6, 7))) {\n        // Seventh character represents the revision. Allowed: a-z, A-Z\n        return false;\n      }\n      // Last 7 characters must all be numbers\n      return new RegExp('^\\\\d{7}$').test(val.substring(7));\n    },\n    message: function message(_, values) {\n      return i18n.t('serial', values);\n    }\n  });\n\n  /**\n   * This rule validates if the input is a valid host or ipv4.\n   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked\n   */\n  extend('hostname', {\n    validate: function validate(value) {\n      return util.isHostnameValid(value);\n    },\n    message: function message() {\n      return i18n.t('hostname_ipv4');\n    }\n  });\n  extend('hosts', {\n    validate: function validate(value) {\n      var isValid = value.split(',').reduce(function (accumulator, currentValue) {\n        return accumulator + (util.isHostnameValid(currentValue.trim()) ? 0 : 1);\n      }, 0);\n      return isValid === 0;\n    },\n    message: function message() {\n      return i18n.t('hostname_ipv4');\n    }\n  });\n\n  /**\n   * This rule validates if the input is a valid hostname, ipv4, or ipv6.\n   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked\n   */\n  extend('hostname_ipv6', {\n    validate: function validate(value) {\n      return util.isHostnameValid(value) || util.isIPv6AddressValid(value);\n    },\n    message: function message() {\n      return i18n.t('hostname_ipv6');\n    }\n  });\n\n  /**\n   * Validate a website url domain matches an email address domain.\n   *\n   * @param {string} url\n   * @param {string} email\n   *\n   * @returns {boolean}\n   */\n  extend('website_domain_match_email_domain', {\n    params: ['email'],\n    validate: function validate(url, _ref8) {\n      var email = _ref8.email;\n      // make sure the email field was loaded\n      if (email === undefined) {\n        return true;\n      }\n\n      // try to parse url from URL object\n      var urlObj;\n      try {\n        urlObj = new URL(url);\n      } catch (ex) {\n        urlObj = null;\n      }\n\n      // get domain from URL object\n      var websiteDomain = '';\n      if (urlObj) {\n        // if the hostname is 3 parts, remove the first part (ie. www)\n        var hostnameParts = urlObj.hostname.split('.');\n        websiteDomain = hostnameParts.length === 3 ? \"\".concat(hostnameParts[1], \".\").concat(hostnameParts[2]) : urlObj.hostname;\n      }\n\n      // check website domain against email domain\n      return websiteDomain === email.split('@').pop();\n    },\n    message: i18n.t('website_domain_must_match_email_domain')\n  });\n\n  /**\n   * This rule validates if the host IP falls in available hosts range\n   * defined by an IP and CIDR\n   */\n  extend('host_in_range', {\n    params: ['ip', 'cidr'],\n    /**\n     * @param {string} value - the host IP to be checked\n     * @param {string} ip - the interface v4 static address\n     * @param {number} cidr - the interface v4 static prefix\n     * @returns {boolean}\n     */\n    validate: function validate(value, _ref9) {\n      var ip = _ref9.ip,\n        cidr = _ref9.cidr;\n      return net.isHostInRange(ip, cidr, value);\n    },\n    message: function message() {\n      return i18n.t('host_not_in_range');\n    }\n  });\n\n  /**\n   * This rule validates if DHCP hosts range is valid\n   */\n  extend('dhcp_range', {\n    params: ['rangeStart', 'rangeEnd'],\n    /**\n     * @param {string} value - the host IP value\n     * @param {string} rangeStart - the DHCP range first host\n     * @param {string} rangeEnd - the DHCP range last host\n     * @returns {boolean}\n     */\n    validate: function validate(value, _ref10) {\n      var rangeStart = _ref10.rangeStart,\n        rangeEnd = _ref10.rangeEnd;\n      if (rangeStart) return net.isValidDhcpRange(rangeStart, value);\n      if (rangeEnd) return net.isValidDhcpRange(value, rangeEnd);\n    },\n    message: function message() {\n      return i18n.t('invalid_dhcp_range');\n    }\n  });\n\n  /**\n   * Password validator rule\n   * it builds up a reg expression to which password is tested against\n   * Validator supports:\n   * - min chars for the password/secret\n   * - min 1 digit\n   * - min 1 uppercase letter\n   * - min 1 lowercase letter\n   * - min one special char from: @#$%^&*\n   *\n   * Sample usage\n   * <ValidationProvider :rules=\"{ password: { minChars: 6, digit: true, special: false, uppercase: true, lowercase: true } }\">\n   */\n  extend('password', {\n    params: ['minChars', 'digit', 'special', 'uppercase', 'lowercase'],\n    /**\n     * @param {string} value - the password/secret\n     * @param {number} minChars - the minimum length of the password\n     *\n     * @param {boolean} digit - require at least min 1 digit\n     * @param {boolean} special - require at least 1 special character\n     * @param {boolean} uppercase - require at least 1 Uppercase letter\n     * @param {boolean} lowercase - require at least 1 lowercase letter\n     * @returns {boolean}\n     */\n    validate: function validate(value, _ref11) {\n      var minChars = _ref11.minChars,\n        digit = _ref11.digit,\n        special = _ref11.special,\n        uppercase = _ref11.uppercase,\n        lowercase = _ref11.lowercase;\n      var re = '[a-zA-Z\\\\d!@#$%^&*\\\\s]';\n      var digitRe = '(?=.*\\\\d)';\n      var specialRe = '(?=.*[!@#$%^&*])';\n      var upperRe = '(?=.*[A-Z])';\n      var lowerRe = '(?=.*[a-z])';\n      if (digit) re = digitRe + re;\n      if (special) re = specialRe + re;\n      if (minChars > 0) re = re + \"{\".concat(minChars, \",}\");\n      if (uppercase) re = upperRe + re;\n      if (lowercase) re = lowerRe + re;\n      var reg = new RegExp(\"^\".concat(re, \"$\"));\n      return reg.test(value);\n    },\n    message: function message(_, _ref12) {\n      var minChars = _ref12.minChars,\n        digit = _ref12.digit,\n        special = _ref12.special,\n        uppercase = _ref12.uppercase,\n        lowercase = _ref12.lowercase;\n      var message = i18n.t('password_validation');\n\n      // builds up an unordered message list with requirements\n      message += '<ul>';\n      if (minChars > 0) message += '<li>' + i18n.t('password_min_chars', [minChars]) + '</li>';\n      if (digit) message += '<li>' + i18n.t('password_digit') + '</li>';\n      if (uppercase) message += '<li>' + i18n.t('password_uppercase') + '</li>';\n      if (lowercase) message += '<li>' + i18n.t('password_lowercase') + '</li>';\n      if (special) message += '<li>' + i18n.t('password_special') + '</li>';\n      message += '<li>' + i18n.t('password_special_list', ['!@#$%^&*']) + '</li>';\n      message += '</ul>';\n      return message;\n    }\n  });\n\n  /**\n   * Validates that the value is a proper VLAN Tag value, range, or list.\n   */\n  extend('vlan_tag_expression', {\n    params: ['multiple'],\n    /**\n     * @param {string} value - the value to validate\n     * @param {boolean} multiple - flag to control if value is comma separated or not\n     * @returns {string|boolean} - validation result\n     */\n    validate: function validate(value, _ref13) {\n      var _ref13$multiple = _ref13.multiple,\n        multiple = _ref13$multiple === void 0 ? true : _ref13$multiple;\n      var list = multiple ? value.split(',') : [value];\n      var _iterator9 = _createForOfIteratorHelper(list),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var item = _step9.value;\n          // check for an invalid range\n          var range = item.split('-');\n          var _range5 = _slicedToArray(range, 2),\n            rangeStart = _range5[0],\n            rangeEnd = _range5[1];\n          if (range.length > 2) {\n            return i18n.t('vlan_tag_range', [item]);\n          }\n\n          // check if range start or VLAN tag was not set\n          if (!rangeStart.trim()) {\n            return range.length === 2 ? i18n.t('vlan_tag_range', [item]) : i18n.t('vlan_tag_validation');\n          }\n\n          // check invalid starting vlan tag. Use the port regex as it's the same logic\n          if (!vlanTagValidate(rangeStart.trim())) {\n            return i18n.t('vlan_tag_value', [rangeStart]);\n          }\n\n          // continue if range was not entered\n          if (range.length === 1) {\n            continue;\n          }\n\n          // check if range end was not set\n          if (!rangeEnd.trim()) {\n            return i18n.t('vlan_tag_range', [item]);\n          }\n\n          // check invalid VLAN tag range end\n          if (!vlanTagValidate(rangeEnd.trim())) {\n            return i18n.t('vlan_tag_value', [rangeEnd]);\n          }\n\n          // check if start range value greater than end range value\n          if (parseInt(rangeStart) > parseInt(rangeEnd)) {\n            return i18n.t('vlan_tag_range', [item]);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      return true;\n    }\n  });\n\n  // Validation rule for vlan network duplicate parent interface/vlanid\n  extend('vlan_duplicate', {\n    params: ['interfaceId', 'interfaces', 'boundInterfaceId', 'vlanId'],\n    /**\n     * @param {number} value - the bound interface id or vlan id\n     * @param {number} interfaceId - current edited interface id (null if adding)\n     * @param {array} interfaces - existing interfaces\n     * @param {number|null} boundInterfaceId - the vlan bound interface\n     * @param {number|null} vlanId - the vlan id\n     * @returns {string|boolean}\n     */\n    validate: function validate(value, _ref14) {\n      var interfaceId = _ref14.interfaceId,\n        interfaces = _ref14.interfaces,\n        boundInterfaceId = _ref14.boundInterfaceId,\n        vlanId = _ref14.vlanId;\n      var invalid = false;\n      interfaces.forEach(function (intf) {\n        // skip if editing or is not vlan or already found duplicate\n        if (interfaceId === intf.interfaceId || intf.type !== 'VLAN' || invalid) return;\n        invalid = !vlanId && intf.boundInterfaceId === boundInterfaceId && intf.vlanid === value || !boundInterfaceId && intf.boundInterfaceId === value && intf.vlanid === vlanId;\n      });\n      return invalid ? i18n.t('vlan_duplicate_parent_vlan_id') : true;\n    }\n  });\n\n  // validates against local/remote gateway set both as 'any'\n  extend('conflicting_any_gateways', {\n    /**\n     * @param {string} value\n     * @param {string} local\n     * @param {string} remote\n     * @returns {boolean} validation result\n     */\n    params: ['local', 'remote'],\n    validate: function validate(value, _ref15) {\n      var local = _ref15.local,\n        remote = _ref15.remote;\n      return !(local === '%any' && remote === '%any');\n    },\n    message: i18n.t('api_ipsec_local_remote_any')\n  });\n\n  // validates bound interface address being set\n  extend('disconnected_wan', {\n    /**\n     * @param {string} value\n     * @param {Object} boundWan\n     * @returns {boolean} validation result\n     */\n    params: ['boundWan'],\n    validate: function validate(value, _ref16) {\n      var boundWan = _ref16.boundWan;\n      return !(value === 'wan' && (boundWan === null || boundWan === void 0 ? void 0 : boundWan.address) === '');\n    },\n    message: i18n.t('ipsec_disconnected_wan')\n  });\n\n  // validate gateway IPs\n  extend('validate_gateways', {\n    /**\n     * @param {string} value\n     * @param {string} local\n     * @param {string} remote\n     * @returns {boolean} validation result\n     */\n    params: ['local', 'remote'],\n    validate: function validate(value, _ref17) {\n      var local = _ref17.local,\n        remote = _ref17.remote;\n      return local !== remote;\n    },\n    message: i18n.t('gateway_ip_conflict')\n  });\n  extend('unique_wireguard_ipv4', {\n    /**\n     * @param {string} value\n     * @param {string} allInterfaces\n     * @returns {boolean} validationReult\n     */\n    params: ['allInterfaces', 'currentWireguardIntf'],\n    validate: function validate(value, _ref18) {\n      var allInterfaces = _ref18.allInterfaces,\n        currentWireguardIntf = _ref18.currentWireguardIntf;\n      var _iterator10 = _createForOfIteratorHelper(allInterfaces),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var currentInterface = _step10.value;\n          if (currentInterface.type === 'WIREGUARD' && currentInterface.interfaceId !== currentWireguardIntf.interfaceId) {\n            var _iterator11 = _createForOfIteratorHelper(currentInterface.wireguardAddresses),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var wgAddress = _step11.value;\n                if (wgAddress.address === value) {\n                  return i18n.t('ip_address_occupied', [currentInterface.name]);\n                }\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return true;\n    }\n  });\n  extend('check_non_routeable_address', {\n    validate: function validate(value) {\n      return value !== '0.0.0.0';\n    },\n    message: i18n.t('deny_non_routeable_address')\n  });\n  extend('check_static_route_metric', {\n    validate: function validate(value) {\n      return digitsRegex.test(value) && minValue.validate(value, {\n        min: 0\n      }) && maxValue.validate(value, {\n        max: 4294967295\n      });\n    },\n    message: i18n.t('invalid_static_route_metric')\n  });\n}","map":{"version":3,"names":["extend","setInteractionMode","required","email","alpha","max","min","confirmed","excluded","min_value","minValue","max_value","maxValue","integer","numeric","regex","i18n","util","net","digitsRegex","portValidate","value","test","validate","vlanTagValidate","macAddressRegex","_objectSpread","message","_","values","t","isIPv4AddressValid","validateEmail","includes","emails","split","_iterator","_createForOfIteratorHelper","_step","s","n","done","emailInput","trim","err","e","f","params","_ref","_ref$multiple","multiple","list","_iterator2","_step2","item","isIPv6AddressValid","_iterator3","_step3","trimmedItem","isValidIPv4","isValidIPv6","_iterator4","_step4","range","length","_range","_slicedToArray","rangeStart","rangeEnd","trimmedRangeStart","trimmedRangeEnd","isStartValidIPv4","isStartValidIPv6","isEndValidIPv4","isEndValidIPv6","isIPv4RangeValid","isIPv6RangeValid","nonUniqueIP","allItemsUnique","every","ip","index","trimmedIP","isUnique","otherIP","otherIndex","_ref2","listLowerCase","map","name","toLowerCase","_ref3","_ref3$multiple","_iterator5","_step5","_range2","_ref4","_ref4$multiple","_iterator6","_step6","_iterator7","_step7","_range3","_ref5","minutes","hours","minMinutes","substr","toUpperCase","parseInt","slice","maxMinutes","inputMinutes","_ref6","minType","tc","toLocaleLowerCase","maxType","charAt","pattern","RegExp","replace","_iterator8","_step8","_range4","concat","_toConsumableArray","_ref7","translationKey","isValid","uidMatch","guidMatch","urlMatch","re","qSeriesMatch","val","substring","isHostnameValid","reduce","accumulator","currentValue","url","_ref8","undefined","urlObj","URL","ex","websiteDomain","hostnameParts","hostname","pop","_ref9","cidr","isHostInRange","_ref10","isValidDhcpRange","_ref11","minChars","digit","special","uppercase","lowercase","digitRe","specialRe","upperRe","lowerRe","reg","_ref12","_ref13","_ref13$multiple","_iterator9","_step9","_range5","_ref14","interfaceId","interfaces","boundInterfaceId","vlanId","invalid","forEach","intf","type","vlanid","_ref15","local","remote","_ref16","boundWan","address","_ref17","_ref18","allInterfaces","currentWireguardIntf","_iterator10","_step10","currentInterface","_iterator11","wireguardAddresses","_step11","wgAddress"],"sources":["/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/vuntangle/src/plugins/init-vee-validate.js"],"sourcesContent":["import { extend, setInteractionMode } from 'vee-validate'\nimport {\n  required,\n  email,\n  alpha,\n  max,\n  min,\n  confirmed,\n  excluded,\n  min_value as minValue,\n  max_value as maxValue,\n  integer,\n  numeric,\n  regex,\n} from 'vee-validate/dist/rules'\nimport i18n from './vue-i18n'\nimport util from './util'\nimport net from './net'\n\nconst digitsRegex = /^[0-9]*$/\nconst portValidate = value =>\n  digitsRegex.test(value) && minValue.validate(value, { min: 1 }) && maxValue.validate(value, { max: 65535 })\nconst vlanTagValidate = value =>\n  digitsRegex.test(value) && minValue.validate(value, { min: 1 }) && maxValue.validate(value, { max: 4094 })\nconst macAddressRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/\n\nexport default function () {\n  /**\n   * Setting global validation integration mode\n   *\n   * there are 4 predefined validation integration modes\n   * - aggressive (default)\n   * - lazy\n   * - passive\n   * - eager\n   *\n   * \"eager\" mode seems to be most suitable\n   */\n  setInteractionMode('eager')\n\n  extend('alpha', {\n    ...alpha,\n    message: (_, values) => i18n.t('alpha', values),\n  })\n\n  /**\n   * Check the string only contains numbers, letters, dashes, underscores, and periods.\n   */\n  extend('alpha_dash_period', {\n    validate: value => /^[a-zA-Z0-9-_.]+$/.test(value),\n    message: (_, values) => i18n.t('alpha_dash_period', values),\n  })\n\n  /**\n   * Check the string only contains numbers, letters, dashes, asterisks, and periods.\n   */\n  extend('alpha_star_period', {\n    validate: value => /^[a-zA-Z0-9-.*]+$/.test(value),\n    message: (_, values) => i18n.t('alpha_star_period', values),\n  })\n\n  extend('cidr', {\n    validate: value => util.isIPv4AddressValid(value, true),\n    message: (_, values) => i18n.t('cidr_validation', values),\n  })\n\n  extend('confirmed', {\n    ...confirmed,\n    message: (_, values) => i18n.t('confirmed', values),\n  })\n\n  extend('email', {\n    validate: value => util.validateEmail(value) && !value.includes('&'),\n    message: (_, values) => i18n.t('email', values),\n  })\n\n  /**\n   * This validates a comma separated list of emails.\n   */\n  extend('email_comma_list', {\n    validate(value) {\n      const emails = value.split(',')\n      for (const emailInput of emails) {\n        if (!email.validate(emailInput.trim()) || value.includes('&')) {\n          return false\n        }\n      }\n\n      return true\n    },\n    message: (_, values) => i18n.t('email_comma_list', values),\n  })\n\n  extend('integer', {\n    ...integer,\n    message: (_, values) => i18n.t('integer', { value: values }),\n  })\n\n  extend('numeric', {\n    ...numeric,\n    message: (_, values) => i18n.t('numeric', { value: values }),\n  })\n\n  extend('ip', {\n    params: ['multiple'],\n    validate: (value, { multiple = false }) => {\n      const list = multiple ? value.split(',') : [value]\n      for (const item of list) {\n        if (!util.isIPv4AddressValid(item.trim())) {\n          return i18n.t('ip_v4_invalid')\n        }\n      }\n      return true\n    },\n  })\n\n  extend('ip_any', {\n    validate: value => util.isIPv4AddressValid(value) || util.isIPv6AddressValid(value),\n    message: (_, values) => i18n.t('ip_any', values),\n  })\n\n  /**\n   * Validates Ipv4 or Ipv6 with or without CIDR\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   */\n  extend('ip_any_cidr', {\n    validate: value =>\n      util.isIPv4AddressValid(value) ||\n      util.isIPv6AddressValid(value) ||\n      util.isIPv4AddressValid(value, true) ||\n      util.isIPv6AddressValid(value, true),\n    message: (_, values) => i18n.t('ip_any', values),\n  })\n\n  /**\n   * Validates list Ipv4 or Ipv6 addresses with or without CIDR\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | List | 1.2.3.4,1.2.3.3/16 | matches any IP in the list |\n   */\n  extend('ip_any_cidr_list', {\n    validate: value => {\n      const list = value.split(',')\n      for (const item of list) {\n        const trimmedItem = item.trim()\n        const isValidIPv4 = util.isIPv4AddressValid(trimmedItem) || util.isIPv4AddressValid(trimmedItem, true)\n        const isValidIPv6 = util.isIPv6AddressValid(trimmedItem) || util.isIPv6AddressValid(trimmedItem, true)\n\n        if (!(isValidIPv4 || isValidIPv6)) {\n          return i18n.t('ip_any_list', [item])\n        }\n      }\n      return true\n    },\n  })\n\n  /**\n   * Validates list of IP Addresses that are Ipv4 or Ipv6.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |\n   * | List | 1.2.3.4/24,1.2.3.5,1.2.3.5-1.2.3.8,2404:0068:0000:0000:0000:0000:0000:0000-2404:0068:0000:0000:0000:0000:0000:0001  | matches any IP that matches any IPv4 or IPv6 Expression in the list |\n   */\n  extend('ip_any_expression_cidr_list', value => {\n    const list = value.split(',')\n    for (const item of list) {\n      const range = item.split('-')\n      if (range.length > 2) {\n        return i18n.t('ip_range', [item])\n      }\n      const [rangeStart, rangeEnd] = range\n      const trimmedRangeStart = rangeStart.trim()\n      const trimmedRangeEnd = rangeEnd && rangeEnd.trim()\n\n      // validate single IP\n      if (range.length === 1) {\n        const isStartValidIPv4 =\n          util.isIPv4AddressValid(trimmedRangeStart) || util.isIPv4AddressValid(trimmedRangeStart, true)\n        const isStartValidIPv6 =\n          util.isIPv6AddressValid(trimmedRangeStart) || util.isIPv6AddressValid(trimmedRangeStart, true)\n\n        if (!(isStartValidIPv4 || isStartValidIPv6)) {\n          return i18n.t('ip_any_list', [rangeStart])\n        }\n\n        continue\n      }\n\n      // validate IP range\n\n      // start of range cannot be a CIDR address\n      if (util.isIPv4AddressValid(trimmedRangeStart, true) || util.isIPv6AddressValid(trimmedRangeStart, true)) {\n        return i18n.t('no_cidr_in_range', [rangeStart])\n      }\n\n      // validate start ip is correct format\n      const isStartValidIPv4 = util.isIPv4AddressValid(trimmedRangeStart)\n      const isStartValidIPv6 = util.isIPv6AddressValid(trimmedRangeStart)\n      if (!(isStartValidIPv4 || isStartValidIPv6)) {\n        return i18n.t('ip_any_list', [rangeEnd])\n      }\n\n      // end of range cannot be a CIDR address\n      if (util.isIPv4AddressValid(trimmedRangeEnd, true) || util.isIPv6AddressValid(trimmedRangeEnd, true)) {\n        return i18n.t('no_cidr_in_range', [rangeEnd])\n      }\n\n      // validate end ip is correct format\n      const isEndValidIPv4 = util.isIPv4AddressValid(trimmedRangeEnd)\n      const isEndValidIPv6 = util.isIPv6AddressValid(trimmedRangeEnd)\n      if (!(isEndValidIPv4 || isEndValidIPv6)) {\n        return i18n.t('ip_any_list', [rangeEnd])\n      }\n\n      // make sure start and end of range are the same version\n      if ((isStartValidIPv4 && !isEndValidIPv4) || (!isStartValidIPv4 && isEndValidIPv4)) {\n        return i18n.t('ip_range_same_version', [rangeStart, rangeEnd])\n      }\n\n      // make sure start IP is less than end IP\n      if (isStartValidIPv4 && isEndValidIPv4 && !util.isIPv4RangeValid(trimmedRangeStart, trimmedRangeEnd)) {\n        return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])\n      }\n      if (isStartValidIPv6 && isEndValidIPv6 && !util.isIPv6RangeValid(trimmedRangeStart, trimmedRangeEnd)) {\n        return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])\n      }\n    }\n    return true\n  })\n\n  /**\n   * Ensure all IPs in a list are unique. Assumes IPs are valid\n   */\n  extend('ip_list_unique', value => {\n    const list = value.split(',')\n    let nonUniqueIP = ''\n    const allItemsUnique = list.every((ip, index) => {\n      const trimmedIP = ip.trim()\n      const isUnique = list.every((otherIP, otherIndex) => otherIndex === index || otherIP.trim() !== trimmedIP)\n      if (!isUnique) {\n        nonUniqueIP = ip\n      }\n      return isUnique\n    })\n    if (!allItemsUnique) {\n      return i18n.t('ip_unique', [nonUniqueIP])\n    }\n    return true\n  })\n\n  /**\n   * Validates a field value against a provided list of values, to be unique (not found in the list)\n   * If not unique (found in the list) provided translated message will be shown\n   * Usage:\n   *   <ValidationProvider v-slot=\"{ errors }\" :rules=\"{ unique_insensitive: { list: [], message: $t('xx') } }\">\n   *   </ValidationProvider>\n   */\n  extend('unique_insensitive', {\n    params: ['list', 'message'],\n    validate(value, { list, message }) {\n      if (!list && !list.length) {\n        return true\n      }\n      // convert values to lowercase so the check is not case sensitive\n      const listLowerCase = list.map(name => name.toLowerCase())\n\n      // return the error message in case not unique\n      if (listLowerCase.includes(value.toLowerCase())) {\n        return message\n      }\n      return true\n    },\n  })\n\n  /**\n   * Validates Ipv4 expression.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 1.2.3.4 | matches a single value |\n   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |\n   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |\n   * | List | 1.2.3.4/24,1.2.3.5-1.2.3.8 | matches any IP that matches any IPv4 Expression in the list |\n   */\n  extend('ip_expression', {\n    params: ['multiple'],\n    /**\n     * @param {string} value - the value to validate\n     * @param {boolean} multiple - flag to control if value is comma separated or not\n     * @returns {string|boolean} - validation result\n     */\n    validate(value, { multiple = true }) {\n      const list = multiple ? value.split(',') : [value]\n      for (const item of list) {\n        // check for an invalid range\n        const range = item.split('-')\n        if (range.length > 2) {\n          return i18n.t('ip_range', [item])\n        }\n\n        // check if IP was not inputted\n        const [rangeStart, rangeEnd] = range\n        if (!rangeStart.trim()) {\n          return range.length === 2 ? i18n.t('ip_range', [item]) : i18n.t('ip_v4_invalid')\n        }\n\n        // check invalid IPv4 (with or without subnet)\n        if (!util.isIPv4AddressValid(rangeStart.trim()) && !util.isIPv4AddressValid(rangeStart.trim(), true)) {\n          return i18n.t('ip_value', [rangeStart])\n        }\n\n        // continue if range was not entered\n        if (range.length === 1) {\n          continue\n        }\n\n        // check if range end was not set\n        if (!rangeEnd.trim()) {\n          return i18n.t('ip_range', [item])\n        }\n\n        // check invalid IPv4 range end (with or without subnet)\n        if (!util.isIPv4AddressValid(rangeEnd.trim()) && !util.isIPv4AddressValid(rangeEnd.trim(), true)) {\n          return i18n.t('ip_value', [rangeEnd])\n        }\n\n        // if both range ips exists and are valid, check the range being valid rangeStart < rangeEnd\n        if (!util.isIPv4RangeValid(rangeStart.trim(), rangeEnd.trim())) {\n          return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])\n        }\n      }\n\n      return true\n    },\n  })\n\n  extend('ip_v6', {\n    params: ['multiple'],\n    validate: (value, { multiple = false }) => {\n      const list = multiple ? value.split(',') : [value]\n      for (const item of list) {\n        if (!util.isIPv6AddressValid(item.trim())) {\n          return i18n.t('ip_v6')\n        }\n      }\n      return true\n    },\n  })\n\n  /**\n   * Validates Ipv6 expression.\n   *\n   * | Name | Example | Description |\n   * | Single Value | 2001:db8:85a3:0:0:8a2e:370:7334 | matches a single value |\n   * | Range | 2001:db8::-2001:db9:: | matches any IP in the range |\n   * | CIDR subnet | 2001:db8::/64 | matches any IP in the subnet |\n   * | List | 2001:db8::/64,2001:db8::-2001:db9:: | matches any IP that matches any IPv6 Expression in the list |\n   */\n  extend('ip_v6_expression', value => {\n    const list = value.split(',')\n    for (const item of list) {\n      // check for an invalid range\n      const range = item.split('-')\n      if (range.length > 2) {\n        return i18n.t('ip_v6_range', [item])\n      }\n\n      // check if IP was not inputted\n      const [rangeStart, rangeEnd] = range\n      if (!rangeStart.trim()) {\n        return range.length === 2 ? i18n.t('ip_v6_range', [item]) : i18n.t('ip_v6')\n      }\n\n      // check invalid IPv6 (with or without subnet)\n      if (!util.isIPv6AddressValid(rangeStart.trim()) && !util.isIPv6AddressValid(rangeStart.trim(), true)) {\n        return i18n.t('ip_v6_value', [rangeStart])\n      }\n\n      // continue if range was not entered\n      if (range.length === 1) {\n        continue\n      }\n\n      // check if range end was not set\n      if (!rangeEnd.trim()) {\n        return i18n.t('ip_v6_range', [item])\n      }\n\n      // check invalid IPv6 range end (with or without subnet)\n      if (!util.isIPv6AddressValid(rangeEnd.trim()) && !util.isIPv6AddressValid(rangeEnd.trim(), true)) {\n        return i18n.t('ip_v6_value', [rangeEnd])\n      }\n    }\n\n    return true\n  })\n\n  extend('mac_address', {\n    validate: value => macAddressRegex.test(value),\n    message: (_, values) => i18n.t('mac_address_validation', values),\n  })\n\n  extend('max', {\n    ...max,\n    message: (_, values) => i18n.t('max', values),\n  })\n\n  extend('max_value', {\n    ...maxValue,\n    message: (_, values) => i18n.t('max_value', { value: values.max }),\n  })\n\n  extend('min', {\n    ...min,\n    message: (_, values) => i18n.t('min', values),\n  })\n\n  /**\n   * General validation function to check the minimum and maximum of minutes and/or hours.\n   */\n  extend('min_max_hours_minutes', {\n    params: ['min', 'max', 'minutes', 'hours'],\n\n    /**\n     * Validate minutes and hours input are between a minimum minutes/hours and a maximum hours/minutes.  Used in\n     * the inactivity logout period user account setting.\n     *\n     * @param {string} value    value of current field being changed, not really needed\n     * @param {string} min      min value with 'M' or 'H' postfix for hours or minutes\n     * @param {string} max      max value with 'M' or 'H' postfix for hours or minutes\n     * @param {string} minutes  minutes inputted\n     * @param {string} hours    hours inputted\n     *\n     * @returns {boolean}\n     */\n    validate(value, { min, max, minutes, hours }) {\n      // convert everything to minutes\n      const minMinutes = min.substr(-1).toUpperCase() === 'H' ? parseInt(min.slice(0, -1)) * 60 : parseInt(min)\n      const maxMinutes = max.substr(-1).toUpperCase() === 'H' ? parseInt(max.slice(0, -1)) * 60 : parseInt(max)\n      const inputMinutes = parseInt(hours, 10) * 60 + parseInt(minutes, 10)\n\n      return inputMinutes >= minMinutes && inputMinutes <= maxMinutes\n    },\n    message: (_, { min, max }) => {\n      const minValue = min.slice(0, -1)\n      const maxValue = max.slice(0, -1)\n\n      return i18n.t('min_max_hours_minutes', {\n        minValue,\n        minType:\n          min.substr(-1).toUpperCase() === 'H'\n            ? i18n.tc('hours', minValue).toLocaleLowerCase()\n            : i18n.tc('minutes', minValue).toLocaleLowerCase(),\n        maxValue,\n        maxType:\n          max.substr(-1).toUpperCase() === 'H'\n            ? i18n.tc('hours', maxValue).toLocaleLowerCase()\n            : i18n.tc('minutes', maxValue).toLocaleLowerCase(),\n      })\n    },\n  })\n\n  extend('min_value', {\n    ...minValue,\n    message: (_, values) => i18n.t('min_value', { value: values.min }),\n  })\n\n  /**\n   * Check the string does not start with a period.  Used for hostname.\n   */\n  extend('not_start_period', {\n    validate: value => value.charAt(0) === '.',\n    message: (_, values) => i18n.t('not_start_period', values),\n  })\n\n  extend('phone', {\n    validate(value) {\n      // allows empty phone number\n      if (value === null || value === '') {\n        return true\n      }\n      // Number between 7 and 18 digits and it may contain symbols like: .()+- and spaces\n      const pattern = new RegExp(\"^[0-9-.()+/'.\\\\s]{7,18}$\")\n      // trim whitespace and .()+- before and after the value\n      if (pattern.test(value)) {\n        value = value.replace(/\\D/g, '')\n        return true\n      }\n    },\n    message: (_, values) => i18n.t('invalid_phone', values),\n  })\n\n  extend('port', {\n    validate: portValidate,\n    message: (_, values) => i18n.t('port_validation', values),\n  })\n\n  /**\n   * Validates that the value is a proper port value, range, or list.\n   */\n  extend('port_expression', value => {\n    const list = value.split(',')\n    for (const item of list) {\n      // check for an invalid range\n      const range = item.split('-')\n      const [rangeStart, rangeEnd] = range\n      if (range.length > 2) {\n        return i18n.t('port_range', [item])\n      }\n\n      // check if range start or port was not set\n      if (!rangeStart.trim()) {\n        return range.length === 2 ? i18n.t('port_range', [item]) : i18n.t('port_validation')\n      }\n\n      // check invalid starting port\n      if (!portValidate(rangeStart.trim())) {\n        return i18n.t('port_value', [rangeStart])\n      }\n\n      // continue if range was not entered\n      if (range.length === 1) {\n        continue\n      }\n\n      // check if range end was not set\n      if (!rangeEnd.trim()) {\n        return i18n.t('port_range', [item])\n      }\n\n      // check invalid port range end\n      if (!portValidate(rangeEnd.trim())) {\n        return i18n.t('port_value', [rangeEnd])\n      }\n\n      // check if start range value greater than end range value\n      if (parseInt(rangeStart) > parseInt(rangeEnd)) {\n        return i18n.t('port_range', [item])\n      }\n    }\n\n    return true\n  })\n\n  extend('regex', {\n    params: [...regex.params, 'translationKey'],\n    validate: regex.validate,\n    message: (_, { translationKey }) => i18n.t(translationKey),\n  })\n\n  /**\n   * As opposed to the above, this simply checks if the text can be turned into a regular expression without errors.\n   * It returns nothing about the regular expression itself (assuming it is valid)\n   */\n  extend('valid_regex', {\n    validate(value) {\n      let isValid = true\n      try {\n        RegExp(value)\n      } catch (e) {\n        isValid = false\n      }\n      return isValid\n    },\n    message: i18n.t('valid_regex'),\n  })\n\n  extend('required', {\n    ...required,\n    message: (_, values) => i18n.t('required', values),\n  })\n\n  /**\n   * This validates an appliance UID\n   */\n  extend('uid', {\n    validate(value) {\n      // format validation for adding a ngfw appliance via uid\n      const uidMatch = new RegExp(/\\b([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})\\b/g)\n      // format validation for adding a MRW or WAF appliances via uid\n      const guidMatch = new RegExp(\n        /\\b([A-Fa-f0-9]{8})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{12})\\b/g,\n      )\n      return uidMatch.test(value) || guidMatch.test(value)\n    },\n    message: (_, values) => i18n.t('uid', values),\n  })\n\n  extend('unique', {\n    ...excluded,\n    message: (_, values) => i18n.t('unique', values),\n  })\n\n  extend('url', {\n    validate(value) {\n      // format validation that accepts URL with user:password in it\n      const urlMatch = new RegExp(\n        /^(https?:\\/\\/)?((([a-zA-Z0-9_\\-.]+):([a-zA-Z0-9_\\-.]+)@)?([a-zA-Z0-9_\\-.]+))(:\\d+)?(\\/[^\\s]*)?$/,\n      )\n      return urlMatch.test(value)\n    },\n    message: (_, values) => i18n.t('url', values),\n  })\n\n  extend('domain', {\n    validate(value) {\n      const re = /^(?!-)(?!.*-\\.)([a-zA-Z0-9-]{1,63}(?<!-)\\.)+[a-zA-Z]{2,}$/\n\n      return re.test(value)\n    },\n    message: (_, values) => i18n.t('domain_validation', values),\n  })\n\n  extend('serial', {\n    validate(value) {\n      if (value.length < 11) {\n        // Serial numbers are either 11 (q series) characters or 14 (all others)\n        return false\n      }\n      // format validation for adding a Q Series via serial number\n      const qSeriesMatch = new RegExp(/^CTW+\\d{8}$/g, 'i')\n      if (qSeriesMatch.test(value)) {\n        return true\n      }\n      // if not a q series, check for formatting of others\n      const val = value.replace(/-/g, '') // replace dashes that were used for old serial numbers\n      if (val.length !== 14) {\n        // Serial numbers length is exactly 14 characters\n        return false\n      }\n      if (!new RegExp('^0[1-9]|1[0-2]$').test(val.substring(0, 2))) {\n        // First 2 characters represent the month. Allowed: 01-12 / for zSeries, first 2 chars are 02\n        return false\n      }\n      if (!new RegExp('^[0-9]{2}$').test(val.substring(2, 4))) {\n        // Characters 3-4 represent the year. / for zSeries, they are 01\n        return false\n      }\n      if (!new RegExp('^[1-9A-H]$').test(val.substring(4, 5))) {\n        // Fifth character represents the model. Allowed: 1-9, and A-H\n        return false\n      }\n      if (\n        val.substring(5, 6) !== 'L' &&\n        val.substring(5, 6) !== 'W' &&\n        val.substring(5, 6) !== 'P' && // added for Z4Plus SN\n        val.substring(5, 6) !== 'w' &&\n        val.substring(5, 6) !== '0'\n      ) {\n        // Sixth character is the wireless flag. Allowed: L, W, w, 0 or P\n        return false\n      }\n      if (!new RegExp('^[a-zA-Z]$').test(val.substring(6, 7))) {\n        // Seventh character represents the revision. Allowed: a-z, A-Z\n        return false\n      }\n      // Last 7 characters must all be numbers\n      return new RegExp('^\\\\d{7}$').test(val.substring(7))\n    },\n    message: (_, values) => i18n.t('serial', values),\n  })\n\n  /**\n   * This rule validates if the input is a valid host or ipv4.\n   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked\n   */\n  extend('hostname', {\n    validate(value) {\n      return util.isHostnameValid(value)\n    },\n    message: () => i18n.t('hostname_ipv4'),\n  })\n\n  extend('hosts', {\n    validate(value) {\n      const isValid = value\n        .split(',')\n        .reduce((accumulator, currentValue) => accumulator + (util.isHostnameValid(currentValue.trim()) ? 0 : 1), 0)\n      return isValid === 0\n    },\n    message: () => i18n.t('hostname_ipv4'),\n  })\n\n  /**\n   * This rule validates if the input is a valid hostname, ipv4, or ipv6.\n   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked\n   */\n  extend('hostname_ipv6', {\n    validate(value) {\n      return util.isHostnameValid(value) || util.isIPv6AddressValid(value)\n    },\n    message: () => i18n.t('hostname_ipv6'),\n  })\n\n  /**\n   * Validate a website url domain matches an email address domain.\n   *\n   * @param {string} url\n   * @param {string} email\n   *\n   * @returns {boolean}\n   */\n  extend('website_domain_match_email_domain', {\n    params: ['email'],\n    validate(url, { email }) {\n      // make sure the email field was loaded\n      if (email === undefined) {\n        return true\n      }\n\n      // try to parse url from URL object\n      let urlObj\n      try {\n        urlObj = new URL(url)\n      } catch (ex) {\n        urlObj = null\n      }\n\n      // get domain from URL object\n      let websiteDomain = ''\n      if (urlObj) {\n        // if the hostname is 3 parts, remove the first part (ie. www)\n        const hostnameParts = urlObj.hostname.split('.')\n        websiteDomain = hostnameParts.length === 3 ? `${hostnameParts[1]}.${hostnameParts[2]}` : urlObj.hostname\n      }\n\n      // check website domain against email domain\n      return websiteDomain === email.split('@').pop()\n    },\n    message: i18n.t('website_domain_must_match_email_domain'),\n  })\n\n  /**\n   * This rule validates if the host IP falls in available hosts range\n   * defined by an IP and CIDR\n   */\n  extend('host_in_range', {\n    params: ['ip', 'cidr'],\n    /**\n     * @param {string} value - the host IP to be checked\n     * @param {string} ip - the interface v4 static address\n     * @param {number} cidr - the interface v4 static prefix\n     * @returns {boolean}\n     */\n    validate(value, { ip, cidr }) {\n      return net.isHostInRange(ip, cidr, value)\n    },\n    message: () => i18n.t('host_not_in_range'),\n  })\n\n  /**\n   * This rule validates if DHCP hosts range is valid\n   */\n  extend('dhcp_range', {\n    params: ['rangeStart', 'rangeEnd'],\n    /**\n     * @param {string} value - the host IP value\n     * @param {string} rangeStart - the DHCP range first host\n     * @param {string} rangeEnd - the DHCP range last host\n     * @returns {boolean}\n     */\n    validate(value, { rangeStart, rangeEnd }) {\n      if (rangeStart) return net.isValidDhcpRange(rangeStart, value)\n      if (rangeEnd) return net.isValidDhcpRange(value, rangeEnd)\n    },\n    message: () => i18n.t('invalid_dhcp_range'),\n  })\n\n  /**\n   * Password validator rule\n   * it builds up a reg expression to which password is tested against\n   * Validator supports:\n   * - min chars for the password/secret\n   * - min 1 digit\n   * - min 1 uppercase letter\n   * - min 1 lowercase letter\n   * - min one special char from: @#$%^&*\n   *\n   * Sample usage\n   * <ValidationProvider :rules=\"{ password: { minChars: 6, digit: true, special: false, uppercase: true, lowercase: true } }\">\n   */\n  extend('password', {\n    params: ['minChars', 'digit', 'special', 'uppercase', 'lowercase'],\n    /**\n     * @param {string} value - the password/secret\n     * @param {number} minChars - the minimum length of the password\n     *\n     * @param {boolean} digit - require at least min 1 digit\n     * @param {boolean} special - require at least 1 special character\n     * @param {boolean} uppercase - require at least 1 Uppercase letter\n     * @param {boolean} lowercase - require at least 1 lowercase letter\n     * @returns {boolean}\n     */\n    validate(value, { minChars, digit, special, uppercase, lowercase }) {\n      let re = '[a-zA-Z\\\\d!@#$%^&*\\\\s]'\n      const digitRe = '(?=.*\\\\d)'\n      const specialRe = '(?=.*[!@#$%^&*])'\n      const upperRe = '(?=.*[A-Z])'\n      const lowerRe = '(?=.*[a-z])'\n\n      if (digit) re = digitRe + re\n      if (special) re = specialRe + re\n      if (minChars > 0) re = re + `{${minChars},}`\n      if (uppercase) re = upperRe + re\n      if (lowercase) re = lowerRe + re\n\n      const reg = new RegExp(`^${re}$`)\n      return reg.test(value)\n    },\n    message: (_, { minChars, digit, special, uppercase, lowercase }) => {\n      let message = i18n.t('password_validation')\n\n      // builds up an unordered message list with requirements\n      message += '<ul>'\n      if (minChars > 0) message += '<li>' + i18n.t('password_min_chars', [minChars]) + '</li>'\n      if (digit) message += '<li>' + i18n.t('password_digit') + '</li>'\n      if (uppercase) message += '<li>' + i18n.t('password_uppercase') + '</li>'\n      if (lowercase) message += '<li>' + i18n.t('password_lowercase') + '</li>'\n      if (special) message += '<li>' + i18n.t('password_special') + '</li>'\n      message += '<li>' + i18n.t('password_special_list', ['!@#$%^&*']) + '</li>'\n      message += '</ul>'\n\n      return message\n    },\n  })\n\n  /**\n   * Validates that the value is a proper VLAN Tag value, range, or list.\n   */\n  extend('vlan_tag_expression', {\n    params: ['multiple'],\n    /**\n     * @param {string} value - the value to validate\n     * @param {boolean} multiple - flag to control if value is comma separated or not\n     * @returns {string|boolean} - validation result\n     */\n    validate(value, { multiple = true }) {\n      const list = multiple ? value.split(',') : [value]\n      for (const item of list) {\n        // check for an invalid range\n        const range = item.split('-')\n        const [rangeStart, rangeEnd] = range\n        if (range.length > 2) {\n          return i18n.t('vlan_tag_range', [item])\n        }\n\n        // check if range start or VLAN tag was not set\n        if (!rangeStart.trim()) {\n          return range.length === 2 ? i18n.t('vlan_tag_range', [item]) : i18n.t('vlan_tag_validation')\n        }\n\n        // check invalid starting vlan tag. Use the port regex as it's the same logic\n        if (!vlanTagValidate(rangeStart.trim())) {\n          return i18n.t('vlan_tag_value', [rangeStart])\n        }\n\n        // continue if range was not entered\n        if (range.length === 1) {\n          continue\n        }\n\n        // check if range end was not set\n        if (!rangeEnd.trim()) {\n          return i18n.t('vlan_tag_range', [item])\n        }\n\n        // check invalid VLAN tag range end\n        if (!vlanTagValidate(rangeEnd.trim())) {\n          return i18n.t('vlan_tag_value', [rangeEnd])\n        }\n\n        // check if start range value greater than end range value\n        if (parseInt(rangeStart) > parseInt(rangeEnd)) {\n          return i18n.t('vlan_tag_range', [item])\n        }\n      }\n\n      return true\n    },\n  })\n\n  // Validation rule for vlan network duplicate parent interface/vlanid\n  extend('vlan_duplicate', {\n    params: ['interfaceId', 'interfaces', 'boundInterfaceId', 'vlanId'],\n    /**\n     * @param {number} value - the bound interface id or vlan id\n     * @param {number} interfaceId - current edited interface id (null if adding)\n     * @param {array} interfaces - existing interfaces\n     * @param {number|null} boundInterfaceId - the vlan bound interface\n     * @param {number|null} vlanId - the vlan id\n     * @returns {string|boolean}\n     */\n    validate(value, { interfaceId, interfaces, boundInterfaceId, vlanId }) {\n      let invalid = false\n      interfaces.forEach(intf => {\n        // skip if editing or is not vlan or already found duplicate\n        if (interfaceId === intf.interfaceId || intf.type !== 'VLAN' || invalid) return\n        invalid =\n          (!vlanId && intf.boundInterfaceId === boundInterfaceId && intf.vlanid === value) ||\n          (!boundInterfaceId && intf.boundInterfaceId === value && intf.vlanid === vlanId)\n      })\n      return invalid ? i18n.t('vlan_duplicate_parent_vlan_id') : true\n    },\n  })\n\n  // validates against local/remote gateway set both as 'any'\n  extend('conflicting_any_gateways', {\n    /**\n     * @param {string} value\n     * @param {string} local\n     * @param {string} remote\n     * @returns {boolean} validation result\n     */\n    params: ['local', 'remote'],\n    validate(value, { local, remote }) {\n      return !(local === '%any' && remote === '%any')\n    },\n    message: i18n.t('api_ipsec_local_remote_any'),\n  })\n\n  // validates bound interface address being set\n  extend('disconnected_wan', {\n    /**\n     * @param {string} value\n     * @param {Object} boundWan\n     * @returns {boolean} validation result\n     */\n    params: ['boundWan'],\n    validate(value, { boundWan }) {\n      return !(value === 'wan' && boundWan?.address === '')\n    },\n    message: i18n.t('ipsec_disconnected_wan'),\n  })\n\n  // validate gateway IPs\n  extend('validate_gateways', {\n    /**\n     * @param {string} value\n     * @param {string} local\n     * @param {string} remote\n     * @returns {boolean} validation result\n     */\n    params: ['local', 'remote'],\n    validate(value, { local, remote }) {\n      return local !== remote\n    },\n    message: i18n.t('gateway_ip_conflict'),\n  })\n\n  extend('unique_wireguard_ipv4', {\n    /**\n     * @param {string} value\n     * @param {string} allInterfaces\n     * @returns {boolean} validationReult\n     */\n    params: ['allInterfaces', 'currentWireguardIntf'],\n    validate(value, { allInterfaces, currentWireguardIntf }) {\n      for (const currentInterface of allInterfaces) {\n        if (\n          currentInterface.type === 'WIREGUARD' &&\n          currentInterface.interfaceId !== currentWireguardIntf.interfaceId\n        ) {\n          for (const wgAddress of currentInterface.wireguardAddresses) {\n            if (wgAddress.address === value) {\n              return i18n.t('ip_address_occupied', [currentInterface.name])\n            }\n          }\n        }\n      }\n      return true\n    },\n  })\n\n  extend('check_non_routeable_address', {\n    validate(value) {\n      return value !== '0.0.0.0'\n    },\n    message: i18n.t('deny_non_routeable_address'),\n  })\n\n  extend('check_static_route_metric', {\n    validate(value) {\n      return (\n        digitsRegex.test(value) && minValue.validate(value, { min: 0 }) && maxValue.validate(value, { max: 4294967295 })\n      )\n    },\n    message: i18n.t('invalid_static_route_metric'),\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}