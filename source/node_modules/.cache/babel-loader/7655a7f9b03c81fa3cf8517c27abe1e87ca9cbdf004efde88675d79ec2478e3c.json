{"ast":null,"code":"import _slicedToArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/home/shubham/Desktop/ngfw_pkgs/untangle-vue-ui/source/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport WireguardAllowedIps from './WireguardAllowedIps.vue';\nexport default {\n  components: {\n    WireguardAllowedIps: WireguardAllowedIps\n  },\n  inject: ['$intf', '$status', '$interfaces'],\n  data: function data() {\n    return {\n      disableFields: false,\n      pastedConfig: '',\n      wireguardTypeDisabled: false,\n      typeOptions: [{\n        text: 'Roaming',\n        value: 'ROAMING'\n      }, {\n        text: 'Tunnel',\n        value: 'TUNNEL'\n      }]\n    };\n  },\n  computed: {\n    intf: function intf(_ref) {\n      var $intf = _ref.$intf;\n      return $intf();\n    },\n    interfaces: function interfaces(_ref2) {\n      var $interfaces = _ref2.$interfaces;\n      return $interfaces();\n    },\n    status: function status(_ref3) {\n      var $status = _ref3.$status;\n      return $status();\n    }\n  },\n  mounted: function mounted() {\n    this.setWireguardKeypair();\n    this.configureAvailableWgIP();\n  },\n  methods: {\n    configureAvailableWgIP: function configureAvailableWgIP() {\n      var _this = this;\n      if (!this.intf[\"new\"]) {\n        // Interface edit flow, IP already configured\n        return;\n      }\n\n      // Generate random wireguard address\n      this.$emit('get-wireguard-random-address', function (response) {\n        // If the random address is generated assign it to the wireguard address\n        if (response !== null && response !== void 0 && response.network) {\n          _this.intf.wireguardAddresses[0].address = response.network;\n        }\n      });\n      var allUsedAddresses = []; // list of already used WG Addresses\n      // This is unsaved/new Wireguard Interface\n      if (this.intf.wireguardAddresses[0].address) {\n        // update list for all used WG addresses\n        var _iterator = _createForOfIteratorHelper(this.interfaces),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var currentInterface = _step.value;\n            if (currentInterface.type === 'WIREGUARD') {\n              var _iterator2 = _createForOfIteratorHelper(currentInterface.wireguardAddresses),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var wgAddress = _step2.value;\n                  allUsedAddresses.push(wgAddress.address);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var nextAvailableAddress = this.getNextAvailableAddress(this.intf.wireguardAddresses[0].address, this.intf.wireguardAddresses[0].prefix, allUsedAddresses.sort());\n        this.intf.wireguardAddresses[0].address = nextAvailableAddress;\n      }\n    },\n    getNextAvailableAddress: function getNextAvailableAddress(address, addressSpace, allUsedAddresses) {\n      /*\n        checks the IP/address-space against the allUsedAddresses\n        and returns the first available IP Address the 'allUsedAddresses' that is not used yet\n      */\n      var currentAddress = address.split('.').map(Number);\n      // Calculate the number of available addresses based on the address space\n      var availableAddresses = Math.pow(2, 32 - parseInt(addressSpace, 10));\n\n      // Convert the current address to a decimal number\n      var decimalAddress = (currentAddress[0] << 24) + (currentAddress[1] << 16) + (currentAddress[2] << 8) + currentAddress[3];\n      var nextDecimalAddress = decimalAddress;\n      var newAddress = '';\n      while (nextDecimalAddress < availableAddresses) {\n        // Convert the decimal address back to the dotted-quad format\n        newAddress = (nextDecimalAddress >> 24 & 255) + '.' + (nextDecimalAddress >> 16 & 255) + '.' + (nextDecimalAddress >> 8 & 255) + '.' + (nextDecimalAddress & 255);\n        if (!allUsedAddresses.includes(newAddress)) {\n          return newAddress;\n        }\n        nextDecimalAddress++;\n      }\n      return '';\n    },\n    setWireguardKeypair: function setWireguardKeypair() {\n      var _this$intf,\n        _this2 = this;\n      if (!((_this$intf = this.intf) !== null && _this$intf !== void 0 && _this$intf.wireguardPrivateKey)) {\n        this.$emit('get-wireguard-keypair', function (response) {\n          _this2.intf.wireguardPrivateKey = response === null || response === void 0 ? void 0 : response.privateKey;\n          _this2.intf.wireguardPublicKey = response === null || response === void 0 ? void 0 : response.publicKey;\n        });\n      }\n    },\n    onPaste: function onPaste(event) {\n      var _this3 = this;\n      var text = event.clipboardData.getData('text/plain');\n      this.parseConfiguration(text);\n\n      // clear field after paste, blur is needed to trigger the update\n      // set a timeout so the user can tell it was pasted, otherwise it looks like no paste happened\n      setTimeout(function () {\n        _this3.pastedConfig = '';\n        event.target.blur();\n      }, 200);\n    },\n    onCopy: function onCopy() {\n      var _this4 = this;\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this4$intf$wireguard;\n        var jsonData, boundInterface, address, _response$, response, _response$2, _response, allBridgedToInterfaces, networks;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              jsonData = {\n                hostname: _this4.intf.name,\n                publicKey: _this4.intf.wireguardPublicKey,\n                peerAddress: ((_this4$intf$wireguard = _this4.intf.wireguardAddresses[0]) === null || _this4$intf$wireguard === void 0 ? void 0 : _this4$intf$wireguard.address) || ''\n              }; // if the wireguard is a tunnel, try to get the endpoint address\n              if (!(_this4.intf.wireguardType === 'TUNNEL')) {\n                _context.next = 27;\n                break;\n              }\n              // get the bound interface object\n              boundInterface = _this4.interfaces.find(function (intf) {\n                return _this4.intf.boundInterfaceId === intf.interfaceId;\n              });\n              if (boundInterface) {\n                _context.next = 6;\n                break;\n              }\n              _this4.$vuntangle.toast.add(_this4.$t('could_not_find_bound_interface'), 'error');\n              return _context.abrupt(\"return\");\n            case 6:\n              // try to get the IPv4 endpoint address\n              address = '';\n              if (!(boundInterface.v4ConfigType === 'STATIC')) {\n                _context.next = 11;\n                break;\n              }\n              // for static configuration grab the configured static address\n              address = boundInterface.v4StaticAddress;\n              _context.next = 16;\n              break;\n            case 11:\n              if (!(boundInterface.v4ConfigType === 'DHCP' || boundInterface.v4ConfigType === 'PPPOE')) {\n                _context.next = 16;\n                break;\n              }\n              _context.next = 14;\n              return _this4.getResponse(boundInterface);\n            case 14:\n              response = _context.sent;\n              address = (response === null || response === void 0 || (_response$ = response[0]) === null || _response$ === void 0 || (_response$ = _response$.ip4Addr) === null || _response$ === void 0 || (_response$ = _response$[0]) === null || _response$ === void 0 ? void 0 : _response$.split('/')[0]) || '';\n            case 16:\n              if (!(address === '')) {\n                _context.next = 26;\n                break;\n              }\n              if (!(boundInterface.v6ConfigType === 'STATIC')) {\n                _context.next = 21;\n                break;\n              }\n              // for static configuration grab the configured static address\n              address = boundInterface.v6StaticAddress;\n              _context.next = 26;\n              break;\n            case 21:\n              if (!(boundInterface.v6ConfigType === 'DHCP' || boundInterface.v6ConfigType === 'PPPOE')) {\n                _context.next = 26;\n                break;\n              }\n              _context.next = 24;\n              return _this4.getResponse(boundInterface);\n            case 24:\n              _response = _context.sent;\n              address = (_response === null || _response === void 0 || (_response$2 = _response[0]) === null || _response$2 === void 0 || (_response$2 = _response$2.ip6Addr) === null || _response$2 === void 0 || (_response$2 = _response$2[0]) === null || _response$2 === void 0 ? void 0 : _response$2.split('/')[0]) || '';\n            case 26:\n              // add endpoint address if found\n              if (address !== '') {\n                jsonData.endpointAddress = address;\n                jsonData.endpointPort = _this4.intf.wireguardPort;\n              }\n            case 27:\n              // If interface is bridged then we do not need to add the network\n              allBridgedToInterfaces = [];\n              _this4.interfaces.forEach(function (intf) {\n                if (intf.configType === 'BRIDGED') {\n                  allBridgedToInterfaces.push.apply(allBridgedToInterfaces, _toConsumableArray(intf.bridgedInterfaces));\n                }\n              });\n\n              // get local networks for the JSON\n              networks = [];\n              _this4.interfaces.forEach(function (intf) {\n                if (intf.wan === false && intf.enabled === true && !allBridgedToInterfaces.includes(intf.interfaceId)) {\n                  var netAddr;\n                  if (intf.v4ConfigType === 'STATIC') {\n                    netAddr = _this4.getNetworkWithCIDR(intf.v4StaticAddress, intf.v4StaticPrefix);\n                    networks.push(netAddr + '/' + intf.v4StaticPrefix);\n                  }\n                  if (intf.v6ConfigType === 'STATIC') {\n                    netAddr = _this4.getNetworkWithCIDR(intf.v6StaticAddress, intf.v6StaticPrefix);\n                    networks.push(netAddr + '/' + intf.v6StaticPrefix);\n                  }\n                }\n              });\n              if (networks.length > 0) {\n                jsonData.networks = networks.join(',');\n              }\n              _this4.$vuntangle.util.copyToClipboard(JSON.stringify(jsonData));\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    },\n    /**\n     * Use the async callback to fetch the address from device status\n     *\n     * @param {any} boundInterface\n     */\n    getResponse: function getResponse(boundInterface) {\n      var _this5 = this;\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return new Promise(function (resolve) {\n                _this5.$emit('get-device-status', boundInterface.device, resolve);\n              });\n            case 2:\n              response = _context2.sent;\n              return _context2.abrupt(\"return\", response);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    },\n    /**\n     * Parse the pasted wireguard text.  First check if it is in a JSON format and convert it to a wireguard\n     * config format.  Then loop through each line and parse and set local/remote fields.\n     *\n     * @param {string} pasteData\n     */\n    parseConfiguration: function parseConfiguration(pasteData) {\n      // check if the data is JSON\n      var jsonPasteData;\n      try {\n        jsonPasteData = JSON.parse(pasteData);\n      } catch (e) {\n        jsonPasteData = null;\n      }\n\n      // convert JSON format into a wireguard conf file format\n      if (jsonPasteData) {\n        var remote = ['[Peer]'];\n        var endpoint = [];\n        for (var key in jsonPasteData) {\n          switch (key) {\n            case 'hostname':\n              remote.push('# ' + jsonPasteData[key]);\n              break;\n            case 'publicKey':\n              remote.push('PublicKey=' + jsonPasteData[key]);\n              break;\n            case 'endpointAddress':\n              endpoint[0] = jsonPasteData[key];\n              break;\n            case 'endpointPort':\n              endpoint[1] = jsonPasteData[key];\n              break;\n            case 'networks':\n              remote.push('AllowedIps=' + jsonPasteData[key]);\n              break;\n          }\n        }\n        remote.push('Endpoint=' + endpoint.join(':'));\n        pasteData = remote.join('\\n');\n      }\n\n      // loop through key=value lines of the wireguard conf format\n      var configured = false;\n      var privateKeySet = false;\n      var group = '';\n      var lines = pasteData.split('\\n');\n      var _iterator3 = _createForOfIteratorHelper(lines),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var line = _step3.value;\n          // remove whitespaces (if any)\n          line = line.trim();\n\n          // skip commented out lines\n          if (line.startsWith('#')) {\n            continue;\n          }\n\n          // check if the line is just the section type, if so set it for next lines\n          if (line.toLowerCase() === '[interface]') {\n            group = 'local';\n            continue;\n          }\n          if (line.toLowerCase() === '[peer]') {\n            group = 'remote';\n            continue;\n          }\n\n          // check to split key/value on equals , skip if not found\n          var equalIndex = line.indexOf('=');\n          if (equalIndex === -1) {\n            continue;\n          }\n          var _key = line.slice(0, equalIndex).toLowerCase();\n          var value = line.slice(equalIndex + 1);\n\n          // set local settings\n          if (group === 'local') {\n            var success = this.parseLocalConfLine(_key, value);\n            if (success) {\n              configured = true;\n\n              // if what was configured was a private key, set flag to change the 'type'\n              if (_key === 'privatekey') {\n                privateKeySet = true;\n              }\n            }\n            continue;\n          }\n\n          // set remote settings\n          if (group === 'remote') {\n            var _success = this.parseRemoteConfLine(_key, value);\n            if (_success) {\n              configured = true;\n            }\n          }\n        }\n\n        // if at least one field was configured from the paste, the form fields are no longer editable\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (configured) {\n        // set the wireguard 'type'\n        this.intf.wireguardType = privateKeySet ? 'ROAMING' : 'TUNNEL';\n        this.disableFields = true;\n      } else {\n        this.$vuntangle.toast.add(this.$t('no_valid_wireguard_settings'), 'error');\n      }\n    },\n    /**\n     * Parse a line from the local (interface) section of a wireguard conf file.\n     *\n     * @param {string} key\n     * @param {string} value\n     *\n     * @returns {boolean} true/false if any form fields were configured\n     */\n    parseLocalConfLine: function parseLocalConfLine(key, value) {\n      var _this6 = this;\n      if (key === 'privatekey') {\n        if (value === '') {\n          return false;\n        }\n        this.$emit('get-wireguard-publickey', value, function (response) {\n          _this6.intf.wireguardPrivateKey = response === null || response === void 0 ? void 0 : response.privateKey;\n          _this6.intf.wireguardPublicKey = response === null || response === void 0 ? void 0 : response.publicKey;\n        });\n        return true;\n      }\n      if (key === 'address') {\n        this.$emit('get-wireguard-address-check', value, function (response) {\n          if (response) {\n            _this6.$vuntangle.toast.add(\"Interface IP address - \".concat(response), 'error');\n            return false;\n          }\n        });\n        this.$set(this.intf.wireguardAddresses[0], 'address', value);\n        this.$set(this.intf.wireguardAddresses[0], 'prefix', 24);\n        return true;\n      }\n      if (key === 'listenport') {\n        this.intf.wireguardPort = parseInt(value, 10);\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Parse a line from the remote (peer) section of a wireguard conf file.\n     *\n     * @param {string} key\n     * @param {string} value\n     *\n     * @returns {boolean} true/false if any form fields were configured\n     */\n    parseRemoteConfLine: function parseRemoteConfLine(key, value) {\n      var _this7 = this;\n      if (key === 'publickey') {\n        this.$set(this.intf.wireguardPeers[0], 'publicKey', value);\n        return true;\n      }\n      if (key === 'endpoint') {\n        var _value$split = value.split(':'),\n          _value$split2 = _slicedToArray(_value$split, 2),\n          host = _value$split2[0],\n          port = _value$split2[1];\n        this.$set(this.intf.wireguardPeers[0], 'host', host);\n        this.$set(this.intf.wireguardPeers[0], 'port', parseInt(port, 10));\n        return true;\n      }\n      if (key === 'allowedips') {\n        var allowedIps = [];\n        value.split(',').forEach(function (cidr) {\n          var _cidr$trim$split = cidr.trim().split('/'),\n            _cidr$trim$split2 = _slicedToArray(_cidr$trim$split, 2),\n            address = _cidr$trim$split2[0],\n            prefix = _cidr$trim$split2[1];\n          if (address) {\n            prefix = prefix ? parseInt(prefix, 10) : 32;\n            address = _this7.getNetworkWithCIDR(cidr.split('/')[0], prefix);\n            allowedIps.push({\n              address: address,\n              prefix: prefix\n            });\n          }\n        });\n\n        // add default 0.0.0.0/0 if it does not exist\n        var findIndex = allowedIps.findIndex(function (allowedIp) {\n          return allowedIp.address === '0.0.0.0' && allowedIp.prefix === 0;\n        });\n        if (findIndex === -1) {\n          allowedIps.push({\n            address: '0.0.0.0',\n            prefix: 0\n          });\n        }\n        this.$set(this.intf.wireguardPeers[0], 'allowedIps', allowedIps);\n        return true;\n      }\n      return false;\n    },\n    /**\n     * From the specified IP address and CIDR bit, return the network.\n     * For example, 192.168.1.1/24 returns 192.168.1.0\n     *\n     * @param {*} ip\n     * @param {*} cidr\n     */\n    getNetworkWithCIDR: function getNetworkWithCIDR(ip, cidr) {\n      var mask = this.getNetmask(cidr);\n      return this.getNetworkWithMask(ip, mask);\n    },\n    /**\n     * From the specified IP address and netmask, return the network.\n     * For example, 192.168.1.1/255.255.255.0 returns 192.168.1.0\n     *\n     * @param {*} ip\n     * @param {*} netmask\n     */\n    getNetworkWithMask: function getNetworkWithMask(ip, netmask) {\n      var dots = netmask.split('.');\n      var netmaskInteger = ((+dots[0] * 256 + +dots[1]) * 256 + +dots[2]) * 256 + +dots[3];\n      dots = ip.split('.');\n      var ipInteger = ((+dots[0] * 256 + +dots[1]) * 256 + +dots[2]) * 256 + +dots[3] & netmaskInteger;\n      return (ipInteger >>> 24) + '.' + (ipInteger >> 16 & 255) + '.' + (ipInteger >> 8 & 255) + '.' + (ipInteger & 255);\n    },\n    /**\n     * From a given CIDR bitcount, get the appropriate netmask\n     *\n     * @param {*} bitCount - the CIDR bitcount (ie: 32)\n     */\n    getNetmask: function getNetmask(bitCount) {\n      var mask = [];\n      for (var i = 0; i < 4; i++) {\n        var n = Math.min(bitCount, 8);\n        mask.push(256 - Math.pow(2, 8 - n));\n        bitCount -= n;\n      }\n      return mask.join('.');\n    }\n  }\n};","map":{"version":3,"names":["WireguardAllowedIps","components","inject","data","disableFields","pastedConfig","wireguardTypeDisabled","typeOptions","text","value","computed","intf","_ref","$intf","interfaces","_ref2","$interfaces","status","_ref3","$status","mounted","setWireguardKeypair","configureAvailableWgIP","methods","_this","$emit","response","network","wireguardAddresses","address","allUsedAddresses","_iterator","_createForOfIteratorHelper","_step","s","n","done","currentInterface","type","_iterator2","_step2","wgAddress","push","err","e","f","nextAvailableAddress","getNextAvailableAddress","prefix","sort","addressSpace","currentAddress","split","map","Number","availableAddresses","Math","pow","parseInt","decimalAddress","nextDecimalAddress","newAddress","includes","_this$intf","_this2","wireguardPrivateKey","privateKey","wireguardPublicKey","publicKey","onPaste","event","_this3","clipboardData","getData","parseConfiguration","setTimeout","target","blur","onCopy","_this4","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this4$intf$wireguard","jsonData","boundInterface","_response$","_response$2","_response","allBridgedToInterfaces","networks","wrap","_callee$","_context","prev","next","hostname","name","peerAddress","wireguardType","find","boundInterfaceId","interfaceId","$vuntangle","toast","add","$t","abrupt","v4ConfigType","v4StaticAddress","getResponse","sent","ip4Addr","v6ConfigType","v6StaticAddress","ip6Addr","endpointAddress","endpointPort","wireguardPort","forEach","configType","apply","_toConsumableArray","bridgedInterfaces","wan","enabled","netAddr","getNetworkWithCIDR","v4StaticPrefix","v6StaticPrefix","length","join","util","copyToClipboard","JSON","stringify","stop","_this5","_callee2","_callee2$","_context2","Promise","resolve","device","pasteData","jsonPasteData","parse","remote","endpoint","key","configured","privateKeySet","group","lines","_iterator3","_step3","line","trim","startsWith","toLowerCase","equalIndex","indexOf","slice","success","parseLocalConfLine","parseRemoteConfLine","_this6","concat","$set","_this7","wireguardPeers","_value$split","_value$split2","_slicedToArray","host","port","allowedIps","cidr","_cidr$trim$split","_cidr$trim$split2","findIndex","allowedIp","ip","mask","getNetmask","getNetworkWithMask","netmask","dots","netmaskInteger","ipInteger","bitCount","i","min"],"sources":["node_modules/vuntangle/src/shared/SettingsInterface/components/wireguard/Wireguard.vue"],"sourcesContent":["<template>\n  <div>\n    <p class=\"font-weight-bold mb-2\">{{ $t('configuration') }}</p>\n    <u-text-field v-model=\"pastedConfig\" :label=\"$t('paste_wireguard')\" @paste=\"onPaste\" />\n    <p class=\"caption my-2\">\n      <v-icon style=\"margin-bottom: 2px\" small>mdi-information</v-icon> {{ $t('paste_wireguard_warning') }}\n    </p>\n    <v-divider class=\"my-4\" />\n\n    <p>\n      <!-- LOCAL -->\n      <span class=\"font-weight-bold\"> {{ $t('local') }} </span>\n      <u-btn\n        v-if=\"intf.wireguardType === 'TUNNEL'\"\n        text\n        outlined\n        class=\"mx-2 font-weight-bold\"\n        :min-width=\"null\"\n        @click=\"onCopy\"\n      >\n        <v-icon small class=\"mr-1\">mdi-content-copy</v-icon>\n        {{ $t('copy_to_clipboard') }}\n      </u-btn>\n    </p>\n\n    <v-row>\n      <v-col>\n        <u-text-field :label=\"$t('public_key')\" :disabled=\"true\" :value=\"intf.wireguardPublicKey\" />\n      </v-col>\n    </v-row>\n\n    <v-row>\n      <v-col cols=\"4\">\n        <!-- wireguardType -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n          <u-select\n            v-model=\"intf.wireguardType\"\n            :disabled=\"disableFields\"\n            :items=\"typeOptions\"\n            :label=\"$t('wireguard_type')\"\n          >\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-select>\n        </ValidationProvider>\n      </v-col>\n      <v-col>\n        <!-- wireguardAddresses[0].address -->\n        <ValidationProvider\n          v-slot=\"{ errors }\"\n          :rules=\"{\n            required: true,\n            ip: true,\n            unique_wireguard_ipv4: { allInterfaces: interfaces, currentWireguardIntf: intf },\n          }\"\n        >\n          <u-text-field v-model=\"intf.wireguardAddresses[0].address\" :label=\"$t('address')\" :error-messages=\"errors\">\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-text-field>\n        </ValidationProvider>\n      </v-col>\n      <v-col v-if=\"intf.wireguardType === 'TUNNEL'\" cols=\"3\">\n        <!-- wireguardPort -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"required|port|max:5|max_value:65535\">\n          <u-text-field\n            v-model.number=\"intf.wireguardPort\"\n            :label=\"$t('listen_port')\"\n            :disabled=\"disableFields\"\n            :error-messages=\"errors\"\n            type=\"number\"\n          >\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-text-field>\n        </ValidationProvider>\n      </v-col>\n    </v-row>\n\n    <p class=\"font-weight-bold mt-8\">{{ $t('remote') }}</p>\n    <!-- The first peer options -->\n    <v-row>\n      <v-col>\n        <!-- wireguardPeers[0].publicKey -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"required\">\n          <u-text-field\n            v-model=\"intf.wireguardPeers[0].publicKey\"\n            :disabled=\"disableFields\"\n            :label=\"$t('public_key')\"\n            :error-messages=\"errors\"\n          >\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-text-field>\n        </ValidationProvider>\n      </v-col>\n    </v-row>\n    <v-row>\n      <v-col>\n        <!-- wireguardPeers[0].host -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"required|ip\">\n          <u-text-field\n            v-model=\"intf.wireguardPeers[0].host\"\n            :disabled=\"disableFields\"\n            :label=\"$t('endpoint_address')\"\n            :error-messages=\"errors\"\n          >\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-text-field>\n        </ValidationProvider>\n      </v-col>\n      <v-col cols=\"4\">\n        <!-- wireguardPeers[0].port -->\n        <ValidationProvider v-slot=\"{ errors }\" rules=\"required|port|max:5|max_value:65535\">\n          <u-text-field\n            v-model.number=\"intf.wireguardPeers[0].port\"\n            :label=\"$t('endpoint_listen_port')\"\n            :disabled=\"disableFields\"\n            :error-messages=\"errors\"\n            type=\"number\"\n          >\n            <template v-if=\"errors.length\" #append><u-errors-tooltip :errors=\"errors\" /></template>\n          </u-text-field>\n        </ValidationProvider>\n      </v-col>\n    </v-row>\n\n    <v-row>\n      <v-col>\n        <wireguard-allowed-ips :ips=\"intf.wireguardPeers[0].allowedIps\" v-on=\"$listeners\" />\n      </v-col>\n    </v-row>\n  </div>\n</template>\n<script>\n  import WireguardAllowedIps from './WireguardAllowedIps.vue'\n\n  export default {\n    components: { WireguardAllowedIps },\n    inject: ['$intf', '$status', '$interfaces'],\n    data() {\n      return {\n        disableFields: false,\n        pastedConfig: '',\n        wireguardTypeDisabled: false,\n        typeOptions: [\n          { text: 'Roaming', value: 'ROAMING' },\n          { text: 'Tunnel', value: 'TUNNEL' },\n        ],\n      }\n    },\n    computed: {\n      intf: ({ $intf }) => $intf(),\n      interfaces: ({ $interfaces }) => $interfaces(),\n      status: ({ $status }) => $status(),\n    },\n\n    mounted() {\n      this.setWireguardKeypair()\n      this.configureAvailableWgIP()\n    },\n\n    methods: {\n      configureAvailableWgIP() {\n        if (!this.intf.new) {\n          // Interface edit flow, IP already configured\n          return\n        }\n\n        // Generate random wireguard address\n        this.$emit('get-wireguard-random-address', response => {\n          // If the random address is generated assign it to the wireguard address\n          if (response?.network) {\n            this.intf.wireguardAddresses[0].address = response.network\n          }\n        })\n\n        const allUsedAddresses = [] // list of already used WG Addresses\n        // This is unsaved/new Wireguard Interface\n        if (this.intf.wireguardAddresses[0].address) {\n          // update list for all used WG addresses\n          for (const currentInterface of this.interfaces) {\n            if (currentInterface.type === 'WIREGUARD') {\n              for (const wgAddress of currentInterface.wireguardAddresses) {\n                allUsedAddresses.push(wgAddress.address)\n              }\n            }\n          }\n\n          const nextAvailableAddress = this.getNextAvailableAddress(\n            this.intf.wireguardAddresses[0].address,\n            this.intf.wireguardAddresses[0].prefix,\n            allUsedAddresses.sort(),\n          )\n\n          this.intf.wireguardAddresses[0].address = nextAvailableAddress\n        }\n      },\n      getNextAvailableAddress(address, addressSpace, allUsedAddresses) {\n        /*\n          checks the IP/address-space against the allUsedAddresses\n          and returns the first available IP Address the 'allUsedAddresses' that is not used yet\n        */\n        const currentAddress = address.split('.').map(Number)\n        // Calculate the number of available addresses based on the address space\n        const availableAddresses = Math.pow(2, 32 - parseInt(addressSpace, 10))\n\n        // Convert the current address to a decimal number\n        const decimalAddress =\n          (currentAddress[0] << 24) + (currentAddress[1] << 16) + (currentAddress[2] << 8) + currentAddress[3]\n\n        let nextDecimalAddress = decimalAddress\n        let newAddress = ''\n        while (nextDecimalAddress < availableAddresses) {\n          // Convert the decimal address back to the dotted-quad format\n          newAddress =\n            ((nextDecimalAddress >> 24) & 255) +\n            '.' +\n            ((nextDecimalAddress >> 16) & 255) +\n            '.' +\n            ((nextDecimalAddress >> 8) & 255) +\n            '.' +\n            (nextDecimalAddress & 255)\n\n          if (!allUsedAddresses.includes(newAddress)) {\n            return newAddress\n          }\n          nextDecimalAddress++\n        }\n        return ''\n      },\n      setWireguardKeypair() {\n        if (!this.intf?.wireguardPrivateKey) {\n          this.$emit('get-wireguard-keypair', response => {\n            this.intf.wireguardPrivateKey = response?.privateKey\n            this.intf.wireguardPublicKey = response?.publicKey\n          })\n        }\n      },\n\n      onPaste(event) {\n        const text = event.clipboardData.getData('text/plain')\n\n        this.parseConfiguration(text)\n\n        // clear field after paste, blur is needed to trigger the update\n        // set a timeout so the user can tell it was pasted, otherwise it looks like no paste happened\n        setTimeout(() => {\n          this.pastedConfig = ''\n          event.target.blur()\n        }, 200)\n      },\n\n      async onCopy() {\n        const jsonData = {\n          hostname: this.intf.name,\n          publicKey: this.intf.wireguardPublicKey,\n          peerAddress: this.intf.wireguardAddresses[0]?.address || '',\n        }\n\n        // if the wireguard is a tunnel, try to get the endpoint address\n        if (this.intf.wireguardType === 'TUNNEL') {\n          // get the bound interface object\n          const boundInterface = this.interfaces.find(intf => this.intf.boundInterfaceId === intf.interfaceId)\n          if (!boundInterface) {\n            this.$vuntangle.toast.add(this.$t('could_not_find_bound_interface'), 'error')\n            return\n          }\n\n          // try to get the IPv4 endpoint address\n          let address = ''\n          if (boundInterface.v4ConfigType === 'STATIC') {\n            // for static configuration grab the configured static address\n            address = boundInterface.v4StaticAddress\n          } else if (boundInterface.v4ConfigType === 'DHCP' || boundInterface.v4ConfigType === 'PPPOE') {\n            // for DHCP and PPPoE grab the address from the status of the bound interface\n            const response = await this.getResponse(boundInterface)\n            address = response?.[0]?.ip4Addr?.[0]?.split('/')[0] || ''\n          }\n          // if a IPv4 address was not found, try to find an IPv6 address\n          if (address === '') {\n            if (boundInterface.v6ConfigType === 'STATIC') {\n              // for static configuration grab the configured static address\n              address = boundInterface.v6StaticAddress\n            } else if (boundInterface.v6ConfigType === 'DHCP' || boundInterface.v6ConfigType === 'PPPOE') {\n              // for DHCP and PPPoE grab the address from the status of the bound interface\n              const response = await this.getResponse(boundInterface)\n              address = response?.[0]?.ip6Addr?.[0]?.split('/')[0] || ''\n            }\n          }\n\n          // add endpoint address if found\n          if (address !== '') {\n            jsonData.endpointAddress = address\n            jsonData.endpointPort = this.intf.wireguardPort\n          }\n        }\n        // If interface is bridged then we do not need to add the network\n        const allBridgedToInterfaces = []\n        this.interfaces.forEach(intf => {\n          if (intf.configType === 'BRIDGED') {\n            allBridgedToInterfaces.push(...intf.bridgedInterfaces)\n          }\n        })\n\n        // get local networks for the JSON\n        const networks = []\n        this.interfaces.forEach(intf => {\n          if (intf.wan === false && intf.enabled === true && !allBridgedToInterfaces.includes(intf.interfaceId)) {\n            let netAddr\n            if (intf.v4ConfigType === 'STATIC') {\n              netAddr = this.getNetworkWithCIDR(intf.v4StaticAddress, intf.v4StaticPrefix)\n              networks.push(netAddr + '/' + intf.v4StaticPrefix)\n            }\n            if (intf.v6ConfigType === 'STATIC') {\n              netAddr = this.getNetworkWithCIDR(intf.v6StaticAddress, intf.v6StaticPrefix)\n              networks.push(netAddr + '/' + intf.v6StaticPrefix)\n            }\n          }\n        })\n\n        if (networks.length > 0) {\n          jsonData.networks = networks.join(',')\n        }\n\n        this.$vuntangle.util.copyToClipboard(JSON.stringify(jsonData))\n      },\n\n      /**\n       * Use the async callback to fetch the address from device status\n       *\n       * @param {any} boundInterface\n       */\n      async getResponse(boundInterface) {\n        const response = await new Promise(resolve => {\n          this.$emit('get-device-status', boundInterface.device, resolve)\n        })\n        return response\n      },\n\n      /**\n       * Parse the pasted wireguard text.  First check if it is in a JSON format and convert it to a wireguard\n       * config format.  Then loop through each line and parse and set local/remote fields.\n       *\n       * @param {string} pasteData\n       */\n      parseConfiguration(pasteData) {\n        // check if the data is JSON\n        let jsonPasteData\n        try {\n          jsonPasteData = JSON.parse(pasteData)\n        } catch (e) {\n          jsonPasteData = null\n        }\n\n        // convert JSON format into a wireguard conf file format\n        if (jsonPasteData) {\n          const remote = ['[Peer]']\n          const endpoint = []\n          for (const key in jsonPasteData) {\n            switch (key) {\n              case 'hostname':\n                remote.push('# ' + jsonPasteData[key])\n                break\n              case 'publicKey':\n                remote.push('PublicKey=' + jsonPasteData[key])\n                break\n              case 'endpointAddress':\n                endpoint[0] = jsonPasteData[key]\n                break\n              case 'endpointPort':\n                endpoint[1] = jsonPasteData[key]\n                break\n              case 'networks':\n                remote.push('AllowedIps=' + jsonPasteData[key])\n                break\n            }\n          }\n          remote.push('Endpoint=' + endpoint.join(':'))\n          pasteData = remote.join('\\n')\n        }\n\n        // loop through key=value lines of the wireguard conf format\n        let configured = false\n        let privateKeySet = false\n        let group = ''\n        const lines = pasteData.split('\\n')\n        for (let line of lines) {\n          // remove whitespaces (if any)\n          line = line.trim()\n\n          // skip commented out lines\n          if (line.startsWith('#')) {\n            continue\n          }\n\n          // check if the line is just the section type, if so set it for next lines\n          if (line.toLowerCase() === '[interface]') {\n            group = 'local'\n            continue\n          }\n          if (line.toLowerCase() === '[peer]') {\n            group = 'remote'\n            continue\n          }\n\n          // check to split key/value on equals , skip if not found\n          const equalIndex = line.indexOf('=')\n          if (equalIndex === -1) {\n            continue\n          }\n          const key = line.slice(0, equalIndex).toLowerCase()\n          const value = line.slice(equalIndex + 1)\n\n          // set local settings\n          if (group === 'local') {\n            const success = this.parseLocalConfLine(key, value)\n            if (success) {\n              configured = true\n\n              // if what was configured was a private key, set flag to change the 'type'\n              if (key === 'privatekey') {\n                privateKeySet = true\n              }\n            }\n            continue\n          }\n\n          // set remote settings\n          if (group === 'remote') {\n            const success = this.parseRemoteConfLine(key, value)\n            if (success) {\n              configured = true\n            }\n          }\n        }\n\n        // if at least one field was configured from the paste, the form fields are no longer editable\n        if (configured) {\n          // set the wireguard 'type'\n          this.intf.wireguardType = privateKeySet ? 'ROAMING' : 'TUNNEL'\n\n          this.disableFields = true\n        } else {\n          this.$vuntangle.toast.add(this.$t('no_valid_wireguard_settings'), 'error')\n        }\n      },\n\n      /**\n       * Parse a line from the local (interface) section of a wireguard conf file.\n       *\n       * @param {string} key\n       * @param {string} value\n       *\n       * @returns {boolean} true/false if any form fields were configured\n       */\n      parseLocalConfLine(key, value) {\n        if (key === 'privatekey') {\n          if (value === '') {\n            return false\n          }\n          this.$emit('get-wireguard-publickey', value, response => {\n            this.intf.wireguardPrivateKey = response?.privateKey\n            this.intf.wireguardPublicKey = response?.publicKey\n          })\n          return true\n        }\n\n        if (key === 'address') {\n          this.$emit('get-wireguard-address-check', value, response => {\n            if (response) {\n              this.$vuntangle.toast.add(`Interface IP address - ${response}`, 'error')\n              return false\n            }\n          })\n          this.$set(this.intf.wireguardAddresses[0], 'address', value)\n          this.$set(this.intf.wireguardAddresses[0], 'prefix', 24)\n          return true\n        }\n\n        if (key === 'listenport') {\n          this.intf.wireguardPort = parseInt(value, 10)\n          return true\n        }\n\n        return false\n      },\n\n      /**\n       * Parse a line from the remote (peer) section of a wireguard conf file.\n       *\n       * @param {string} key\n       * @param {string} value\n       *\n       * @returns {boolean} true/false if any form fields were configured\n       */\n      parseRemoteConfLine(key, value) {\n        if (key === 'publickey') {\n          this.$set(this.intf.wireguardPeers[0], 'publicKey', value)\n          return true\n        }\n\n        if (key === 'endpoint') {\n          const [host, port] = value.split(':')\n          this.$set(this.intf.wireguardPeers[0], 'host', host)\n          this.$set(this.intf.wireguardPeers[0], 'port', parseInt(port, 10))\n          return true\n        }\n\n        if (key === 'allowedips') {\n          const allowedIps = []\n          value.split(',').forEach(cidr => {\n            let [address, prefix] = cidr.trim().split('/')\n            if (address) {\n              prefix = prefix ? parseInt(prefix, 10) : 32\n              address = this.getNetworkWithCIDR(cidr.split('/')[0], prefix)\n              allowedIps.push({ address, prefix })\n            }\n          })\n\n          // add default 0.0.0.0/0 if it does not exist\n          const findIndex = allowedIps.findIndex(allowedIp => allowedIp.address === '0.0.0.0' && allowedIp.prefix === 0)\n          if (findIndex === -1) {\n            allowedIps.push({ address: '0.0.0.0', prefix: 0 })\n          }\n\n          this.$set(this.intf.wireguardPeers[0], 'allowedIps', allowedIps)\n          return true\n        }\n\n        return false\n      },\n\n      /**\n       * From the specified IP address and CIDR bit, return the network.\n       * For example, 192.168.1.1/24 returns 192.168.1.0\n       *\n       * @param {*} ip\n       * @param {*} cidr\n       */\n      getNetworkWithCIDR(ip, cidr) {\n        const mask = this.getNetmask(cidr)\n        return this.getNetworkWithMask(ip, mask)\n      },\n\n      /**\n       * From the specified IP address and netmask, return the network.\n       * For example, 192.168.1.1/255.255.255.0 returns 192.168.1.0\n       *\n       * @param {*} ip\n       * @param {*} netmask\n       */\n      getNetworkWithMask(ip, netmask) {\n        let dots = netmask.split('.')\n        const netmaskInteger = ((+dots[0] * 256 + +dots[1]) * 256 + +dots[2]) * 256 + +dots[3]\n        dots = ip.split('.')\n        const ipInteger = (((+dots[0] * 256 + +dots[1]) * 256 + +dots[2]) * 256 + +dots[3]) & netmaskInteger\n        return (\n          (ipInteger >>> 24) +\n          '.' +\n          ((ipInteger >> 16) & 255) +\n          '.' +\n          ((ipInteger >> 8) & 255) +\n          '.' +\n          (ipInteger & 255)\n        )\n      },\n\n      /**\n       * From a given CIDR bitcount, get the appropriate netmask\n       *\n       * @param {*} bitCount - the CIDR bitcount (ie: 32)\n       */\n      getNetmask(bitCount) {\n        const mask = []\n        for (let i = 0; i < 4; i++) {\n          const n = Math.min(bitCount, 8)\n          mask.push(256 - Math.pow(2, 8 - n))\n          bitCount -= n\n        }\n        return mask.join('.')\n      },\n    },\n  }\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}