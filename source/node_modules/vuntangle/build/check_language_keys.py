#!/usr/local/bin/python3

import argparse
import errno
import os

from pathlib import Path

# This class parses arguments and files
class Parser:
    
    # Parses all arguments and files
    def __init__(self):
        self.BASE_LANG = 'en'
        self.DEFAULT_S_PATH = '../../src/'
        self.DEFAULT_T_PATH = '../../src/locales/'
        self.DEFAULT_LANGS = 'en,de,ja'
        args = self._parse_args()
        self.v = args.verbose
        self.src_path = args.src_path
        self.tln_path = args.tln_path
        self.languages = args.langs.split(",")
        # Checks that the relevant files exist before doing anything
        if not os.path.exists(self.src_path):
            raise FileNotFoundError(errno.ENOENT,
                                    os.strerror(errno.ENOENT),
                                    self.src_path)
        if not os.path.exists(self.tln_path):
            raise FileNotFoundError(errno.ENOENT, 
                                    os.strerror(errno.ENOENT), 
                                    self.tln_path)
        for lang in self.languages:
            if not os.path.exists(self.tln_path + lang + ".js"):
                raise FileNotFoundError(errno.ENOENT,
                                        os.strerror(errno.ENOENT),
                                        self.tln_path)
        if len(self.languages) > 0 and self.BASE_LANG not in self.languages:
            self.BASE_LANG = self.languages[1]
        self.lang_files = self._get_lang_files()
        self.lang_dict = {}
        for lang in self.lang_files:
            lang_file = self.lang_files[lang]
            languages = self._parse_lang_file(lang_file)
            self.lang_dict[lang] = languages
        
    # Parses the arguments directly using the argparse library
    def _parse_args(self):
        parser = argparse.ArgumentParser(
            description = 'Performs various build checks on language files.' +
                          'First, checks the source files to ensure all ' +
                          'keys exist in all files. Second, checks all ' +
                          '$t(...) calls to make sure they are only calling' +
                          'existing keys within the language files.')
        parser.add_argument('-v', '--verbose',
                            action='store_true')
        parser.add_argument('-s', '--src-path',
            type     = str,
            help     = 'Path to directory for source files. Default ' + 
                       'is: ' + self.DEFAULT_S_PATH,
            default  = self.DEFAULT_S_PATH,
            required = False)
        parser.add_argument('-t', '--tln-path', 
            type     = str, 
            help     = 'Path to directory for translation files. ' +
                       'Default is: ' + self.DEFAULT_T_PATH, 
            default  = self.DEFAULT_T_PATH, 
            required = False)
        parser.add_argument('-l', '--langs', 
            type     = str, 
            help     = 'Languages which will be checked, in a ' +
                       'comma-delimited form. Defaults are English, ' +
                       'German, and Japanese: ' + self.DEFAULT_LANGS, 
            default  = self.DEFAULT_LANGS, 
            required = False)
        return parser.parse_args()
        
    # Gets the file as an array, makes manipulation easier
    def _get_lang_files(self):
        lang_files = {}
        for lang in self.languages:
            with open(self.tln_path + lang + '.js', 'r') as lang_f:
                lang_files[lang] = lang_f.readlines()
        return lang_files
    
    # parses the language file, grabbing the keys and values. Calls 
    # parse_line separately, so that double-line kv pairs can be grabbed
    def _parse_lang_file(self, lang_file):
        file_len = len(lang_file)
        lang_dict = {}
        for i, line in enumerate(lang_file):
            next_line = ''
            if i < file_len - 1:
                next_line = lang_file[i+1]
            key, value = self._parse_line(line, next_line)
            if key and value:
                if key not in lang_dict:
                    lang_dict[key] = []
                # Put this here to manage duplicates better. 
                # Now all are arrays, and duplicates have a list of len > 1
                lang_dict[key] += [value]
        return lang_dict

    # Does very simple parsing. Only difficult part is grabbing the second 
    # line if the kv pair is split
    def _parse_line(self, line, next_line):
        line = line.strip()
        if not line:
            return None, None
        elif line[0] == '#' or line[0] == '\'' or line[0] == '\"':
            return None, None
        elif ":" not in line:
            return None, None
        else:
            key, value = line.split(':', 1)
            # If this is the case, we have a double-lined kv-pair
            if key and not value:
                # Ensures we have a two-line pair by grabbing the next line 
                # and checking for quote characters
                line2 = next_line.strip()
                single_a = (line2[0] == '\'' and line2[-2] == '\'')
                double_a = (line2[0] == '\"' and line2[-2] == '\"')
                if single_a or double_a:
                    value = line2
            return key, value
        
# Checks the translation files themselves. To find missing keys, starts with 
# keys from the base_lang file (usually en or English). For extra keys, the
# opposite is done.
class TranslationChecker:
    
    # Sets useful parameters
    def __init__(self, base_lang, lang_dict):
        self.base_lang = base_lang
        self.lang_dict = lang_dict
    
    # Gets keys from base_lang, check that they exist in the other langs
    def get_missing_src_keys(self):
        key_dict = {}
        for lang in self.lang_dict:
            key_arr = self._get_keys(self.base_lang, lang)
            if key_arr:
                key_dict[lang] = key_arr
        return key_dict
    
    # Gets keys from each lang, and checks that they exist in base_lang
    def get_extra_src_keys(self):
        key_dict = {}
        for lang in self.lang_dict:
            key_arr = self._get_keys(lang, self.base_lang)
            if key_arr:
                key_dict[lang] = key_arr
        return key_dict
    
    # A helper method for above, gets the keys from each file
    def _get_keys(self, src, dest):
        key_arr = []
        for key in self.lang_dict[src]:
            if key not in self.lang_dict[dest]:
                key_arr += [key]
        return key_arr
    
# Checks the source files for any $t(...) calls. If they're found, the key
# inside is checked to be in the base_lang.
class SourceChecker:
    
    # Sets useful parameters and some constants
    def __init__(self, src_path, base_lang, lang_dict):
        self.src_path   = src_path
        self.base_lang  = base_lang
        self.lang_dict  = lang_dict
        self.C_OPEN  = '<!--'
        self.C_CLOSE = '-->'
        self.T_OPEN  = '$t('
        self.P_OPEN  = '('
        self.P_CLOSE = ')'
    
    # Gets all $t(...) calls where the translation key is not in base_lang
    def get_missing_tln_keys(self):
        missing_keys = {}
        # Only checking .vue files
        source_files = Path(self.src_path).glob('**/*.vue')
        for source_file in source_files:
            source = open(str(source_file), 'r')
            in_comment = False
            lineNumber = 1
            for line in source:
                # Handles comments
                if not in_comment and self.C_OPEN in line:
                    in_comment = True
                if in_comment and self.C_CLOSE in line:
                    line = line.split(self.C_CLOSE)[1]
                    in_comment = False
                # If not in a comment, and '$t(' is called
                if not in_comment and self.T_OPEN in line:
                    for t in self._get_complex_t(line):
                        if t not in self.lang_dict[self.base_lang]:
                            loc_str  = str(source_file.resolve())
                            loc_str += ":" + str(lineNumber)
                            missing_keys[t] = loc_str
                lineNumber += 1
            source.close()
        return missing_keys
    
    # Grabs the inside of a $t(...) call. Since these calls can be nested, 
    # there's a recursive call
    def _get_complex_t(self, line):
        t_arr = []
        if self.T_OPEN in line and self.P_CLOSE in line:
            # First, grab everything after '$t('
            complex_str = line.split(self.T_OPEN, 1)[1]
            # Get simple '$t(' (explained below)
            simple_t = self._get_simple_t(complex_str)
            if simple_t:
                t_arr += [simple_t]
            # If there's another open paren, this is more complicated. Might 
            # include a second '$t(' call
            if self.P_OPEN in complex_str:
                # If a ')' occurs before a '(', it's not another '$t(' call. 
                # Strip it away.
                open_p_loc = complex_str.find(self.P_OPEN)
                close_p_loc = complex_str.find(self.P_CLOSE)
                if close_p_loc < open_p_loc:
                    complex_str = complex_str.split(self.P_CLOSE, 1)[1]
                # Calls this function recursively. Grabs any leftover '$t('s
                t_arr += self._get_complex_t(complex_str)
        return t_arr
    
    # Gets a simple '$t('. That is, just a string after '$t(' (which has 
    # already been stripped by now). If there's more to the string, it'll be 
    # handled by _get_complex_t.
    def _get_simple_t(self, simple_str):
        t_str = ''
        if self.P_CLOSE in simple_str: 
            # Grab stuff before the ')', and after the '$t('
            new_str = simple_str.split(self.P_CLOSE, 1)[0].strip()
            if new_str:
                # Strings can start with ' or "
                if new_str[0] == '\'':
                    t_str = new_str.split('\'')[1]
                elif new_str[0] == '\"':
                    t_str = new_str.split('\"')[1]
        return t_str

# Grabs all missing and extra keys between the language files
def main():
    # Grabs all parsed information, handling file errors before doing anything
    try:
        args = Parser()
    except FileNotFoundError as err:
        print("FileNotFoundError:", err)
        return err
    
    ret_val = []
    
    # First checks source files, for any orphan $t(..) calls
    src_checker = SourceChecker(args.src_path, args.BASE_LANG, args.lang_dict)
    missing_src_keys = src_checker.get_missing_tln_keys()
    if args.v:
        print("Missing Source Keys: " + str(missing_src_keys))
    if missing_src_keys:
        ret_val += missing_src_keys
        
    # Then checks translation files. Missing keys are those in en, but not in 
    # other files
    tln_checker = TranslationChecker(args.BASE_LANG, args.lang_dict)
    missing_tln_keys = tln_checker.get_missing_src_keys()
    if args.v:
        print("Missing Translation Keys: " + str(missing_tln_keys))
    if missing_tln_keys:
        ret_val += missing_tln_keys
        
    # Finally checks translation files again, the other direction. Extra keys
    # are those in a language file, but not in en
    extra_tln_keys   = tln_checker.get_extra_src_keys()
    if args.v:
        print("Extra Translation Keys: "   + str(extra_tln_keys))
    if extra_tln_keys:
        ret_val += extra_tln_keys
    
    return ret_val

if __name__ == '__main__':
    result = main()
    # If anything is returned, exit with an error code
    if result:
        exit(1)
