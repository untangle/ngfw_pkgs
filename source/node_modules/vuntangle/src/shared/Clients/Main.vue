<template>
  <div class="d-flex flex-column fill-height pa-4">
    <h1 class="headline mb-2">{{ $t('clients') }}</h1>
    <div v-if="showGrid" class="d-flex flex-grow-1" outlined>
      <u-grid
        id="devices"
        :no-data-message="$vuntangle.$t('no_data_available')"
        :row-data="devices"
        :column-defs="columnDefs"
        :fetching="fetching"
        selection-type="single"
        :selection.sync="selection"
        :use-condensed-toggle="false"
        @refresh="$emit('refresh')"
      />

      <v-card
        v-if="selectedDevice"
        :color="!$vuetify.theme.isDark ? 'grey lighten-3' : ''"
        class="d-flex flex-column flex-grow-1"
        flat
        outlined
        width="300"
      >
        <v-card-title>
          <span>{{ $t('mac') }}: {{ selectedDevice.macAddress }}</span>
          <v-spacer />
          <u-btn icon :min-width="null" @click="selection = []"><v-icon>mdi-close</v-icon></u-btn>
        </v-card-title>

        <v-list dense color="transparent">
          <v-list-group v-for="(item, index) in selectedDeviceCollectors" :key="index">
            <template #activator>
              <v-list-item class="pl-0">
                <v-list-item-content>
                  <v-list-item-title> {{ $t('ip') }}: {{ item.ip }} </v-list-item-title>
                  <v-list-item-subtitle>
                    <span class="text-uppercase">{{ item.type }}</span> -
                    {{ $vuntangle.dates.formatLocaleDate(item.LastUpdate * 1000) }}
                  </v-list-item-subtitle>
                </v-list-item-content>
              </v-list-item>
            </template>
            <!-- NMAP -->
            <list-item v-if="item.hostname" :name="$t('hostname')" :value="item.hostname" />
            <list-item v-if="item.os" :name="$t('os')" :value="item.os" />
            <list-item v-if="item.macVendor" :name="$t('mac_vendor')" :value="item.macVendor" />
            <list-item v-if="item.uptime" :name="$t('up_time')" :value="renderUptime(item.uptime)" />
            <list-item v-if="item.lastBoot" :name="$t('last_boot')" :value="item.lastBoot" />
            <list-item v-if="item.openPorts" :name="$t('open_ports')" :value="renderOpenPorts(item.openPorts)" />
            <!-- LLDP -->
            <list-item v-if="item.sysName" :name="$t('sys_name')" :value="item.sysName" />
            <list-item v-if="item.sysDesc" :name="$t('sys_desc')" :value="item.sysDesc" />
            <list-item v-if="item.deviceType" :name="$t('device_type')" :value="item.deviceType" />
            <list-item v-if="item.inventoryHWRev" :name="$t('inventory_hw_rev')" :value="item.inventoryHWRev" />
            <list-item v-if="item.inventorySoftRev" :name="$t('inventory_soft_rev')" :value="item.inventorySoftRev" />
            <list-item v-if="item.inventorySerial" :name="$t('inventory_serial')" :value="item.inventorySerial" />
            <list-item
              v-if="item.inventoryAssetTag"
              :name="$t('inventory_asset_tag')"
              :value="item.inventoryAssetTag"
            />
            <list-item v-if="item.inventoryModel" :name="$t('inventory_model')" :value="item.inventoryModel" />
            <list-item v-if="item.inventoryVendor" :name="$t('inventory_vendor')" :value="item.inventoryVendor" />
            <list-item
              v-if="item.chassisCapabilities && Array.isArray(item.chassisCapabilities)"
              :name="$t('chassis_capabilities')"
              :value="item.chassisCapabilities.map(cap => cap.capability).join(', ')"
            />
            <!-- NEIGH -->
            <list-item v-if="item.state" :name="$t('state')" :value="item.state" />
            <list-item v-if="item.interface" :name="$t('interface')" :value="item.interface" />
            <list-item v-if="item.family" :name="$t('family')" :value="item.family" />
            <list-item v-if="item.vlan" :name="$t('vlan')" :value="item.vlan" />
            <list-item
              :name="$t('last_seen')"
              :value="$vuntangle.dates.formatLocaleDate(selectedDevice.LastUpdate * 1000)"
            />
            <v-divider />
          </v-list-group>

          <list-item
            :name="$t('data_usage')"
            :value="renderDataUsage(selectedDevice.sessionDetail.dataUsage)"
            :indent="false"
          />
          <list-item :name="$t('active_sessions')" :value="selectedDevice.sessionDetail.numSessions" :indent="false" />
          <list-item
            :name="$t('active_transfer_rate')"
            :value="renderActiveTransferRate(selectedDevice.sessionDetail.byteTransferRate)"
            :indent="false"
          />
        </v-list>
      </v-card>
    </div>
    <div v-else-if="showGrid === false">
      <v-container>
        <no-license class="mt-8">
          {{ $t('discovery_license_required') }}
        </no-license>
      </v-container>
    </div>
  </div>
</template>

<script>
  import {
    VCard,
    VCardTitle,
    VList,
    VListGroup,
    VListItem,
    VListItemContent,
    VListItemTitle,
    VListItemSubtitle,
  } from 'vuetify/lib'
  import NoLicense from '../NoLicense/Main.vue'
  import renderer from '../../plugins/renderer'
  import util from '../../plugins/util'
  import ListItem from './ListItem.vue'

  export default {
    components: {
      VCard,
      VCardTitle,
      VList,
      VListGroup,
      VListItem,
      VListItemContent,
      VListItemTitle,
      VListItemSubtitle,
      ListItem,
      NoLicense,
    },
    props: {
      boxSettings: { type: Object, default: () => {} },
      // the actual devices data
      devices: { type: Array, default: () => [] },
      fetching: { type: Boolean, default: false },
      showGrid: { type: Boolean, default: false },
    },
    data: () => ({
      selection: [],
    }),

    computed: {
      // return a map like {"eth0":"internal" , "eth1":"WAN0", "ma1_1":"MGMT1"}
      deviceMap() {
        const interfaces = this.boxSettings.network.interfaces
        return Object.fromEntries(interfaces.map(i => [i.device, i.name]))
      },
      // return selected device
      selectedDevice() {
        return this.selection[0]
      },

      // return a sorted array with all the collectors associated
      selectedDeviceCollectors() {
        if (!this.selectedDevice) return
        return this.orderedCollectors(this.selectedDevice).sorted
      },

      columnDefs() {
        return [
          {
            colId: 'mac_address',
            headerName: this.$t('mac_address'),
            field: 'macAddress',
            cellRenderer: ({ value }) => `<strong>${value}</strong>`,
          },
          {
            colId: 'last_seen',
            headerName: this.$t('last_seen'),
            sort: 'desc',
            autoHeight: true,
            cellRenderer: this.cellRenderer,
            valueGetter: this.formatValuesForColumn,
          },
          {
            colId: 'client_address',
            field: 'client_address',
            headerName: this.$t('client_address'),
            autoHeight: true,
            cellRenderer: this.cellRenderer,
            valueGetter: this.formatValuesForColumn,
            // values (a/b) are arrays, first one being the emphasized one (latest)
            comparator: (a, b) => util.compareIpAny(a[0], b[0]),
          },
          {
            colId: 'client_interface',
            headerName: this.$t('client_interface_id'),
            autoHeight: true,
            cellRenderer: this.cellRenderer,
            valueGetter: this.formatValuesForColumn,
          },
          {
            colId: 'system_info',
            headerName: this.$t('system_info'),
            autoHeight: true,
            cellRenderer: this.cellRenderer,
            valueGetter: this.formatValuesForColumn,
          },
          {
            colId: 'host_name',
            headerName: this.$t('host_name'),
            autoHeight: true,
            cellRenderer: this.cellRenderer,
            valueGetter: this.formatValuesForColumn,
          },
          {
            headerName: this.$t('data_usage'),
            field: 'dataUsage',
            valueGetter: ({ data }) => {
              const { sessionDetail } = data
              if (sessionDetail && sessionDetail.dataUsage)
                return renderer.bytesRenderer(sessionDetail.dataUsage).replace(/<\/?b>/g, '')
            },
          },
          {
            headerName: this.$t('active_sessions'),
            field: 'numSessions',
            valueGetter: ({ data }) => {
              const { sessionDetail } = data
              if (sessionDetail && sessionDetail.numSessions) return sessionDetail.numSessions
            },
          },
          {
            headerName: this.$t('active_transfer_rate'),
            field: 'byteTransferRate',
            valueGetter: ({ data }) => {
              const { sessionDetail } = data
              if (sessionDetail && sessionDetail.byteTransferRate)
                return renderer.bytesSecRenderer(sessionDetail.byteTransferRate).replace(/<\/?b>/g, '')
            },
          },
        ]
      },
    },

    methods: {
      /**
       * Returns an array with all the collectors associated with a mac
       * + an ip based rolledup values
       * Supposing an entry like
       * {
       *   macAddress: '9C:C9:EB:0A:D1:65'
       *   {
       *     nmap: {
       *       '1.2.3.4': { LastUpdate: xxx, ... }, <- array[0]
       *     },
       *     lldp: {
       *       '1.2.3.4': { LastUpdate: xxx, ... }, <- array[1]
       *     }
       *     neigh: {
       *       '1.2.3.4': { LastUpdate: xxx, ... }, <- array[2]
       *       '2.3.4.5': { LastUpdate: xxx, ... }, <- array[3]
       *     },
       *   }
       * }
       * It also adds a `type` for each array item, to know from which collector came
       * Then it sorts the elements by `LastUpdate` descending
       * Last collector being shown first
       */
      orderedCollectors(entry) {
        let sorted = []
        if (entry.nmap) sorted = [...sorted, ...Object.values(entry.nmap).map(el => ({ ...el, type: 'nmap' }))]
        if (entry.lldp) sorted = [...sorted, ...Object.values(entry.lldp).map(el => ({ ...el, type: 'lldp' }))]
        if (entry.neigh) sorted = [...sorted, ...Object.values(entry.neigh).map(el => ({ ...el, type: 'neigh' }))]

        sorted.sort((a, b) => {
          if (a.LastUpdate > b.LastUpdate) return -1
          if (a.LastUpdate < b.LastUpdate) return 1
          return 0
        })

        // ip based data rollup
        const rolledUp = {}

        sorted.forEach(el => {
          if (!el.ip) return // this excludes LLDP which does not return an IP
          if (!rolledUp[el.ip]) {
            rolledUp[el.ip] = {
              lastUpdate: el.LastUpdate,
            }
          }
          rolledUp[el.ip].ip = el.ip
          if (el.interface && !rolledUp[el.ip].interface) rolledUp[el.ip].interface = el.interface
          if ((el.os || el.sysName) && !rolledUp[el.ip].sys) rolledUp[el.ip].sys = el.os || el.sysName
          if (el.hostname && !rolledUp[el.ip].hostname) rolledUp[el.ip].hostname = el.hostname
        })

        return { sorted, rolledUp: Object.values(rolledUp) }
      },

      /**
       * Format values for specific column types
       */
      formatValuesForColumn({ colDef, data }) {
        const rolledData = this.orderedCollectors(data).rolledUp
        let values = []
        switch (colDef.colId) {
          case 'last_seen':
            values = rolledData.map(val => this.$vuntangle.dates.formatLocaleDate(val.lastUpdate * 1000))
            break
          case 'client_address':
            values = rolledData.map(val => val.ip || '-')
            break
          case 'client_interface':
            values = rolledData.map(val => this.deviceMap[val.interface] || '-')
            break
          case 'system_info':
            values = rolledData.map(val => val.sys || '-')
            break
          case 'host_name':
            values = rolledData.map(val => val.hostname || '-')
            break
        }
        return values
      },

      /**
       * renders the above array value in it's auto-height cell as a list
       * first element (last info from a collector) being emphasized
       */
      cellRenderer({ value }) {
        return `<strong>${value[0]}</strong><br/> ${value.join('<br/>')}`
      },

      // rendering helpers
      renderDataUsage(value) {
        return value ? renderer.bytesRenderer(value) : ''
      },
      renderActiveTransferRate(value) {
        return value ? renderer.bytesSecRenderer(value) : ''
      },
      renderUptime(value) {
        return value ? util.formatUptime(value) : ''
      },
      renderOpenPorts(value) {
        if (!value || !Array.isArray(value)) {
          return
        }
        const out = []
        value.forEach(v => {
          out.push(`${v.port} (${v.protocol})`)
        })
        return out.join(', ')
      },
    },
  }
</script>
