<template>
  <v-container fluid class="pa-4">
    <div class="d-flex align-center">
      <h1
        :class="`headline ${!classicView ? 'font-weight-light' : ''}`"
        v-text="`${!settingsCopy.policyId ? $vuntangle.$t('add_wan_policy') : $vuntangle.$t('edit_wan_policy')}`"
      />
      <v-spacer />
      <slot name="actions" :new-settings="settingsCopy" :is-dirty="isDirty"></slot>
    </div>
    <v-divider class="my-2" />
    <ValidationObserver ref="obs">
      <component :is="!classicView ? 'div' : 'u-section'">
        <slot v-if="!!$slots['extra-fields']" name="extra-fields" />
        <ValidationProvider v-if="showDescription" v-slot="{ errors }" rules="required">
          <u-text-field
            v-model="settingsCopy.description"
            :label="$vuntangle.$t('description')"
            :error-messages="errors"
            class="flex-grow-1"
          >
            <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
          </u-text-field>
        </ValidationProvider>
      </component>

      <component :is="!classicView ? 'div' : 'u-section'">
        <v-row class="my-4">
          <!-- the policy type selector: SPECIFIC_WAN, BEST_OF, BALANCE -->
          <v-col cols="2">
            <div class="font-weight-bold mr-2">{{ $vuntangle.$t('policy_wan_selection_type') }}:</div>
            <v-radio-group v-model="typeSelection" class="my-0">
              <v-radio
                v-for="(text, type) in policyTypeOptions"
                :key="`type-${type}`"
                :value="type"
                :label="$vuntangle.$t(text)"
              />
            </v-radio-group>
          </v-col>

          <!-- wan selector for SPECIFIC_WAN type -->
          <v-col v-if="settingsCopy.type === 'SPECIFIC_WAN'" cols="2">
            <div class="font-weight-bold mr-2">{{ $vuntangle.$t('wans') }}:</div>
            <v-radio-group v-model="specificWanInterface" class="my-0">
              <v-radio v-for="wan in wans" :key="wan.interfaceId" :value="wan.interfaceId" :label="wan.name" />
            </v-radio-group>
          </v-col>

          <!-- metric selector for BEST_OF type -->
          <v-col v-if="settingsCopy.type === 'BEST_OF'" cols="3">
            <div class="font-weight-bold mr-2">{{ $vuntangle.$t('metric') }}:</div>
            <v-radio-group v-model="settingsCopy.best_of_metric" class="my-0">
              <v-radio
                v-for="(text, metric) in policyBestOfMetrics"
                :key="`metric-${metric}`"
                :value="metric"
                :label="$vuntangle.$t(text)"
              />
            </v-radio-group>
          </v-col>

          <!-- algorithm selector for BALANCE type -->
          <v-col v-if="settingsCopy.type === 'BALANCE'" cols="3">
            <div class="font-weight-bold mr-2">{{ $vuntangle.$t('algorithm') }}:</div>
            <v-radio-group v-model="settingsCopy.balance_algorithm" class="my-0">
              <v-radio
                v-for="(text, algorithm) in policyBalanceAlgorithms"
                :key="`balance-${algorithm}`"
                :value="algorithm"
                :label="$vuntangle.$t(text)"
              />
            </v-radio-group>
          </v-col>

          <template v-if="(settingsCopy.type === 'BEST_OF' || settingsCopy.type === 'BALANCE') && !omitSpecificWans">
            <!-- all or specific selector for BEST_OF and BALANCE types -->
            <v-col cols="2">
              <div class="font-weight-bold mr-2">{{ $vuntangle.$t('select') }}:</div>
              <v-radio-group v-model="wanSelection" class="my-0">
                <v-radio value="ALL" :label="$vuntangle.$t('all_wans')"></v-radio>
                <v-radio value="SPECIFIC" :label="$vuntangle.$t('pick_specific_wans')"></v-radio>
              </v-radio-group>
            </v-col>

            <!-- selector with all available wans that can be selected -->
            <v-col v-if="wanSelection === 'SPECIFIC'" cols="2">
              <div class="font-weight-bold mr-2">{{ $vuntangle.$t('wans') }}:</div>
              <v-checkbox
                v-for="wan in selectedWansTracker"
                :key="`wan-${wan.id}`"
                v-model="wan.selected"
                :disabled="wan.selected && settingsCopy.interfaces.length <= 1"
                :label="wan.name"
                class="mt-0 mb-1"
                hide-details
                style="width: 200px"
              />
            </v-col>

            <!-- weight sliders for BALANCE WEIGHTED algorithm -->
            <v-col
              v-if="
                settingsCopy.type === 'BALANCE' &&
                settingsCopy.balance_algorithm === 'WEIGHTED' &&
                wanSelection === 'SPECIFIC'
              "
              cols="3"
            >
              <div class="font-weight-bold mr-2">{{ $vuntangle.$t('weight') }}:</div>
              <div v-for="wan in selectedWansTracker" :key="`weight-${wan.id}`" class="d-flex">
                <v-slider
                  v-model="wan.weight"
                  :disabled="!wan.selected"
                  thumb-label
                  :ticks="false"
                  hide-details
                  class="my-0"
                >
                  <template #append>
                    <div class="caption" style="width: 80px">
                      <strong>{{ wan.weight }}</strong> ({{ computePercent(wan.id) }}%)
                    </div>
                  </template>
                </v-slider>
              </div>
            </v-col>
          </template>
        </v-row>

        <!-- CRITERIA section -->
        <h3 class="mb-3">{{ $vuntangle.$t('wan_criteria') }}</h3>

        <!-- using condition.type as an extra key composer -->
        <div v-for="(criteria, index) in settingsCopy.criteria" :key="index" class="d-flex align-center mb-2">
          <wan-criteria :criteria.sync="settingsCopy.criteria[index]" v-on="$listeners" />
          <v-btn icon class="ml-2" @click="onRemoveCriteria(index)"> <v-icon>mdi-close</v-icon></v-btn>
        </div>
        <u-btn @click="onAddCriteria">{{ $vuntangle.$t('add_criteria') }}</u-btn>
      </component>
    </ValidationObserver>
  </v-container>
</template>
<script>
  import {
    VContainer,
    VSpacer,
    VDivider,
    VCheckbox,
    VRow,
    VCol,
    VRadioGroup,
    VRadio,
    VSlider,
    VBtn,
    VIcon,
  } from 'vuetify/lib'
  import { ValidationObserver, ValidationProvider } from 'vee-validate'
  import settingsMixin from '../settingsMixin'
  import { policyTypes, policyBestOfMetrics, policyBalanceAlgorithms } from './data/options'
  import WanCriteria from './WanCriteria.vue'

  export default {
    components: {
      VContainer,
      VSpacer,
      VDivider,
      VCheckbox,
      VRow,
      VCol,
      VRadioGroup,
      VRadio,
      VSlider,
      VBtn,
      VIcon,
      ValidationObserver,
      ValidationProvider,

      WanCriteria,
    },
    mixins: [settingsMixin],
    props: {
      // all the wans that can be part of a policy also passed from host app
      wans: { type: Array, default: () => [] },
    },
    data: () => ({
      wanSelection: undefined, // ALL or SPECIFIC
      selectedWansTracker: [], // keeps track of specific wans selection and if it's the case their weights
      mixins: [settingsMixin],

      policyTypes,
      policyBestOfMetrics,
      policyBalanceAlgorithms,
    }),
    computed: {
      /**
       * for cloud is needed to omit specific wan policies
       * if no wans are passed to the component than it omits any configs implying specific wans
       */
      omitSpecificWans: ({ wans }) => !wans?.length,

      /**
       * removes the SPECIFIC_WAN option if specific wans omitted
       */
      policyTypeOptions: ({ omitSpecificWans, policyTypes }) => {
        if (omitSpecificWans) {
          delete policyTypes.SPECIFIC_WAN
        }
        return policyTypes
      },

      // returns the first wan used for specific type, applies for mfw only
      firstWan: ({ wans }) => wans[0] || undefined,

      typeSelection: {
        get: ({ settingsCopy }) => {
          return settingsCopy.type
        },
        set(type) {
          this.settingsCopy.type = type
          if (!this.settingsCopy.best_of_metric) {
            // sets default metric for BEST_OF
            this.$set(this.settingsCopy, 'best_of_metric', 'LOWEST_LATENCY')
          }
          if (!this.settingsCopy.balance_algorithm) {
            // selects default algorithm for BALANCE
            this.$set(this.settingsCopy, 'balance_algorithm', 'WEIGHTED')
          }
        },
      },

      /**
       * computed for SPECIFIC_WAN selection type
       */
      specificWanInterface: {
        get: ({ settingsCopy }) => settingsCopy.interfaces[0].interfaceId,
        set(value) {
          this.settingsCopy.interfaces = [{ interfaceId: value }]
        },
      },
    },

    /**
     * all those watchers are needed to keep track of the selected wans and their weight
     */
    watch: {
      'wanSelection'() {
        this.updateWansTracker()
      },
      'settingsCopy.type'() {
        this.updateWansTracker()
      },
      'settingsCopy.balance_algorithm'() {
        this.updateWansTracker()
      },
      'settingsCopy.best_of_metric'() {
        this.updateWansTracker()
      },
      selectedWansTracker: {
        handler() {
          this.updateWansTracker()
        },
        deep: true,
      },
    },

    created() {
      if (!this.settingsCopy) {
        this.settingsCopy = {
          criteria: [],
          interfaces: [{ interfaceId: this.firstWan?.interfaceId || 0 }],
          type: this.omitSpecificWans ? 'BEST_OF' : 'SPECIFIC_WAN',
        }
      }
      if (!this.omitSpecificWans) {
        this.initializeWansSelectionTracker()
      } else {
        this.wanSelection = 'ALL'
      }
    },

    methods: {
      /**
       * based on initial policy settings passed to the component
       * it sets up the selected wans tracker
       */
      initializeWansSelectionTracker() {
        this.wanSelection =
          this.settingsCopy.interfaces.length === 1 && this.settingsCopy.interfaces[0].interfaceId === 0
            ? 'ALL'
            : 'SPECIFIC'

        const selection = []
        this.wans.forEach(wan => {
          const intf = this.settingsCopy.interfaces.find(intf => intf.interfaceId === wan.interfaceId)
          selection.push({
            id: wan.interfaceId,
            name: wan.name,
            selected: this.wanSelection === 'ALL' ? true : !!intf,
            weight: intf?.weight || 50,
          })
        })
        this.selectedWansTracker = selection
      },

      /**
       * updates the policy interfaces based on UI selections
       */
      updateWansTracker() {
        // reset interfaces & remove keys based on `type`
        switch (this.settingsCopy.type) {
          case 'SPECIFIC_WAN':
            delete this.settingsCopy.balance_algorithm
            delete this.settingsCopy.best_of_metric
            break
          case 'BEST_OF':
            delete this.settingsCopy.balance_algorithm
            break
          case 'BALANCE':
            delete this.settingsCopy.best_of_metric
        }
        // reset interfaces & remove keys when SPECIFIC_WAN
        if (this.settingsCopy.type === 'SPECIFIC_WAN') {
          // preselect specific interface instead of ALL (id: 0) when SPECIFIC_WAN
          this.settingsCopy.interfaces = [{ interfaceId: this.settingsCopy.interfaces[0].interfaceId }]
        } else {
          if (this.wanSelection === 'ALL') {
            this.settingsCopy.interfaces = [{ interfaceId: 0 }]
            return
          }
          const interfaces = []
          this.selectedWansTracker.forEach(wan => {
            if (wan.selected) {
              const intf = { interfaceId: wan.id }
              if (this.settingsCopy.type === 'BALANCE' && this.settingsCopy.balance_algorithm === 'WEIGHTED') {
                intf.weight = wan.weight || 50
              }
              interfaces.push(intf)
            }
          })
          this.settingsCopy.interfaces = interfaces
        }
      },

      /**
       * used for showing a percentage corresponding to each wan weight
       */
      computePercent(wanId) {
        const wan = this.selectedWansTracker.find(wan => wan.id === wanId)
        if (wan && !wan.selected) return 0

        let totalWeight = 0
        this.selectedWansTracker.forEach(wan => {
          if (wan.selected) totalWeight += wan.weight
        })
        return ((wan.weight / totalWeight) * 100).toFixed(2)
      },

      // just ads a new empty criteria entry
      onAddCriteria() {
        /**
         * MFW-2673 - auto generated wan policies when creating an IPsec/wireguard interface
         * do not have `criteria` field set
         */
        if (!this.settingsCopy.criteria) {
          this.$set(this.settingsCopy, 'criteria', [])
        }
        this.settingsCopy.criteria.push({})
      },

      onRemoveCriteria(index) {
        this.$delete(this.settingsCopy.criteria, index)
      },

      /**
       * validation called from the host app
       */
      async validate() {
        const isValid = await this.$refs.obs.validate()
        return isValid
      },
    },
  }
</script>
