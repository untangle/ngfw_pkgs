<template>
  <v-container :fluid="true" :class="`d-flex flex-column flex-grow-1 shared-cmp ${disabled ? 'disabled' : ''}`">
    <div class="d-flex align-center">
      <h2 class="font-weight-light">{{ $vuntangle.$t('dynamic_blocklist') }}</h2>
      <v-spacer />
      <slot name="actions" :new-settings="settingsCopy" :is-dirty="isDirty" :disabled="disabled" />
    </div>
    <v-divider class="my-2" />
    <p class="body-2 my-4">
      {{ $vuntangle.$t('dynamic_blocklist_description') }}
    </p>
    <u-section v-if="!!$slots['extra-fields']">
      <slot name="extra-fields" />
    </u-section>
    <div class="d-flex my-2 align-center">
      <!-- Enable/Disable toggle -->
      <v-switch
        v-model="settingsCopy.enabled"
        :disabled="disabled"
        class="body-2 my-0 py-0"
        dense
        inset
        hide-details
        :label="
          $vuntangle.$t('toggle_block_list', [
            settingsCopy.enabled ? $vuntangle.$t('enabled') : $vuntangle.$t('disabled'),
          ])
        "
      />
      <v-spacer />

      <u-btn
        v-if="!features.isTemplateView"
        color="primary"
        class="mr-2"
        :disabled="disabled || !settings.enabled || !canSelectedDownload()"
        @click="downloadSelected()"
      >
        <v-icon left>mdi-download</v-icon> {{ $vuntangle.$t('download_to_appliance') }}
      </u-btn>

      <u-btn color="primary" @click="onEdit({})">
        <v-icon left>mdi-plus</v-icon> {{ $vuntangle.$t('add_source') }}
      </u-btn>
    </div>

    <u-grid
      id="dynamic-blocklists"
      row-node-id="id"
      :row-data="combinedData"
      :column-defs="columnDefs"
      :enable-refresh="!features.isTemplateView"
      :row-actions="rowActions"
      :fetching="fetching"
      :selection-type="!features.isTemplateView ? 'multiAction' : ''"
      :selection.sync="selection"
      :framework-components="frameworkComponents"
      :custom-grid-options="{ suppressRowClickSelection: true }"
      @row-clicked="onEdit"
      @refresh="$emit('refresh')"
    />
  </v-container>
</template>

<script>
  import cloneDeep from 'lodash/cloneDeep'
  import { VContainer, VSpacer, VDivider } from 'vuetify/lib'
  import settingsMixin from '../settingsMixin'
  import util from '../../plugins/util'
  import UGrid from '../../components/UGrid'
  import CheckboxRenderer from '../../components/UGrid/renderers/CheckboxRenderer.vue'
  import dates from '../../plugins/dates'
  import DynamicBlockList from './DynamicBlockList.vue'
  import { settingsDefaults as defaults } from './defaults'

  export default {
    components: { VContainer, VSpacer, VDivider, UGrid },
    mixins: [settingsMixin],
    defaults,
    props: {
      status: { type: Array, default: () => [] },
      fetching: { type: Boolean, default: false },
    },
    data() {
      return {
        combinedData: [],
        selection: [],
        frameworkComponents: {
          CheckboxRenderer,
        },
      }
    },
    computed: {
      columnDefs() {
        const columns = [
          {
            headerName: this.$vuntangle.$t('enabled'),
            field: 'enabled',
            minWidth: 50,
            width: 80,
            flex: 0,
            cellRenderer: 'CheckboxRenderer',
          },
          { headerName: this.$vuntangle.$t('source_name'), field: 'name', flex: 1 },
          { headerName: this.$vuntangle.$t('source_url'), field: 'source', flex: 2 },
          {
            headerName: this.$vuntangle.$t('polling_interval'),
            minWidth: 120,
            valueGetter: ({ data }) => {
              if (data.pollingTime && data.pollingUnit) {
                return data.pollingTime + ' ' + this.$vuntangle.$tc(data.pollingUnit.toLowerCase(), data.pollingTime)
              } else {
                return this.$vuntangle.$t('no_polling')
              }
            },
            comparator: (a, b, nodeA, nodeB) => {
              return util.compareTimeIntervals(
                nodeA.data.pollingTime,
                nodeA.data.pollingUnit,
                nodeB.data.pollingTime,
                nodeB.data.pollingUnit,
              )
            },
          },
        ]
        if (!this.features.isTemplateView) {
          columns.splice(0, 0, {
            headerName: this.$vuntangle.$t('status'),
            field: 'status',
            minWidth: 50,
            width: 80,
            flex: 0,
            sortable: true,
            valueGetter: ({ data }) => {
              return this.$vuntangle.$t(this.getStatusTooltip(data))
            },
            cellRenderer: 'CellWithTooltip',
            cellRendererParams: params => {
              return {
                icon: 'mdi-circle',
                small: true,
                color: this.getStatusColor(params.data),
                top: true,
                tooltip: this.$vuntangle.$t(this.getStatusTooltip(params.data)),
              }
            },
          })
          columns.push(
            ...[
              {
                headerName: this.$vuntangle.$t('count'),
                field: 'num_entries',
                minWidth: 50,
                width: 70,
                flex: 0,
                valueFormatter: ({ value }) => {
                  return value || value === 0 ? value : '-'
                },
              },
              {
                headerName: this.$vuntangle.$t('last_updated'),
                field: 'last_updated_time',
                valueFormatter: ({ value }) => {
                  return dates.formatDateFromApi(value * 1000) || '-'
                },
              },
            ],
          )
        }
        return columns
      },

      rowActions() {
        return [
          {
            icon: 'mdi-download',
            isHidden: ({ data }) => {
              return (
                !this.settingsCopy.enabled ||
                !this.settings.enabled ||
                !this.isSavedAsEnabled(data.id) ||
                this.features.isTemplateView
              )
            },
            tooltip: this.$vuntangle.$t('download_to_appliance'),
            handler: ({ data }) => this.$emit('download', [data.id]),
          },
          {
            icon: 'mdi-publish',
            isHidden: ({ data }) => {
              return !data.num_entries || this.features.isTemplateView
            },
            tooltip: this.$vuntangle.$t('export_csv'),
            handler: ({ data }) => this.$emit('download-csv', data.id),
          },
          {
            icon: 'mdi-pencil',
            tooltip: this.$vuntangle.$t('edit'),
            handler: this.onEdit,
          },
          {
            icon: 'mdi-delete',
            tooltip: this.$vuntangle.$t('remove'),
            handler: ({ data }) => this.onDeleteConfiguration(data),
          },
        ]
      },
    },

    /** watchers used to generate combined data from settings and status */
    watch: {
      settingsCopy: {
        handler() {
          this.setCombinedData()
        },
        immediate: true,
        deep: true,
      },
      /** sets the enabled flag on configurations when using the grid Enabled column checkboxes  */
      combinedData: {
        handler(data) {
          data.forEach((entry, index) => {
            this.settingsCopy.configurations[index].enabled = entry.enabled
          })
        },
        immediate: true,
        deep: true,
      },

      status: {
        handler() {
          this.setCombinedData()
        },
        immediate: true,
        deep: true,
      },
    },

    methods: {
      /**
       * Combines the settings data with the status data to be displayed in the grid
       */
      setCombinedData() {
        if (!this.settingsCopy || !this.status) return
        const list = cloneDeep(this.settingsCopy.configurations)
        list.forEach(conf => {
          const confStatus = this.status.find(s => s.uuid === conf.id)
          if (confStatus) {
            this.$set(conf, 'num_entries', confStatus.num_entries)
            this.$set(conf, 'status', confStatus.status)
            this.$set(conf, 'last_updated_time', confStatus.last_updated_time)
          }
        })
        this.combinedData = list
      },

      /**
       * Downloads the selected configurations to the appliance
       */
      downloadSelected() {
        const list = []
        this.selection.forEach(entry => {
          const conf = this.settingsCopy.configurations.find(c => c.id === entry.id)
          if (conf && conf.enabled && this.isSavedAsEnabled(conf.id)) {
            list.push(conf.id)
          }
        })
        if (list.length) {
          this.$emit('download', list)
        }
      },

      /**
       * Enables the mass action to downloads the selected configurations to the appliance
       * Requires selecting no configurations which are invalid for download
       */
      canSelectedDownload() {
        return (
          this.selection.length &&
          this.settingsCopy.enabled &&
          this.settings.enabled &&
          !this.selection.find(s => {
            const conf = this.settingsCopy.configurations.find(c => c.id === s.id)
            return !(conf && conf.enabled && this.isSavedAsEnabled(conf.id))
          })
        )
      },

      /**
       * Returns the saved `enabled` state of the configuration
       * @param {String} confId - the configuration UUID for which `enabled` prop is set
       */
      isSavedAsEnabled(confId) {
        const conf = this.settings.configurations.find(c => c.id === confId)
        return conf ? conf.enabled : false
      },

      /**
       * Shows confirm dialog when deleting a configuration
       * Upon confirm the `delete-configuration` gets emitted to the host app
       * @param configuration - complete configuration object for respective row
       */
      onDeleteConfiguration(configuration) {
        /**
         * in case of global templates the entry is not just removed from list
         * whithout being pushed, as the template may not jave been yet created
         */
        if (this.features.isTemplateView) {
          const index = this.settingsCopy.configurations.findIndex(conf => conf.id === configuration.id)
          if (index >= 0) {
            this.settingsCopy.configurations.splice(index, 1)
          }
          return
        }

        this.$vuntangle.confirm.show({
          title: `<i class="mdi mdi-alert" style="font-style: normal;"> ${this.$vuntangle.$t('confirm')}</i>`,
          message: this.$vuntangle.$t('remove_block_list', [configuration.name]),
          confirmLabel: this.$vuntangle.$t('yes'),
          cancelLabel: this.$vuntangle.$t('no'),
          action: async resolve => {
            await this.$emit('delete-configuration', configuration.id)
            resolve()
          },
        })
      },

      /**
       * Get the color for the status icon
       * @param item - row item
       */
      getStatusColor(item) {
        if (!this.settings.enabled || !this.isSavedAsEnabled(item.id)) {
          return 'gray' // gray if the blocklist or all blocklists are saved as disabled
        } else if (item.status === undefined || item.status == null) {
          return 'gray' // gray if the blocklist has never polled for status
        } else if (item.status) {
          return '#68bd49' // green if it has polled and reached the url
        } else {
          return 'red' // red indicates failure to reach url
        }
      },

      /**
       * Get the tooltip text for the status icon
       * @param item - row item
       */
      getStatusTooltip(item) {
        if (!this.settings.enabled || !this.isSavedAsEnabled(item.id)) {
          return 'disabled' // the blocklist or all blocklists are saved as disabled
        } else if (item.status === undefined || item.status == null) {
          return 'last_update_never' // blocklist has never polled for status
        } else if (item.status) {
          return 'last_update_succeeded' // it has polled and reached the url
        } else {
          return 'last_update_failed' // failure to reach url
        }
      },

      /**
       * Shows route edit dialog, it adds a new route if index undefined
       * @param index - number
       */
      onEdit({ data }) {
        const id = data?.id
        // extract only conf data on grid row click (avoid getting status data in conf columns)
        const settings = this.settingsCopy.configurations.find(conf => conf.id === id) || undefined

        this.$vuntangle.dialog.show({
          title: !id ? this.$vuntangle.$t('add_blocklist') : this.$vuntangle.$t('edit_blocklist'),
          component: DynamicBlockList,
          width: 800,
          height: 'auto',
          actionLabel: !id ? this.$vuntangle.$t('add') : this.$vuntangle.$t('update'),
          componentProps: {
            settings,
          },
          componentEvents: {
            // updates configuration
            update: entry => {
              const index = this.settingsCopy.configurations.findIndex(conf => conf.id === id)
              if (index >= 0) this.settingsCopy.configurations.splice(index, 1, entry)
              else this.settingsCopy.configurations.push(entry)

              /**
               * for global templates the changes are not going to be pushed right away
               * upon add/edit/delete a list entry as the template might not have been created yet
               */
              if (this.features.isTemplateView) return
              this.$emit('update-settings', this.settingsCopy)
            },
          },
        })
      },
    },
  }
</script>
