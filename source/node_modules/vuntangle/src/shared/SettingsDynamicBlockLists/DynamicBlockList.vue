<template>
  <div v-if="settingsCopy" class="py-2">
    <ValidationObserver ref="obs">
      <v-row align="center">
        <v-col>
          <ValidationProvider v-slot="{ errors }" rules="required">
            <u-text-field v-model="settingsCopy.name" :label="$vuntangle.$t('name')" :error-messages="errors">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
        <v-col cols="auto">
          <v-checkbox v-model="settingsCopy.enabled" :label="$vuntangle.$t('enabled')" hide-details class="pa-0 ma-0" />
        </v-col>
      </v-row>

      <h4 class="my-4">{{ $vuntangle.$t('polling_source') }}</h4>
      <v-row align="center">
        <v-col>
          <ValidationProvider v-slot="{ errors }" rules="required|url">
            <u-text-field v-model="settingsCopy.source" :label="$vuntangle.$t('source_url')" :error-messages="errors">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
        <v-col cols="auto">
          <v-checkbox
            v-model="settingsCopy.skipCertCheck"
            :label="$vuntangle.$t('ignore_ssl_cert_errors')"
            hide-details
            class="pa-0 ma-0"
          />
        </v-col>
      </v-row>

      <h4 class="my-4">{{ $vuntangle.$t('polling_interval') }}</h4>
      <v-row>
        <v-col cols="4">
          <ValidationProvider v-slot="{ errors }" rules="required">
            <u-select
              v-model="settingsCopy.pollingUnit"
              :items="pollingUnits"
              :label="$vuntangle.$t('unit')"
              :error-messages="errors"
            >
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-select>
          </ValidationProvider>
        </v-col>
        <v-col cols="2">
          <ValidationProvider v-slot="{ errors }" rules="required">
            <u-select
              v-model="settingsCopy.pollingTime"
              :items="timeOptions"
              :error-messages="errors"
              :label="$vuntangle.$t('value')"
            >
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-select>
          </ValidationProvider>
        </v-col>
      </v-row>

      <h4 class="my-4">{{ $vuntangle.$t('parsing_method') }}</h4>
      <v-row>
        <v-col cols="6">
          <u-select v-model="selectedParse" :items="parsingOptions"> </u-select>
        </v-col>
        <v-col v-if="selectedParse === 'custom'" cols="6">
          <ValidationProvider v-slot="{ errors }" rules="required|valid_regex">
            <u-text-field v-model="customRegex" :error-messages="errors" :label="$vuntangle.$t('custom_regex')">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
      </v-row>
    </ValidationObserver>
  </div>
</template>
<script>
  import { VRow, VCol, VCheckbox } from 'vuetify/lib'
  import settingsMixin from '../settingsMixin'
  import util from '../../plugins/util'
  import USelect from '../../components/USelect'
  import UTextField from '../../components/UTextField'
  import { configurationDefaults as defaults } from './defaults'

  const firstIpRegex = '^\\S{2,256}'
  const everyIpRegex =
    '((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)+|(?:[a-f0-9:]+:+)+(?:[a-f0-9](?:(::)?))+)(?:\\/{1}\\d+|-((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)+|(?:[a-f0-9:]+:+)+(?:[a-f0-9](?:(::)?))+))?'
  const customValue = 'custom' // note: this is also used in the components above. But those are pre-render, so a naked string is required

  export default {
    components: {
      VRow,
      VCol,
      VCheckbox,
      USelect,
      UTextField,
    },
    defaults,
    mixins: [settingsMixin],
    data: () => ({
      customRegex: '',
      selectedParse: firstIpRegex,
    }),
    computed: {
      /** units for the polling interval */
      pollingUnits() {
        return [
          { text: this.$vuntangle.$tc('minutes', 2), value: 'Minutes', range: [15, 45] },
          { text: this.$vuntangle.$tc('hours', 2), value: 'Hours', range: [1, 23] },
          { text: this.$vuntangle.$t('days'), value: 'Days', range: [1, 30] },
          { text: this.$vuntangle.$tc('months', 2), value: 'Months', range: [1, 12] },
        ]
      },

      /** computes the polling interval values based on unit range */
      timeOptions: ({ settingsCopy, pollingUnits }) => {
        const unit = pollingUnits.find(unit => unit.value === settingsCopy.pollingUnit)
        const range = unit?.range
        if (!unit || !range) return []
        return Array.from({ length: range[1] }, (_, index) => range[0] + index)
      },

      /** Options for blocklist parsing */
      parsingOptions() {
        return [
          { text: this.$vuntangle.$t('dynamic_blocklist_first_ip_parse'), value: firstIpRegex },
          { text: this.$vuntangle.$t('dynamic_blocklist_every_ip_parse'), value: everyIpRegex },
          { text: this.$vuntangle.$t('dynamic_blocklist_custom_parse'), value: customValue },
        ]
      },
    },

    watch: {
      selectedParse: {
        handler(value) {
          // when the user uses the drop-down and selects custom, we save custom regex into sync-settings. Otherwise we use a built-in
          this.settingsCopy.parsingMethod = value === customValue ? this.customRegex : value
        },
      },

      customRegex(value) {
        // when the user types in a custom regex, we make sure settingsCopy gets that value before saving
        if (this.selectedParse === customValue) {
          this.settingsCopy.parsingMethod = value
        }
      },

      settingsCopy: {
        /** generates an UUID for new configurations, without it the configurations is not saved */
        handler(value) {
          if (!value.id) this.settingsCopy.id = util.uuidv4()
        },
        immediate: true,
      },
    },

    created() {
      if (this.parsingOptions.some(item => item.value === this.settingsCopy.parsingMethod)) {
        // if settingsCopy matches one of the parsing options, then the drop-down will show that selection
        this.selectedParse = this.settingsCopy.parsingMethod
      } else {
        // if settingsCopy matches nothing, we have a custom regex (so show that in the options and text box instead)
        this.selectedParse = customValue
        this.customRegex = this.settingsCopy.parsingMethod
      }
    },

    methods: {
      // Dialog main action emitting updated settings
      async action() {
        const isValid = await this.$refs.obs.validate()
        if (!isValid) return

        this.$emit('update', this.settingsCopy)
        this.$emit('close')
      },
    },
  }
</script>
