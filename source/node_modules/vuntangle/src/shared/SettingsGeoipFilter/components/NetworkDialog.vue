<template>
  <v-container class="px-0">
    <ValidationObserver ref="obs">
      <v-row>
        <v-col>
          <ValidationProvider
            v-slot="{ errors }"
            :rules="{
              required: true,
              ip: true,
              pass_network: {
                network: suggestedNetwork,
                existingNetworks: settings.passedNetworks,
                index,
              },
            }"
          >
            <u-text-field v-model="address" :label="$t('ip_address')" :error-messages="errors" @keydown.space.prevent>
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
        <v-col>
          <ValidationProvider v-slot="{ errors }" rules="required">
            <ipv-4-prefix-autocomplete v-model="prefix" :errors="errors" />
          </ValidationProvider>
        </v-col>
      </v-row>
      <v-row>
        <v-col>
          <ValidationProvider v-slot="{ errors }" rules="required">
            <u-text-field v-model="description" :label="$t('description')" :error-messages="errors">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
      </v-row>
      <v-row>
        <v-col>
          <u-alert v-if="suggestedNetwork && suggestedNetwork.networkAddress !== address">
            <span
              v-html="
                $t('geoip_subnet_suggested_network', [
                  `${address}/${prefix}`,
                  `${suggestedNetwork.networkAddress}/${suggestedNetwork.cidr}`,
                ])
              "
            />
          </u-alert>
        </v-col>
      </v-row>
    </ValidationObserver>
  </v-container>
</template>
<script>
  import { VContainer, VRow, VCol } from 'vuetify/lib'
  import { ValidationObserver, ValidationProvider, extend } from 'vee-validate'
  import cloneDeep from 'lodash/cloneDeep'
  import i18n from '../../../plugins/vue-i18n'
  import net from '../../../plugins/net'
  import Ipv4PrefixAutocomplete from '../../../components/Ipv4PrefixAutocomplete'

  export default {
    components: { VContainer, VRow, VCol, ValidationObserver, ValidationProvider, Ipv4PrefixAutocomplete },
    props: {
      settings: { type: Object, required: true }, // full geoip settings
      index: { type: String, required: false, default: '' }, // index of network being edited
    },
    data: () => ({
      address: '',
      prefix: 24,
      description: '',
    }),
    computed: {
      editingNetwork() {
        return this.settings.passedNetworks[this.index] || null
      },
      suggestedNetwork() {
        return net.info(this.address, this.prefix)
      },
    },
    created() {
      // set network if editing
      if (this.editingNetwork) {
        // split host into ip/prefix
        const [address, prefix] = this.editingNetwork.address.split('/')

        this.address = address
        this.prefix = parseInt(prefix)
        this.description = this.editingNetwork.description
      }

      // Validation rule for a network if duplicates or overlaps existing passed network
      extend('pass_network', {
        params: ['network', 'existingNetworks', 'index'],
        /**
         * @param {string} value - the host IP to be checked
         * @param {string} network - the network to be added/edited
         * @param {array} existingNetworks - the existing passed networks to check against
         * @param {number} index - the index of the edited network
         * @returns {boolean}
         */
        validate(value, { network, existingNetworks, index }) {
          index = Number(index)
          if (!network?.networkAddress) return false
          const inputNetwork = `${network.networkAddress}/${network.cidr}`
          let duplicateNetwork = null
          let overlappingNetwork = null
          existingNetworks.forEach((n, idx) => {
            // if editing a network skip duplicate or overlap check against self
            if (index >= 0 && idx === index) return
            // check if duplicate
            if (!duplicateNetwork && n.address === inputNetwork) {
              duplicateNetwork = n.address
            }
            // check if overlapping
            if (!overlappingNetwork && net.subnetConflict(n.address, inputNetwork)) {
              overlappingNetwork = n.address
            }
          })
          if (duplicateNetwork) {
            return i18n.t('geoip_network_duplicate', [duplicateNetwork])
          }
          if (overlappingNetwork) {
            return i18n.t('geoip_network_overlap', [inputNetwork, overlappingNetwork])
          }
          return true
        },
      })
    },
    methods: {
      async action() {
        const isValid = await this.$refs.obs.validate()
        if (!isValid) {
          return
        }

        const networksCopy = cloneDeep(this.settings.passedNetworks)
        let network = {
          address: `${this.address.trim()}/${this.prefix}`,
          description: this.description,
        }

        if (this.suggestedNetwork) {
          network = {
            address: `${this.suggestedNetwork.networkAddress.trim()}/${this.suggestedNetwork.cidr}`,
            description: this.description,
          }
        }

        if (this.editingNetwork) {
          networksCopy[this.index] = network
        } else {
          networksCopy.push(network)
        }

        this.$set(this.settings, 'passedNetworks', networksCopy)
        this.$emit('close')
      },
    },
  }
</script>
