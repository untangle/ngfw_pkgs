<template>
  <v-row dense align="center">
    <!-- CONDITION TYPE
      type selector computed based on condition type and inferred option
      e.g. if type is APPLICATION_NAME and inferred is TRUE
      than the actual condition type settings is APPLICATION_NAME_INFERRED
      basically it adds/removes _INFERRED in type name
    -->
    <v-col cols="4">
      <ValidationProvider v-slot="{ errors }" :rules="conditionTypeRules">
        <u-autocomplete
          v-if="!isObsolete"
          v-model="type"
          :items="conditionTypes"
          :placeholder="$vuntangle.$t('condition')"
          :error-messages="errors"
        >
          <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
        </u-autocomplete>
        <u-text-field v-if="isObsolete" v-model="type" disabled></u-text-field>
      </ValidationProvider>
    </v-col>

    <!-- OPERATORS
      Operator selector behaving as follows:
      - using is, is not (==, !=) for string values of a given condition type (default)
      - using all operators (==, !=, >, <, >=, <=) for numeric values of a specific condition type
      - disabled if type is not set
      - not shown if field is boolean
      Does not need a validator as the value is always set to a default
    -->
    <v-col v-if="conditionDef.field !== 'boolean'" cols="2">
      <u-select
        v-model="conditionCopy.op"
        :items="conditionDef.ops || isOperatorOptions"
        :disabled="!type || isObsolete"
      >
        <template #selection="{ item }">{{ $vuntangle.$t(item.text) }}</template>
        <template #item="{ item }">{{ $vuntangle.$t(item.text) }}</template>
      </u-select>
    </v-col>

    <!-- VALUE
      the condition value that can be entered using different input fields depending on the condition type
      - by default it's a simple textfield
      - in case of application names/categories/ids it's an autocomplete field
      - in case of application productivity/risk it's a select field
      see data/defs.js for each condition type definition, the type of input field

      SOURCE_PORT and DESTINATION_PORT conditions have an extra field `portProtocols`
      based on that, the value field size is shorter to make space for port protocols selector
    -->
    <v-col :cols="type === 'SOURCE_PORT' || type === 'DESTINATION_PORT' || type === 'LIMIT_RATE' ? 2 : undefined">
      <!--
        default input text for string value of condition types
        used for conditions that does not have a specific field defined
        see (data/defs.js)
        - disabled if condition type is not set
        - using default `required` validation rule, along with other rules if specified in condition definition
      -->
      <template v-if="!conditionDef.field">
        <ValidationProvider v-slot="{ errors }" :rules="valueValidationRules">
          <u-text-field
            v-model="value"
            :disabled="!type || isObsolete"
            :placeholder="$vuntangle.$t('value')"
            :error-messages="errors"
          >
            <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
          </u-text-field>
        </ValidationProvider>
      </template>

      <!-- select field
        used for conditions types that have defined the value field being `select`
        - using the `selectItems` from the condition definition as the possible values for the condition value
        - disabled if condition type not set
        see (data/defs.js)
      -->
      <template v-if="conditionDef.field === 'select'">
        <ValidationProvider v-slot="{ errors }" rules="required">
          <u-select
            v-model="value"
            :items="conditionDef.selectItems || remoteItems"
            :disabled="!type || isObsolete"
            :placeholder="$vuntangle.$t('value')"
            :loading="remoteFetching"
            :error-messages="errors"
          >
            <template #selection="{ item }">{{ $vuntangle.$t(item.text) || item }}</template>
            <template #item="{ item }">{{ $vuntangle.$t(item.text) || item }}</template>
            <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
          </u-select>
        </ValidationProvider>
      </template>

      <!-- autocomplete field
        used for conditions types that have defined the value field being `autocomplete`
        the `autocompleteItems` are set via an event captured by the host app, triggering an API call than passes via props the values
        this field applies for APPLICATION_NAME, APPLICATION_CATEGORY and APPLICATION_ID condition types
      -->
      <template v-if="conditionDef.field === 'autocomplete'">
        <ValidationProvider v-slot="{ errors }" rules="required">
          <u-autocomplete
            v-model="value"
            :items="conditionDef.autocompleteItems || remoteItems"
            :multiple="conditionDef.multiple"
            :placeholder="$vuntangle.$t('value')"
            :loading="remoteFetching"
            :error-messages="errors"
            :disabled="isObsolete"
          >
            <template v-if="type === 'APPLICATION_CATEGORY'" #selection="{ item }">
              {{ $vuntangle.$t(item.replace(/ /g, '_').toLowerCase()) }}
            </template>
            <template #item="{ item, attrs, on }">
              <v-list-item v-slot="{ active }" v-bind="attrs" dense class="px-2" v-on="on">
                <v-list-item-action v-if="conditionDef.multiple" class="my-0 mr-2">
                  <v-checkbox :input-value="active" dense :ripple="false" />
                </v-list-item-action>
                <v-list-item-content v-if="type === 'APPLICATION_CATEGORY'">
                  {{ $vuntangle.$t(item.replace(/ /g, '_').toLowerCase()) }}
                </v-list-item-content>
                <v-list-item-content v-else> {{ item.text || item }} </v-list-item-content>
              </v-list-item>
            </template>
            <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
          </u-autocomplete>
        </ValidationProvider>
      </template>

      <template v-if="conditionDef.field === 'boolean'">
        <v-radio-group v-model="value" row class="ma-0 pa-0" hide-details>
          <v-radio :label="$vuntangle.$t('yes')" :value="true"></v-radio>
          <v-radio :label="$vuntangle.$t('no')" :value="false"></v-radio>
        </v-radio-group>
      </template>
    </v-col>

    <!--
      SOURCE_PORT and DESTINATION_PORT conditions have an extra field `portProtocols`
      the below select field is used only for this specific case
    -->
    <v-col v-if="type === 'SOURCE_PORT' || type === 'DESTINATION_PORT'">
      <ValidationProvider v-slot="{ errors }" rules="required">
        <u-select
          v-model="portProtocols"
          :placeholder="$vuntangle.$t('select_protocol')"
          :items="portProtocolOptions"
          :menu-props="{ offsetY: true }"
          :error-messages="errors"
          multiple
          :disabled="isObsolete"
        >
          <template #item="{ item, attrs, on }">
            <v-list-item v-slot="{ active }" dense v-bind="attrs" class="px-2" v-on="on">
              <v-list-item-action class="my-0 mr-2">
                <v-checkbox :input-value="active" dense :ripple="false" />
              </v-list-item-action>
              <v-list-item-content> {{ item.text }} </v-list-item-content>
            </v-list-item>
          </template>
          <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
        </u-select>
      </ValidationProvider>
    </v-col>

    <!-- inferred checkbox flag
      this is used only for APPLICATION condition types
      and it is disabled for wan-rules having only INFERRED application types
      -->
    <v-col v-if="useInferred" cols="1">
      <v-checkbox
        v-model="inferred"
        label="Inferred"
        :disabled="ruleType === 'wan-rules' || isObsolete"
        class="my-0 py-0"
        hide-details
      />
    </v-col>
    <v-col v-if="type === 'LIMIT_RATE'">
      <ValidationProvider v-slot="{ errors }" rules="required">
        <u-select
          v-model="limitRateUnits"
          :placeholder="$vuntangle.$t('select_unit')"
          :items="limitRateUnitOptions"
          :error-messages="errors"
        >
          <template #selection="{ item }">{{ $vuntangle.$t(item.text) }}</template>
          <template #item="{ item }">{{ $vuntangle.$t(item.text) }}</template>
          <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
        </u-select>
      </ValidationProvider>
    </v-col>
    <v-col v-if="type === 'BURST_SIZE'">
      <ValidationProvider v-slot="{ errors }" rules="required">
        <u-select
          v-model="limitBurstUnits"
          :placeholder="$vuntangle.$t('select_unit')"
          :items="limitBurstUnitOptions"
          :error-messages="errors"
        >
          <template #selection="{ item }">{{ $vuntangle.$t(item.text) }}</template>
          <template #item="{ item }">{{ $vuntangle.$t(item.text) }}</template>
          <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
        </u-select>
      </ValidationProvider>
    </v-col>
  </v-row>
</template>
<script>
  import { VRow, VCol, VListItem, VListItemAction, VListItemContent, VCheckbox, VRadioGroup, VRadio } from 'vuetify/lib'
  import { ValidationProvider, extend } from 'vee-validate'

  import cloneDeep from 'lodash/cloneDeep'
  import UAutocomplete from '../../components/UAutocomplete'
  import { isOperatorOptions, portProtocolOptions, limitRateUnitOptions, limitBurstUnitOptions } from '../../constants'
  import { conditionDefs } from './data/conditionsDefinitions'
  import { ruleDefs } from './data/rulesDefinitions'
  import { addConditionHeaders } from './util/addConditionHeaders'

  export default {
    components: {
      VRow,
      VCol,
      VListItem,
      VListItemAction,
      VListItemContent,
      VCheckbox,
      VRadioGroup,
      VRadio,
      ValidationProvider,
      UAutocomplete,
    },
    props: {
      condition: { type: Object, default: () => {} },
      index: { type: Number, default: undefined },
      excludedConditions: { type: Array, default: null },
      allConditions: { type: Array, default: () => [] },
      // the settings applied on the box
      boxSettings: { type: Object, default: null },
      features: { type: Object, default: null },
    },
    data() {
      return {
        conditionCopy: undefined,
        portProtocolOptions,
        isOperatorOptions,
        limitRateUnitOptions,
        limitBurstUnitOptions,
      }
    },
    computed: {
      ruleType: ({ $attrs }) => $attrs.ruleType,
      remoteData: ({ $attrs }) => $attrs.remoteData,
      remoteFetching: ({ $attrs }) => $attrs.remoteFetching,
      isObsolete: ({ conditionCopy, $attrs }) =>
        conditionCopy.type &&
        !ruleDefs[$attrs.ruleType].conditions.includes(conditionCopy.type.replace(/_INFERRED/, '')),

      conditionTypes() {
        const extractedConditionTypes = this.allConditions.map(cond => cond.type?.replace(/_INFERRED/, ''))
        let types = ruleDefs[this.ruleType].conditions

        // filter out condition types above Layer 3 (for EOS)
        if (
          this.features.hasAboveLayer3Conditions === false &&
          ['filter', 'port-forward', 'nat', 'shaping'].includes(this.ruleType)
        ) {
          types = types.filter(type => conditionDefs[type].layer3)
        }

        if (this.excludedConditions && Array.isArray(this.excludedConditions)) {
          types = types.filter(el => !this.excludedConditions.includes(el))
        }

        // remove already selected conditions types
        types = types.filter(el => !extractedConditionTypes.includes(el))
        // include existing condition type if selected
        let conditionType = ''
        if (this.condition.type !== undefined && this.condition.type !== null) {
          conditionType = this.condition.type.replace(/_INFERRED/, '') // removing inferred to match rule list
        }

        return addConditionHeaders(ruleDefs[this.ruleType].headers, types, conditionType)
      },

      conditionDef() {
        const allCond = conditionDefs[this.conditionCopy.type?.replace(/_INFERRED/, '')] || {}
        if (
          this.features &&
          this.features.hasManagementIntf === false &&
          this.conditionCopy.type?.includes('INTERFACE_TYPE')
        ) {
          const mgmtIndex = allCond.selectItems.findIndex(i => i?.text === 'management')
          if (mgmtIndex !== -1) {
            delete allCond.selectItems[mgmtIndex]
          }
        }
        return allCond
      },

      useInferred: ({ conditionCopy }) => conditionCopy.type?.startsWith('APPLICATION'),

      valueValidationRules: ({ type, conditionDef }) => (type ? `required|${conditionDef.extraRules || ''}` : ''),

      inferred: {
        get: ({ conditionCopy }) => {
          return conditionCopy.type?.includes('_INFERRED')
        },
        set(value) {
          value
            ? (this.conditionCopy.type = this.conditionCopy.type + '_INFERRED')
            : (this.conditionCopy.type = this.conditionCopy.type?.replace(/_INFERRED/, ''))
        },
      },

      limitRateUnits: {
        get: ({ conditionCopy }) => {
          return conditionCopy?.rate_unit
        },
        set(value) {
          this.conditionCopy.rate_unit = value
        },
      },
      limitBurstUnits: {
        get: ({ conditionCopy }) => {
          return conditionCopy?.burst_unit
        },
        set(value) {
          this.conditionCopy.burst_unit = value
        },
      },
      /**
       * condition type computed based on it's name and inferred flag
       * it also set's some condition defaults upon new value
       */
      type: {
        get: ({ conditionCopy }) => {
          return conditionCopy.type?.includes('_INFERRED')
            ? conditionCopy.type.replace(/_INFERRED/, '')
            : conditionCopy.type
        },
        set(type) {
          // adds or removes the `_INFERRED` flag for applications based conditions
          if (type?.startsWith('APPLICATION')) {
            if (this.ruleType === 'wan-rules' || this.inferred) {
              this.conditionCopy.type = type + '_INFERRED'
            } else this.conditionCopy.type = type
          } else this.conditionCopy.type = type
          // reset the value to be blank
          this.conditionCopy.value = null
          // set condition defaults upon new type value
          if (this.conditionDef.defaults) {
            this.conditionCopy = { ...{ type: this.conditionCopy.type }, ...this.conditionDef.defaults }
          } else {
            this.conditionCopy = { type: this.conditionCopy.type, op: '==', value: '' }
          }
          // for SOURCE_PORT and DESTINATION_PORT it adds the extra `port_protocol` default
          if (type === 'SOURCE_PORT' || type === 'DESTINATION_PORT') {
            this.conditionCopy.port_protocol = []
          }
        },
      },

      /**
       * computed condition value needed to treat a special case for IP_PROTOCOL condition
       * settings.json accepts for IP_PROTOCOL a comma separated string with values
       * the autocomplete field returns an array of string values
       * so it has to do this get/set conversion for the condition value
       */
      value: {
        get: ({ type, conditionCopy }) =>
          conditionCopy.value && type === 'IP_PROTOCOL' ? (conditionCopy.value + '').split(',') : conditionCopy.value,
        set(value) {
          if (this.type === 'IP_PROTOCOL') this.conditionCopy.value = value.join() || null
          else this.conditionCopy.value = value
        },
      },

      /**
       * returns items for autocomplete/select fields conditions
       * retrieved from remote (host app)
       */
      remoteItems: ({ remoteData, type }) => {
        switch (type) {
          case 'APPLICATION_NAME':
            return remoteData.apps ? remoteData.apps.map(app => app.name) : undefined
          case 'APPLICATION_CATEGORY':
            return remoteData.apps ? remoteData.apps.map(app => app.category) : undefined
          case 'SOURCE_INTERFACE_ZONE':
          case 'DESTINATION_INTERFACE_ZONE':
          case 'CLIENT_INTERFACE_ZONE':
          case 'SERVER_INTERFACE_ZONE':
            return remoteData.zoneInterfaces ? remoteData.zoneInterfaces : undefined
          default:
            return undefined
        }
      },

      /**
       * sets the port protocol for DESTINATION or SOURCE port
       * for some reason the port protocol value can be a plain number or an array of numbers
       * so we have to switch between array or not depending of the single/multiple selection
       */
      portProtocols: {
        get: ({ conditionCopy }) =>
          !Array.isArray(conditionCopy?.port_protocol) ? [conditionCopy?.port_protocol] : conditionCopy?.port_protocol,
        set(value) {
          if (value.length === 1) this.conditionCopy.port_protocol = value[0]
          else this.conditionCopy.port_protocol = value
        },
      },
      // validation rules for the condition type field
      conditionTypeRules: ({ boxSettings }) => (boxSettings ? 'required|validate_service' : 'required'),
    },
    watch: {
      condition: {
        handler(newCond, oldCond) {
          if (newCond.type === 'BURST_SIZE') {
            this.$emit('add-limit-rate')
          }
          // TODO better handling of set/update conditionCopy
          if (JSON.stringify(newCond) === JSON.stringify(oldCond)) return
          this.conditionCopy = cloneDeep(newCond)
        },
        immediate: true,
      },

      /**
       * for some conditions data is retrieved from the host app
       * so an event is triggered to fetch that data
       */
      'conditionCopy.type': {
        handler(type) {
          if (!type) return
          if (
            !this.$attrs.remoteData.apps &&
            (type.startsWith('APPLICATION_NAME') ||
              type.startsWith('APPLICATION_CATEGORY') ||
              type.startsWith('APPLICATION_ID'))
          ) {
            this.$emit('get-remote-data', 'apps')
          }
          if (!this.$attrs.remoteData.zoneInterfaces && type.includes('_ZONE')) {
            this.$emit('get-remote-data', 'zone-interfaces')
          }
        },
        immediate: true,
      },
      conditionCopy: {
        handler(cond) {
          this.$emit('update:condition', cond)
        },
        deep: true,
      },
    },
    created() {
      extend('validate_service', this.validateService)
    },
    methods: {
      validateService(value) {
        // checks if the selected condition has the requied service enabled.
        // e.g: for selecting condition: "Application Category", service: "Application Control" should be enabled
        if (value.includes('APPLICATION') && !this.boxSettings.application_control.enabled) {
          return this.$t('service_x_is_disabled', [this.$t('application_control')])
        }
        if (value === 'GEOIP' && !this.boxSettings.geoip.enabled) {
          return this.$t('service_x_is_disabled', [this.$t('geoip')])
        }
        return true
      },
    },
  }
</script>
