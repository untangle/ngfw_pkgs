import chartOptions from '../../../plugins/chartOptions'
import columns from '../../../plugins/columns'

export default {
  inject: ['$boxSettings', '$applianceUid', '$timeRange', '$pagination'],

  props: {
    report: { type: Object, default: undefined, required: true },
    customConditions: { type: Array, default: undefined },
    withPieGrid: { type: Boolean, default: false },
  },

  data() {
    return {
      fetching: false,
      data: [],
      options: chartOptions.baseChartOptions,
      total: undefined,
    }
  },

  computed: {
    /**
     * Returns the timerange from injected $timeRange
     * @param {Object} vm
     * @param {Object} vm.$timeRange - the timerange period
     * @returns {Object}
     */
    timeRange: ({ $timeRange }) => $timeRange(),

    /**
     * Returns the pagination from injected $pagination
     * @param {Object} vm
     * @param {Object} vm.$pagination - the pagination pageNumber & pageSize
     * @returns {Object}
     */
    pagination: ({ $pagination }) => $pagination(),

    /**
     * Returns the columns definitions for a grid
     * @param {Object} vm
     * @param {Report} vm.report - the report conf
     * @param {Object} vm.$boxSettings - the appliance box settings
     * @returns {Array<Object>}
     */
    columnDefs: ({ report, $boxSettings }) =>
      report.columns ? columns.buildColumnDefs(report.columns, $boxSettings) : [],

    /**
     * Returns an id -> map between the interface id and it's name
     * @param {Object} vm
     * @param {Object} vm.$boxSettings - the appliance box settings
     * @returns {Object}
     */
    interfaceIdNameMap: ({ $boxSettings }) =>
      $boxSettings?.network?.interfaces?.reduce((res, intf) => {
        return { ...res, [intf.interfaceId]: intf.name }
      }, {}),

    /**
     * Returns the appliance UID used for reports
     * @param {Object} vm
     * @param {Function} vm.$applianceUid - appliance UID
     * @returns {String}
     */
    applianceUid: ({ $applianceUid }) => $applianceUid(),
  },

  watch: {
    // re-fetch data upon time range update
    'timeRange.period'() {
      // reset page to 1 upon timerange change
      this.pagination.pageNumber = 1
      this.fetchData()
    },
    // re-fetch data upon custom conditions update
    customConditions() {
      this.fetchData()
    },

    // refetch data when appliance UID changes
    applianceUid() {
      this.fetchData()
    },

    report: {
      handler() {
        this.fetchData()
      },
      immediate: true,
    },
  },

  methods: {
    onRefresh() {
      this.pagination.pageNumber = 1
      this.fetchData()
    },

    /**
     * Returns the report data after the response received from the host app
     */
    fetchData() {
      const now = Date.now()

      // compute start/end timestamps based on timezone offset
      const start = now + this.timeRange.period[0] * 60 * 60 * 1000

      const end = now + this.timeRange.period[1] * 60 * 60 * 1000

      let conditions = [
        {
          column: 'time_stamp',
          operator: 'GT',
          value: start,
        },
        {
          column: 'time_stamp',
          operator: 'LT',
          value: end,
        },
      ]

      // attach also any costom conditions if passed
      if (this.customConditions) conditions = [...conditions, ...this.customConditions]

      // show loading and fetch data from host
      this.fetching = true
      this.$emit('fetch-data', {
        query: {
          ...this.report.query,
          userConditions: conditions,
          serverPagination: this.pagination,
        },
        applianceUid: this.applianceUid,
        resolve: data => {
          this.fetching = false
          this.data = data
          // for the charts reports, build the normalized data used for charting
          if (this.report.rendering) {
            this.options = chartOptions.getChartOptions(this.report, data, this.interfaceIdNameMap)
          }
        },
      })
    },
  },
}
