<template>
  <div v-if="settingsCopy" class="py-2">
    <ValidationObserver ref="obs">
      <v-row align="center">
        <v-col>
          <ValidationProvider v-slot="{ errors }" rules="required">
            <u-text-field
              v-model="settingsCopy.description"
              :label="$vuntangle.$t('description')"
              :error-messages="errors"
            >
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
        <v-col cols="auto">
          <v-checkbox v-model="settingsCopy.enabled" :label="$vuntangle.$t('enabled')" hide-details class="ma-0 pa-0" />
        </v-col>
      </v-row>
      <v-row class="align-center">
        <v-col cols="6">
          <ValidationProvider
            v-slot="{ errors }"
            :rules="{
              required: true,
              ip: true,
            }"
          >
            <u-text-field v-model="networkIp" :label="$vuntangle.$t('network')" :error-messages="errors">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
        <v-col cols="6">
          <ValidationProvider v-slot="{ errors }" rules="required">
            <ipv-4-prefix-autocomplete v-model="networkPrefix" :errors="errors" />
          </ValidationProvider>
        </v-col>
      </v-row>

      <div v-if="netInfo && !validNetwork" class="my-2">
        <v-icon color="error" class="mr-2">mdi-alert</v-icon>
        <span v-html="$vuntangle.$t('invalid_network_route', [netInfo.networkAddress])" />
      </div>

      <v-row>
        <v-col cols="12">
          <ValidationProvider v-slot="{ errors }" rules="required|ip">
            <u-text-field v-model="settingsCopy.nextHop" :label="$vuntangle.$t('next_hop')" :error-messages="errors">
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
      </v-row>
      <v-row>
        <v-col cols="12">
          <ValidationProvider
            v-slot="{ errors }"
            :rules="{ required: !!interfaces && features.hasStaticRouteInterfaceRequired }"
          >
            <u-select
              v-model="settingsCopy.interfaceId"
              :label="$vuntangle.$t('interface')"
              :error-messages="errors"
              :items="interfaces"
              item-value="interfaceId"
              item-text="name"
              clearable
            >
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-select>
          </ValidationProvider>
        </v-col>
      </v-row>
      <v-row>
        <v-col cols="12">
          <ValidationProvider v-slot="{ errors }" :rules="{ check_static_route_metric: true }">
            <u-text-field
              v-model.number="settingsCopy.metric"
              :label="$vuntangle.$t('metric')"
              :error-messages="errors"
            >
              <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
            </u-text-field>
          </ValidationProvider>
        </v-col>
      </v-row>

      <div v-if="conflictingRoutes" class="my-2">
        <v-icon color="error" class="mr-2">mdi-alert</v-icon>
        {{ $vuntangle.$t('static_route_conflict') }}
      </div>
    </ValidationObserver>
  </div>
</template>
<script>
  // import vuetify components
  import { VRow, VCol, VIcon } from 'vuetify/lib'
  import { ValidationObserver, ValidationProvider } from 'vee-validate'

  import cloneDeep from 'lodash/cloneDeep'
  import Ipv4PrefixAutocomplete from '../../components/Ipv4PrefixAutocomplete'
  import net from '../../plugins/net'
  import { staticRouteDefaults as defaults } from './defaults'

  export default {
    components: { VRow, VCol, VIcon, ValidationObserver, ValidationProvider, Ipv4PrefixAutocomplete },
    defaults,
    props: {
      // the index of the route being edited
      index: { type: Number, default: undefined },
      // the route entry settings
      settings: { type: Object, default: () => undefined },
      // box interfaces if applicable
      interfaces: { type: Array, default: null },
      // box features if any
      features: { type: Object, default: () => ({}) },
      // all the routes list used to check against conflicts
      routes: { type: Array, default: () => [] },
    },

    data() {
      return {
        settingsCopy: undefined,
      }
    },

    computed: {
      /**
       * Checks if edited route conflicts with an existing route.
       * Is conflicting if the below are true:
       * - route networks are the same (ip&prefix)
       * - route nextHops are the same
       * @returns {Boolean} - true if conflict exists
       */
      conflictingRoutes: ({ routes, index, settingsCopy, networkIp, networkPrefix }) => {
        const allRoutes = [...routes]
        const idx = parseInt(index)
        // drop the edited route if exists
        if (!isNaN(index) && allRoutes[idx]) allRoutes.splice(idx, 1)

        return allRoutes.some(
          route => `${networkIp}/${networkPrefix}` === route.network && settingsCopy.nextHop === route.nextHop,
        )
      },
      // used to compute network from IP and prefix
      networkIp: {
        get: ({ settingsCopy }) => settingsCopy.network?.split('/')[0] || '',
        set(ip) {
          this.settingsCopy.network = `${ip}/${this.networkPrefix}`
        },
      },
      // computes prefix based on entry
      networkPrefix: {
        get: ({ settingsCopy }) => parseInt(settingsCopy.network?.split('/')[1]) || 24,
        set(prefix) {
          this.settingsCopy.network = `${this.networkIp}/${prefix}`
        },
      },
      // returns info for a specific ip/prefix
      netInfo() {
        return net.info(this.networkIp, this.networkPrefix)
      },
      // returns if network is valid
      validNetwork() {
        return this.netInfo?.networkAddress === this.networkIp
      },
    },

    watch: {
      settings: {
        handler(settings) {
          this.settingsCopy = cloneDeep(settings || this.$options.defaults)
        },
        immediate: true,
      },
      'settingsCopy.network'(newValue) {
        const [ip, prefix] = newValue.split('/')
        this.settingsCopy.network = `${ip}/${prefix || this.networkPrefix}`
      },
    },

    methods: {
      // Dialog main action emitting updated settings
      async action() {
        const isValid = await this.$refs.obs.validate()
        if (!isValid || !this.validNetwork || this.conflictingRoutes) return

        this.$emit('update', this.settingsCopy, this.index)
        this.$emit('close')
      },
    },
  }
</script>
