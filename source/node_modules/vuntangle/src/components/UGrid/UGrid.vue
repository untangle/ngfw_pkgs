<template>
  <v-card
    :outlined="!noBorder"
    flat
    :class="classes"
    style="position: relative; overflow: hidden"
    @mouseenter="toolbarFloat = true"
    @mouseleave="toolbarFloat = false"
  >
    <toolbar
      v-if="toolbarPosition === 'top'"
      :auto-filter="autoFilter"
      :quick-filter-text.sync="quickFilterText"
      :toolbar="toolbarPosition"
      :filtered-number="filteredNumber"
      :filtered-total="filteredTotal"
      :selected-text="selectedText"
      :selected-number="selectedNumber"
      :enable-refresh="enableRefresh"
      :enable-export-csv="enableExportCsv"
      :enable-quick-filter="enableQuickFilter"
      :enable-condensed-toggle="enableCondensedToggle"
      :condensed-grid.sync="condensedGrid"
      :show-clear="isColumnFiltered"
      :show-multiple-selection-text="selectionType === 'multiAction'"
      :fetching="fetching"
      @export-csv="onExportCsv"
      @refresh="onRefresh"
      @clear-all-filters="onClearAllFilters"
    >
      <template #toolbarActions>
        <slot name="toolbarActions"></slot>
      </template>
    </toolbar>
    <!-- UI-772 added an extra div and used `flex-grow` instead of `fill-height` to fix the Safari issue -->
    <div class="d-flex flex-column flex-grow-1">
      <ag-grid-vue
        :id="id"
        class="u-grid flex-grow-1"
        :framework-components="agFrameworkComponents"
        loading-overlay-component="customLoadingOverlay"
        no-rows-overlay-component="customNoRowsOverlay"
        :no-rows-overlay-component-params="noRowOverlayParams"
        :grid-options="gridOptions"
        :default-col-def="defaultColDef"
        :row-height="28"
        :column-defs="agColumnDefs"
        :row-data="computedRowData"
        :quick-filter-text="setQuickFilterText"
        :row-selection="rowSelection"
        :navigate-to-next-cell="keyRowNav"
        :popup-parent="popupParent"
        :modules="modules"
        @selection-changed="onSelectionChanged"
        @filter-changed="setFilterText"
        @row-data-changed="onRowDataChanged"
        @row-data-updated="setFilterText"
        @column-resized="onColumnResized"
        @grid-columns-changed="onGridColumnsChanged"
        v-on="$listeners"
      />
      <pagination :fetching="fetching" v-on="$listeners" />
    </div>
    <v-slide-y-reverse-transition>
      <toolbar
        v-if="toolbarPosition === 'bottom' || (toolbarPosition === 'float' && toolbarFloat)"
        :auto-filter="autoFilter"
        :quick-filter-text.sync="quickFilterText"
        :toolbar="toolbarPosition"
        :filtered-number="filteredNumber"
        :filtered-total="filteredTotal"
        :selected-text="selectedText"
        :selected-number="selectedNumber"
        :enable-refresh="enableRefresh"
        :enable-export-csv="enableExportCsv"
        :enable-quick-filter="enableQuickFilter"
        :enable-condensed-toggle="enableCondensedToggle"
        :condensed-grid.sync="condensedGrid"
        :show-multiple-selection-text="selectionType === 'multiAction'"
        :fetching="fetching"
        @export-csv="onExportCsv"
        @refresh="onRefresh"
      />
    </v-slide-y-reverse-transition>
  </v-card>
</template>
<script>
  import cloneDeep from 'lodash/cloneDeep'

  // import vuetify components
  import { VSlideYReverseTransition } from 'vuetify/lib'

  import AgGridVue from '../AgGridVue'
  import util from '../../plugins/util'
  import props from './props'

  // import ag-grid
  // import custom framework components
  import LoadingOverlay from './components/LoadingOverlay'
  import NoRowsOverlay from './components/NoRowsOverlay'
  import Pagination from './components/Pagination.vue'

  // import custom filters
  import DefaultFilter from './filters/DefaultFilter'
  import DefaultFloatingFilter from './filters/DefaultFloatingFilter.vue'
  import BooleanFilter from './filters/BooleanFilter'
  import CollectionFilter from './filters/CollectionFilter'
  import CountryFilter from './filters/CountryFilter'
  import CountryFloatingFilter from './filters/CountryFloatingFilter'
  import RangeFilter from './filters/RangeFilter'

  // import renderers
  import ActionButton from './renderers/ActionButton.vue'
  import CheckboxRenderer from './renderers/CheckboxRenderer.vue'
  import CellWithTooltip from './renderers/CellWithTooltip.vue'
  import RowActions from './renderers/RowActions.vue'
  import Ordering from './renderers/Ordering.vue'

  // import toolbar
  import Toolbar from './components/Toolbar'

  // import features
  import useValueFormatter from './features/useValueFormatter'
  import State from './features/State'

  export default {
    components: {
      AgGridVue,
      Toolbar,
      Pagination,
      VSlideYReverseTransition,
    },

    props: {
      ...props,

      enableQuickFilter: { type: Boolean, default: true },

      showMultipleSelectionText: { type: Boolean, default: false },

      autoFilter: { type: Boolean, default: true },

      // other props
      fetching: { type: Boolean, default: false }, // boolean showing progress while fetching data, the fetch is initiated in parent

      /**
       * floating row actions shown at the right
       * an action must be defined like:
       * {
       *    icon: 'mdi-some-icon', // required
       *    handler: ({ data, node, index}) => {}, // required - method handling the click action
       *    tooltip: 'some localized tooltip', // optional - tooltip to display on museover
       * }
       */
      rowActions: { type: Array, default: () => undefined },
      /**
       * weather the row actions should be floating (default)
       * or always visible for each row (non floating)
       */
      rowActionsFloating: { type: Boolean, default: true },

      /**
       * weather to use condensed/expand rows for columns with `autoHeight` feature
       * for appliance/clients this must be false even if those do have `autoHeight`
       */
      useCondensedToggle: { type: Boolean, default: true },
    },

    data() {
      return {
        // the components used in the grid
        agFrameworkComponents: {
          customLoadingOverlay: LoadingOverlay,
          customNoRowsOverlay: NoRowsOverlay,
          ActionButton,
          CellWithTooltip,
          Ordering,
          CheckboxRenderer,
          defaultFilter: DefaultFilter,
          booleanFilter: BooleanFilter,
          collectionFilter: CollectionFilter,
          rangeFilter: RangeFilter,
          countryFilter: CountryFilter,
          countryFloatingFilter: CountryFloatingFilter,
          defaultFloatingFilter: DefaultFloatingFilter,
          RowActions,
          ...this.frameworkComponents,
        },
        agColumnDefs: [],
        rowSelection: null,
        selectedNumber: 0,
        filteredNumber: 0,
        filteredTotal: 0,

        // global grid options
        gridOptions: {
          suppressCellSelection: true,
          suppressColumnMoveAnimation: true,
          animateRows: false,
          rowBuffer: 50,
          enableCellTextSelection: true,
          rowMultiSelectWithClick: true,
          postProcessPopup: this.alignPopup,
          floatingFiltersHeight: 50,
          ...(this.rowNodeId ? { getRowNodeId: data => data[this.rowNodeId] } : {}),
          ...this.customGridOptions,
        },

        // column props applied to all columns by default
        defaultColDef: {
          sortable: true,
          resizable: true,
          suppressMenu: false,
          filter: 'defaultFilter', // equivalent by default as `agTextColumnFilter`
          floatingFilterComponent: 'defaultFloatingFilter',
          floatingFilter: false,
          floatingFilterComponentParams: {
            suppressFilterButton: true,
          },
          sortingOrder: ['asc', 'desc'],
          minWidth: 150,
          flex: 1,
          filterParams: {
            enableRefresh: this.enableRefresh,
            enableExportCsv: this.enableExportCsv,
            showMultipleSelectionText: this.showMultipleSelectionText,
            // update toolbar position
            setToolbar: position => (this.toolbarPosition = position),
            pinColumn: (colId, position) => {
              this.columnApi.setColumnPinned(colId, position)
            },
            refresh: () => this.onRefresh(),
            exportCsv: () => this.onExportCsv(),
            resetColumns: () => this.onResetColumns(),
          },

          // change ag-grids default sort to be case insensitive
          comparator: (valueA, valueB, accentedCompare) => {
            const a = valueA || ''
            const b = valueB || ''
            return util.sortAlphaNumerically(a, b, this.$vuntangle.locale, accentedCompare)
          },

          /**
           * By default use a columns 'valueFormatter' for filtering when available.  This is used so the filtering
           * will match the data on screen.  This may be overridden for advanced filtering like checking
           * greater than or less than with numerical values.
           */
          filterValueGetter: params => useValueFormatter(params),
          ...this.customDefaultColOptions,
        },

        // the actual data shown in the grid
        toolbarPosition: this.toolbar,
        toolbarFloat: false, // show/hide floating toolbar on mouse enter/leave
        selectedText: null,
        quickFilterText: '',
        quickFilterChanged: false,
        setQuickFilterText: null,
        popupParent: document.querySelector('body'),
        noRowOverlayParams: {
          noDataMessage: this.noDataMessage,
        },
        // flag storing the condensed state of the grid, by default being condensed
        condensedGrid: true,
        // flag telling if any column filter is applied to the grid
        isColumnFiltered: false,
      }
    },
    computed: {
      // all classes needed for root grid container
      classes() {
        let classes = this.$vuntangle.theme === 'dark' ? 'ag-theme-alpine-dark' : 'ag-theme-alpine'
        classes += ' d-flex flex-column align-stretch flex-grow-1'
        return classes
      },
      isRemoteGrid() {
        return this.gridOptions.rowModelType === 'infinite'
      },
      // do not try to display data until fetching is done
      computedRowData() {
        return this.fetching ? [] : this.rowData
      },

      /**
       * Passed to the toolbar so it shows the condensed toggle button only for grids
       * having at least one colum definition with `autoHeight` set and true
       */
      enableCondensedToggle: ({ useCondensedToggle, columnDefs }) => {
        return useCondensedToggle && columnDefs?.some(col => col.autoHeight)
      },
    },
    watch: {
      noDataMessage(value) {
        this.noRowOverlayParams.noDataMessage = value
      },
      // deselect all rows if parent selectedRows turns into empty array
      selection(value) {
        if (value.length === 0 && this.gridApi.getSelectedRows().length > 0) {
          this.gridApi.deselectAll()
        }
      },

      // whenever row data changes, filter the selection array
      // so any record not in data gets filtered out of selection as well
      rowData(data) {
        // not sure how to do this if rowNodeId doesn't exist
        if (this.rowNodeId && !this.fetching) {
          const selection = this.selection.filter(
            selectedItem =>
              !!data.find(dataItem => dataItem[this.rowNodeId] === (selectedItem[this.rowNodeId] ?? selectedItem)),
          )
          this.$emit('update:selection', selection)
        }
      },

      /**
       * Intercept the quick filtering to show a loader if non-automatic filtering is being used, this would be
       * used for larger datasets where automatic filtering temporarily freezes the browser.
       */
      quickFilterText(newQuickFilterText) {
        if (this.autoFilter) {
          this.setQuickFilterText = newQuickFilterText
        } else {
          this.quickFilterChanged = true
          this.gridApi.showLoadingOverlay()

          // timeout is needed or the overlay is never shown
          setTimeout(() => (this.setQuickFilterText = newQuickFilterText), 300)
        }
      },

      // watch fetching to trigger grid loading overlay
      fetching: {
        immediate: true,
        handler(value) {
          if (this.gridApi) {
            value ? this.gridApi.showLoadingOverlay() : this.gridApi.hideOverlay()
          }
        },
      },
      columnDefs: {
        deep: true,
        handler(newColumnDefs) {
          // make sure grid was found
          if (!this.gridApi) {
            return
          }

          // set new headers only, so to not change any other column state
          const columnDefs = this.gridApi.getColumnDefs()
          columnDefs.forEach((colDef, i) => {
            if (newColumnDefs[i]?.headerName) {
              colDef.headerName = newColumnDefs[i].headerName

              // column size will change if flex is not set to 0
              if (colDef.width) {
                colDef.flex = 0
              }
            }
          })

          // update the column definitions, refresh data in case locale changed
          this.agColumnDefs = columnDefs
          this.gridApi.redrawRows()
        },
      },

      /**
       * Watch for prop event to auto resize the columns.  Used in widgets.
       *
       * @param {bool} resizeColumns
       *
       * @return {void}
       */
      resizeColumns(resizeColumns) {
        if (resizeColumns) {
          this.gridApi.sizeColumnsToFit()
          // set the prop back in the parent so it can be resized again
          this.$emit('update:resizeColumns', false)
        }
      },

      // used if dynamically changing the selection type, like in appliances list
      selectionType() {
        this.setColumnDefs()
      },

      // when toggling the condensed state of the grid, update grid columndefs
      condensedGrid() {
        this.setCondensedGrid()
      },

      /**
       * CD-3660 upon locale change, column defs have to be
       * updated for grids having first column a selection column
       * otherwise the column names are shifted left 1 place
       */
      '$vuntangle.locale'() {
        this.setColumnDefs()
      },
    },

    beforeMount() {
      this.setColumnDefs()
    },

    mounted() {
      this.gridApi = this.gridOptions.api
      this.columnApi = this.gridOptions.columnApi
      this.$emit('gridApiReady', this.gridApi)

      // state management, do not use if using the webpack dev server
      if (this.$vuntangle.env !== 'devServer') {
        this.state = new State(this.id, this.gridApi, this.columnApi)
        this.state.load()
      }

      // show loader, the initial 'fetching' watch may not fire if the grid is not loaded yet
      if (this.fetching) {
        this.gridApi.showLoadingOverlay()
      }
    },

    updated() {
      if (this.fetching) {
        this.gridApi.showLoadingOverlay()
      } else if (this.gridApi.getDisplayedRowCount()) {
        this.gridApi.hideOverlay()
      } else {
        this.gridApi.showNoRowsOverlay()
      }
    },

    methods: {
      /**
       * Fire when the row data changes. This is the only place to hook into after the row-data prop
       * has been updated in the grid, changing the prop is an asynchronous event.  Therefore,
       * after new data is possibly added, run the 'syncSelection' check to see if any new
       * rows need to be selected.
       */
      onRowDataChanged() {
        this.syncSelection()
        this.setFilterText()
        this.quickFilterText = ''
        this.selectedNumber = this.gridApi.getSelectedRows().length
      },

      onSelectionChanged() {
        this.$emit('update:selection', this.gridApi.getSelectedRows())

        this.selectedNumber = this.gridApi.getSelectedRows().length
      },

      /**
       * Resets column heights upon column resize, needed to accommodate content for autoHeight columns
       * @param {Object} context
       * @param {Array} context.columns - columns affected by the resize event
       * @param {Boolean} context.finished - weather the resize action ended so is not firing endlessly
       * @param {Object} context.api - the grid api
       */
      onColumnResized({ columns, finished, api, useCondensedToggle }) {
        // call reset only when resize finished and any of the affected columns has autoHeight prop
        if (finished && useCondensedToggle && columns.some(col => col.colDef.autoHeight)) {
          api.resetRowHeights()
        }
      },

      /**
       * Resets column heights upon condensed state toggle
       * @param {Object} context
       * @param {Object} context.api - the grid api
       */
      onGridColumnsChanged({ api }) {
        api.resetRowHeights()
      },

      // sets the filtered string
      setFilterText() {
        if (this.isRemoteGrid) return

        this.isColumnFiltered = this.gridApi.isColumnFilterPresent()

        this.filteredTotal = Object.keys(this.gridApi.getModel().nodeManager.allNodesMap).length
        this.filteredNumber = this.gridApi.getDisplayedRowCount()

        if (this.quickFilterChanged) {
          this.gridApi.hideOverlay()
          this.quickFilterChanged = false
        }
      },

      // enables up/down key row navigation by overriding default cell keyboard nav
      keyRowNav(params) {
        const suggestedNextCell = params.nextCellPosition
        this.gridApi.forEachNode(node => {
          if (node.rowIndex === suggestedNextCell.rowIndex) {
            node.setSelected(true)
          }
        })
        return suggestedNextCell
      },

      /**
       * Augments the grid with
       * - checkbox/radio selection column (pinned left)
       * - and/or row actions column (pinned right)
       * This may be called multiple times during a grid lifetime so we need to make sure that
       * this columns are not duplicated (added multiple times)
       */
      setColumnDefs() {
        this.agColumnDefs = cloneDeep(this.columnDefs) // to avoid mutation issue

        // if grid is condensed, set `autoHeight` & `wordWrap` columns props as false
        // on columns which originally have those props set on them
        if (this.condensedGrid && this.useCondensedToggle) {
          this.agColumnDefs.forEach(colDef => {
            if (colDef.autoHeight) colDef.autoHeight = false
            if (colDef.wrapText) colDef.wrapText = false
          })
        }

        this.disableSortIfDraggable()
        const colIds = this.agColumnDefs.map(col => col.colId) // keep a map of colIds to check against

        /**
         * add order column based on `customOrdering` prop
         * the column is named Order and allows for drag/drop
         */
        if (this.customOrdering) {
          this.agColumnDefs.unshift({
            headerName: this.$vuntangle.$t('order'),
            flex: 0,
            colId: 'col-ordering',
            maxWidth: 80,
            rowDrag: true,
            pinned: 'left',
            lockPosition: 'left',
            lockPinned: true,
            cellRenderer: 'Ordering',
            valueGetter: params => params.node.rowIndex + 1,
          })
          // update so all columns have the following props
          this.defaultColDef.sortable = false
          this.defaultColDef.filter = false
          this.defaultColDef.suppressMenu = true
          // update gridOptions for behavior on row dragging
          this.gridOptions.suppressRowClickSelection = true
          this.gridOptions.rowDragManaged = true
          this.gridOptions.rowClass = 'ag-unselectable'
        }
        // used to keep grids from having a white space to the side when columns are resized
        this.gridOptions.rowClass = this.gridOptions.rowClass
          ? `${this.gridOptions.rowClass} ag-center-cols-container`
          : 'ag-center-cols-container'
        /**
         * adds floating/non-floating row actions column based on `rowActions`/`rowActionsFloating` props
         * `col-actions` class needed only for floating buttons
         */
        if (this.rowActions && !colIds.includes('col-actions')) {
          this.agColumnDefs.push({
            colId: 'col-actions',
            headerName: !this.rowActionsFloating ? this.$vuntangle.$t('actions') : undefined,
            pinned: 'right',
            lockPosition: true,
            lockPinned: true,
            // maxWidth is needed so the right pinned panel is not hidden by ag-grid
            maxWidth: this.rowActionsFloating ? 1 : this.rowActions.length === 1 ? 60 : this.rowActions.length * 40,
            resizable: false,
            filter: false,
            sortable: false,
            suppressMenu: true,
            headerClass: this.rowActionsFloating ? 'col-actions' : '',
            cellClass: this.rowActionsFloating ? 'col-actions' : '',
            cellRenderer: 'RowActions',
            cellRendererParams: () => ({ actions: this.rowActions }),
          })
        }

        /**
         * set the ag-grid `rowSelection` and add checkbox/radio selection column if it's the case,
         * based on UGrid `selectionType` prop having following possible values:
         * - `single`       - single selection without radio/checkbox column, selects on row click
         * - `singleAction` - single selection with radio button column selector
         * - `multiAction`  - multiple selection with checkbox column selector
         * - none           - no selection column
         */

        // first set the ag-grid `rowSelection` prop; ag-grid acceptable values are `single` and `multiple`
        if (this.selectionType?.includes('single')) this.rowSelection = 'single'
        else if (this.selectionType === 'multiAction') this.rowSelection = 'multiple'
        else return

        // add the selection column only when having `singleAction` or `multiAction` and is not yet attached to the grid
        if (!['singleAction', 'multiAction'].includes(this.selectionType) || colIds.includes('sel-column')) return

        this.agColumnDefs.unshift({
          colId: 'sel-column',
          resizable: false,
          filter: false,
          sortable: false,
          suppressMenu: true,
          suppressSizeToFit: true,
          pinned: 'left',
          lockPosition: true,
          lockPinned: true,
          checkboxSelection: true,
          headerCheckboxSelection: this.selectionType === 'multiAction',
          headerCheckboxSelectionFilteredOnly: true,
          minWidth: 50,
          width: 50,
          cellStyle: { padding: 0, justifyContent: 'center', display: 'flex' },
          cellClass: this.selectionType === 'singleAction' ? 'ag-radio' : '',
        })
      },

      /**
       * Disables sort on all columns
       * if row reordering is enabled for any column
       */
      disableSortIfDraggable() {
        // check if re ordering is enabled for any column
        if (this.agColumnDefs.some(({ rowDrag }) => rowDrag)) {
          // disable sort on all columns
          this.agColumnDefs.forEach(col => (col.sortable = false))
        }
      },

      onRefresh() {
        this.$emit('refresh')

        // if the rowData is refreshed, make sure the selection is also updated
        this.$emit('update:selection', [])
      },

      onExportCsv() {
        // only get columns that are visible and do not have checkbox selection
        const columnKeys = []

        this.columnApi.getAllGridColumns().forEach(column => {
          if (column.visible && !column.getColDef().checkboxSelection && column.colId !== 'sel-column') {
            columnKeys.push(column.colId)
          }
        })

        this.gridApi.exportDataAsCsv({
          fileName: `export-${this.id}.csv`,
          columnKeys,
          processCellCallback: useValueFormatter,
        })
      },

      onResetColumns() {
        // important to be called first
        this.gridApi.setFilterModel(null)

        // reset
        this.gridApi.setColumnDefs([])
        this.setColumnDefs()

        // in case of auto height columns reset heights
        if (this.agColumnDefs.some(def => def.autoHeight)) this.gridApi.resetRowHeights()
      },

      /**
       * Programmatically passes the selection to grid,
       * This method is called whenever row data is modified
       */
      syncSelection() {
        this.selection.forEach(data => {
          /*
           * initially the 'selection' prop is just ids, but gets synced to be the whole row object
           * later on by 'selection-changed' event.  So check for an object with the id prop,
           * or if not then assume 'data' is just the id
           */
          const nodeId = this.rowNodeId && data[this.rowNodeId] ? data[this.rowNodeId] : data
          const rowNode = this.gridApi.getRowNode(nodeId)
          if (rowNode) {
            rowNode.setSelected(true)
          }
        })
      },

      /**
       * Makes the column menu visible when it falls outside the scrolling window
       * (grid columns at the bottom/right of the page, without enough space to show it as default)
       * The popup will be aligned with the bottom of the window
       */
      alignPopup(params) {
        const popup = params.ePopup
        // timeout needed because of the computations made for menu items
        setTimeout(() => {
          if (popup.offsetTop + popup.offsetHeight > window.innerHeight + window.scrollY) {
            popup.style.top = `${window.innerHeight + window.scrollY - popup.offsetHeight}px`
          }
        }, 10)
      },

      /**
       * Toggles the condensed/not condensed display of the grid
       * using the columns from grid api (not the original columnDefs)
       */
      setCondensedGrid() {
        if (!this.useCondensedToggle) return

        const columnDefs = this.gridApi.getColumnDefs()

        columnDefs.forEach(colDef => {
          if ('autoHeight' in colDef) colDef.autoHeight = !colDef.autoHeight
          if ('wrapText' in colDef) colDef.wrapText = !colDef.wrapText
        })
        this.agColumnDefs = columnDefs
      },

      /**
       * Clears global & all existing column filters
       */
      onClearAllFilters() {
        this.gridApi.setFilterModel(null)
        this.quickFilterText = ''
      },
    },
  }
</script>
<!--used to keep grids from having a white space to the side when columns are resized -->
<style>
  .ag-center-cols-container {
    min-width: 100% !important;
  }
</style>
