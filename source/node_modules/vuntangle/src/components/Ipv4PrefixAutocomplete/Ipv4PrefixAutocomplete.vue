<!--
Autocomplete component used for all IPv4 prefixes editing
When validating the errors are passed via :errors prop
-->
<template>
  <u-autocomplete
    :value="value"
    :items="prefixes"
    :label="labelTkey || $vuntangle.$t('prefix_netmask')"
    item-text="value"
    :disabled="disabled"
    prefix="/"
    :suffix="selectedSubnet"
    :error-messages="errors"
    @input="updateValue"
    @change="updateValue"
    @blur="$emit('blur')"
    @focus="$emit('focus')"
  >
    <template #selection="{ item }">
      {{ item.value }}
    </template>
    <template #item="{ item }">
      <v-list-item-content>
        <v-list-item-title class="d-flex">
          <span>/ {{ item.value }}</span>
          <v-spacer />
          <span v-if="item.text" class="grey--text text--darker-2"> {{ item.text }}</span>
        </v-list-item-title>
      </v-list-item-content>
    </template>
    <template v-if="errors.length" #append><u-errors-tooltip :errors="errors" /></template>
  </u-autocomplete>
</template>
<script>
  // import vuetify components
  import { VListItemContent, VListItemTitle, VSpacer } from 'vuetify/lib'

  import UAutocomplete from '../UAutocomplete'
  import UErrorsTooltip from '../UErrorsTooltip'

  export default {
    components: { VListItemContent, VListItemTitle, VSpacer, UAutocomplete, UErrorsTooltip },
    props: {
      required: { type: Boolean, default: true },
      labelTkey: { type: String, default: undefined },
      value: { type: [Number, String], default: undefined },
      defaultValue: { type: [Number, String], default: undefined },
      min: { type: Number, default: 0 },
      disabled: { type: Boolean, default: false },
      errors: { type: Array, default: () => [] },
    },
    computed: {
      prefixes() {
        const options = [
          { value: 0, text: '0.0.0.0' },
          { value: 1, text: '128.0.0.0' },
          { value: 2, text: '192.0.0.0' },
          { value: 3, text: '224.0.0.0' },
          { value: 4, text: '240.0.0.0' },
          { value: 5, text: '248.0.0.0' },
          { value: 6, text: '252.0.0.0' },
          { value: 7, text: '254.0.0.0' },
          { value: 8, text: '255.0.0.0' },
          { value: 9, text: '255.128.0.0' },
          { value: 10, text: '255.192.0.0' },
          { value: 11, text: '255.224.0.0' },
          { value: 12, text: '255.240.0.0' },
          { value: 13, text: '255.248.0.0' },
          { value: 14, text: '255.252.0.0' },
          { value: 15, text: '255.254.0.0' },
          { value: 16, text: '255.255.0.0' },
          { value: 17, text: '255.255.128.0' },
          { value: 18, text: '255.255.192.0' },
          { value: 19, text: '255.255.224.0' },
          { value: 20, text: '255.255.240.0' },
          { value: 21, text: '255.255.248.0' },
          { value: 22, text: '255.255.252.0' },
          { value: 23, text: '255.255.254.0' },
          { value: 24, text: '255.255.255.0' },
          { value: 25, text: '255.255.255.128' },
          { value: 26, text: '255.255.255.192' },
          { value: 27, text: '255.255.255.224' },
          { value: 28, text: '255.255.255.240' },
          { value: 29, text: '255.255.255.248' },
          { value: 30, text: '255.255.255.252' },
          { value: 31, text: '255.255.255.254' },
          { value: 32, text: '255.255.255.255' },
        ]

        // if starting from a provided min value
        const prefixes = options.filter(p => p.value >= this.min)

        // add a blank option if the field is not required
        if (!this.required) {
          prefixes.unshift({ value: '', text: '' })
        }

        return prefixes
      },

      /**
       * Returns the subnet based on prefix value, to be shown as suffix
       */
      selectedSubnet: ({ prefixes, value }) => {
        return prefixes.find(p => p.value === value)?.text || ''
      },
    },
    methods: {
      updateValue(value) {
        this.$emit('input', value)
      },
    },
  }
</script>
