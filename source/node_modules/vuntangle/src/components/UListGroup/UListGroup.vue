<template>
  <div>
    <!-- search filter field for items -->
    <v-row dense class="mb-4">
      <v-col cols="8">
        <u-text-field
          v-model="filter.text"
          :label="$vuntangle.$t('filter')"
          clearable
          @input="debouncedApplyFilters"
        ></u-text-field>
      </v-col>
      <v-col cols="4">
        <u-select
          v-model="filter.action"
          :label="$vuntangle.$t('action')"
          :items="actions"
          clearable
          @change="applyFilters"
        >
          <template #selection="{ item }">{{ $vuntangle.$t(item.text) }}</template>
          <template #item="{ item }">{{ $vuntangle.$t(item.text) }}</template>
        </u-select>
      </v-col>
    </v-row>

    <v-row v-show="hasData" dense class="mb-4">
      <v-col cols="8" class="d-flex pl-5">
        <v-checkbox
          v-for="action in actions"
          :key="action.value"
          v-model="allActions[action.value]"
          class="mt-0 mr-4"
          hide-details
          :label="$vuntangle.$t(action.text)"
          :disabled="action.forceEnabledFor.some(key => allActions[key])"
          style="white-space: nowrap"
          :indeterminate="allActions[action.value] === undefined"
          @change="applyActionToAll(action, $event)"
        />
      </v-col>
      <v-col cols="4" class="d-flex justify-end">
        <u-btn text @click="toggleExpand(true)">
          <v-icon dense>mdi-arrow-expand-vertical</v-icon>{{ $vuntangle.$t('expand_all') }}
        </u-btn>
        <u-btn text @click="toggleExpand(false)">
          <v-icon dense>mdi-arrow-collapse-vertical</v-icon>{{ $vuntangle.$t('collapse_all') }}
        </u-btn>
      </v-col>
    </v-row>

    <v-card v-if="hasData" outlined style="overflow: hidden">
      <!-- group heading -->
      <div v-for="(group, key) in groups" :key="key">
        <template v-if="group.items.length">
          <v-sheet
            class="d-flex pa-4 align-center"
            style="cursor: pointer"
            :color="$vuetify.theme.isDark ? 'grey darken-4' : 'grey lighten-4'"
            @click="group.expanded = !group.expanded"
          >
            <v-checkbox
              v-for="action in actions"
              :key="action.value"
              v-model="group[action.value]"
              class="mt-0 mr-4"
              hide-details
              :label="$vuntangle.$t(action.text)"
              :disabled="action.forceEnabledFor.some(key => group[key])"
              style="white-space: nowrap"
              :indeterminate="group[action.value] === undefined"
              @change="applyActionToGroup(group, action, $event)"
              @click.stop
            />
            <span class="text-h6 font-weight-bold">{{ $vuntangle.$t(key) }}</span>
            <v-spacer />
            <span class="body-1 mr-4">
              <strong>{{ group.items.length }} {{ $vuntangle.$t('items') }}</strong>
              {{ getGroupActionsHelperText(group) }}
            </span>
            <v-icon>{{ group.expanded ? 'mdi-chevron-up' : 'mdi-chevron-down' }}</v-icon>
          </v-sheet>
          <v-divider />
        </template>
        <!-- group items list -->
        <v-virtual-scroll v-if="group.expanded" max-height="600" bench="10" :items="group.items" item-height="60">
          <template #default="{ item }">
            <div :key="item[idKey]">
              <v-list-item style="height: 59px">
                <v-checkbox
                  v-for="action in actions"
                  :key="item[idKey] + action.value"
                  v-model="item[action.value]"
                  class="mt-0 mr-4"
                  hide-details
                  :label="$vuntangle.$t(action.text)"
                  :disabled="action.forceEnabledFor.some(key => item[key])"
                  style="white-space: nowrap"
                  @change="applyActionToItem(item, action, $event)"
                />
                <v-list-item-content>
                  <v-list-item-title>
                    <span
                      class="font-weight-bold"
                      v-html="$options.filters.highlight($vuntangle.$t(item[nameKey]), filter.text)"
                    ></span>
                  </v-list-item-title>
                  <v-list-item-subtitle class="caption">
                    <span
                      class="grey--text"
                      v-html="$options.filters.highlight($vuntangle.$t(item[descKey]), filter.text)"
                    ></span>
                  </v-list-item-subtitle>
                </v-list-item-content>
              </v-list-item>
              <v-divider />
            </div>
          </template>
        </v-virtual-scroll>
      </div>
    </v-card>
    <div v-else class="body-2 text-center my-8">
      <p>{{ $vuntangle.$t('no_data_meets_filter') }}</p>
      <u-btn outlined @click="clearFilters">{{ $vuntangle.$t('clear_filters') }}</u-btn>
    </div>
  </div>
</template>
<script>
  import {
    VIcon,
    VCard,
    VSheet,
    VSpacer,
    VDivider,
    VCheckbox,
    VVirtualScroll,
    VListItem,
    VListItemContent,
    VListItemTitle,
    VListItemSubtitle,
  } from 'vuetify/lib'
  import cloneDeep from 'lodash/cloneDeep'
  import debounce from 'lodash/debounce'

  export default {
    components: {
      VIcon,
      VCard,
      VSheet,
      VSpacer,
      VDivider,
      VCheckbox,
      VVirtualScroll,
      VListItem,
      VListItemContent,
      VListItemTitle,
      VListItemSubtitle,
    },
    props: {
      // all records
      items: {
        type: Array,
        required: true,
      },
      // modified records
      selectedItems: {
        type: Array,
        required: true,
      },
      // key in items object array to group items by
      groupBy: {
        type: String,
        default: () => 'category',
      },
      // key in items object array to uniquely identify item
      idKey: {
        type: String,
        default: () => 'id',
      },
      // key in items object array to show name from
      nameKey: {
        type: String,
        default: () => 'name',
      },
      // key in items object array to show description from
      descKey: {
        type: String,
        default: () => 'description',
      },
      actions: {
        type: Array,
        default: () => [
          { value: 'enabled', text: 'block', forceEnabledFor: [] },
          { value: 'flagged', text: 'flag', forceEnabledFor: ['enabled'] },
        ],
      },
    },
    data() {
      return {
        filter: {
          text: null,
          action: null,
        },
        groups: [], // items divided into groups
        allActions: {},
      }
    },

    computed: {
      // mapped list of items with selection populated
      allItems: ({ items, actions, selectedItems, idKey }) => {
        return cloneDeep(items).map(item => {
          // if item is selected populate action keys in item using that
          const selected = selectedItems.find(c => c[idKey] === item[idKey])
          if (selected) {
            actions.forEach(({ value: action }) => (item[action] = selected[action]))
          }
          return item
        })
      },

      // returns false if no data matches the filtered criteria
      hasData: ({ groups }) => {
        return Object.values(groups).some(group => !!group.items.length)
      },
    },

    watch: {
      allItems: {
        immediate: true,
        handler() {
          this.computeGroups()
        },
      },
    },

    methods: {
      /**
       * Structures the items array into a groups object
       * and sets the actions count based on items in the group
       */
      computeGroups() {
        const groups = this.allItems.reduce((result, item) => {
          const cat = item[this.groupBy]
          if (!result[cat]) {
            result[cat] = {
              expanded: this.groups[cat]?.expanded || false,
              allItems: [],
              counts: {},
            }
          }
          result[cat].allItems.push(item)
          return result
        }, {})
        // sort groups
        this.groups = Object.keys(groups)
          .sort()
          .reduce((obj, key) => ({ ...obj, [key]: groups[key] }), {})
        this.applyFilters()
      },

      // recompute group level actions state
      syncGroupsActionState() {
        // calculate action state for each group
        Object.values(this.groups).forEach(group => {
          this.actions.forEach(({ value: action }) => {
            const actionCount = group.items.filter(item => item[action]).length
            group[action] = this.calculateCheckboxState(group.items.length, actionCount)
          })
        })
        // calculate state for top actions
        this.actions.forEach(({ value: action }) => {
          this.allActions[action] = Object.values(this.groups).reduce((value, group) => {
            if (group[action]) {
              return value && group[action]
            }
            if (group[action] === undefined) {
              return undefined
            }
            return false
          }, true)
        })
      },

      /**
       * returns following to decide a checkbox's state
       * true (checked) / false (unchecked) / undefined (indeterminate)
       *
       * @param {number} totalItems total Items
       * @param {number} selectedItems selected Items
       */
      calculateCheckboxState(totalItems, selectedItems) {
        if (selectedItems === totalItems) {
          return true // checked
        }
        if (selectedItems === 0) {
          return false // unchecked
        }
        return undefined // indeterminate
      },

      /**
       * clears the applied filters
       */
      clearFilters() {
        this.filter.text = null
        this.filter.action = null
        this.applyFilters()
      },

      debouncedApplyFilters: debounce(function (value) {
        this.filter.text = value
        this.applyFilters()
      }, 300),

      /**
       * applies the filters to the items in the groups
       */
      applyFilters() {
        this.groups = Object.entries(this.groups).reduce((groups, [cat, group]) => {
          const items = this.filterList(group.allItems)
          // update action counts after filter
          this.actions.forEach(({ value: action }) => {
            group.counts[action] = items.filter(item => item[action]).length
          })
          return { ...groups, [cat]: { ...group, items } }
        }, {})
        this.syncGroupsActionState()
      },

      /**
       * filters the list based on the selected filters
       * @param {Array} list list to filter
       */
      filterList(list = []) {
        // get the items matching the filters (if set)
        if (this.filter.text || this.filter.action) {
          list = list.filter(item => {
            let textFilter = true
            let actFilter = true
            if (this.filter.text) {
              textFilter = [this.nameKey, this.descKey].some(key =>
                this.$vuntangle.$t(item[key]).toLowerCase().includes(this.filter.text.toLowerCase()),
              )
            }
            if (this.filter.action) {
              actFilter = item[this.filter.action]
            }
            return textFilter && actFilter
          })
        }
        return list
      },

      /**
       * applies the action to all (filtered) items in all group
       *
       * @param {Object} action the action to perform on the group
       * @param {boolean} value new value of the action flag
       */
      applyActionToAll(action, value) {
        const selectedCopy = cloneDeep(this.selectedItems)
        Object.values(this.groups).forEach(group => {
          group.items.forEach(item => {
            this.updateFlag(selectedCopy, item, action, value)
          })
        })
        this.$emit('update:selectedItems', selectedCopy)
      },

      /**
       * applies the action to all (filtered) items in passed group
       *
       * @param {boolean} value boolean to set for the whole group
       * @param {Object} action the action to perform on the group
       * @param {boolean} value new value of the action flag
       */
      applyActionToGroup(group, action, value) {
        const selectedCopy = cloneDeep(this.selectedItems)
        group.items.forEach(item => {
          this.updateFlag(selectedCopy, item, action, value)
        })
        this.$emit('update:selectedItems', selectedCopy)
      },

      /**
       * applies the action to the passed item
       *
       * @param {Object} item the record to toggle the flag for
       * @param {Object} action the action to perform on the item
       * @param {boolean} value new value of the flag
       */
      applyActionToItem(item, action, value) {
        const selectedCopy = this.updateFlag(cloneDeep(this.selectedItems), item, action, value)
        this.$emit('update:selectedItems', selectedCopy)
      },

      /**
       *
       * @param {array} selectedItems list of selected items
       * @param {Object} item item to modify
       * @param {Object} targetAction action to perform on the item
       * @param {boolean} value value of the action to apply
       */
      updateFlag(selectedItems, item, targetAction, value) {
        const key = targetAction.value
        let selected = selectedItems.find(c => c[this.idKey] === item[this.idKey])
        if (!selected) {
          selected = { [this.idKey]: item[this.idKey], [key]: value }
          selectedItems.push(selected)
        } else {
          // enable the action unless its not disabled
          if (value || targetAction.forceEnabledFor.every(key => !selected[key])) {
            selected[key] = value
            // reset other actions if configured
            if (value && item[targetAction.resets]) {
              selected[targetAction.resets] = false
            }
          }
          if (this.actions.every(({ value: action }) => !selected[action])) {
            // clean up selectedItems in case no action is selected
            const idx = selectedItems.findIndex(c => c[this.idKey] === selected[this.idKey])
            selectedItems.splice(idx, 1)
            return selectedItems
          }
        }
        // check if there are force enabled conditions for any action
        this.actions.forEach(({ value: action, forceEnabledFor }) => {
          if (forceEnabledFor.includes(key)) {
            selected[action] = true
          }
        })
        return selectedItems
      },

      /**
       * used to expand / collapse all group
       *
       * @param {boolean} expand boolean to decide whether to expand or close
       */
      toggleExpand(expand) {
        Object.values(this.groups).forEach(group => {
          group.expanded = expand
        })
      },

      /**
       * Generates an action count for the group in the format; (3 block, 4 flag)
       *
       * @param {Object} group target group
       */
      getGroupActionsHelperText(group) {
        const actionCounts = this.actions.map(
          action => `${group.counts[action.value]} ${this.$vuntangle.$t(action.text)}`,
        )
        return `(${actionCounts.join(', ')})`
      },
    },
  }
</script>
