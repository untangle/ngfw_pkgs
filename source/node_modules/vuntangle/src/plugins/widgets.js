/**
 * This plugin contains functions that deal with widget layout and storage
 */

import util from './util'

const widgets = {
  breakpoints: { xl: 1980, lg: 1200, md: 996, sm: 768 },
  gridSizes: { xl: 4, lg: 3, md: 2, sm: 1 },

  /**
   * Get the breakpoint of the users browsers.  Used for initial display of the grid
   * and saving display on a change.
   *
   * @returns {string}
   */
  getBreakpoint() {
    let initialBreakpoint = 'sm'
    const browserWidth = util.getBrowserWidth()
    for (const breakpoint of Object.getOwnPropertyNames(this.breakpoints)) {
      if (browserWidth >= this.breakpoints[breakpoint]) {
        initialBreakpoint = breakpoint
        break
      }
    }

    return initialBreakpoint
  },

  /**
   * Get the layout from local storage.
   *
   * @param itemName {string}
   *
   * @returns {null|Object}
   */
  getStoredLayout(itemName) {
    const dashboardLayout = window.sessionStorage.getItem(itemName)
    if (dashboardLayout === null) {
      return null
    }

    return JSON.parse(dashboardLayout)
  },

  /**
   *
   * Set the new layout into storage.
   *
   * @param itemName  {string}
   * @param newLayout {Object}
   *
   * @returns {void}
   */
  setStoredLayout: (itemName, newLayout) => window.sessionStorage.setItem(itemName, JSON.stringify(newLayout)),

  /**
   * Get a layout for vue-grid.  Will return breakpoint sizes with x,y widgets fit into the grid
   * based on the size of widgets and columns available.
   *
   * @param gridSizes          {Object} Object of key/values like: breakpoint: columns
   * @param enabledWidgets     {Array}  Array of widget_index's that are enabled on the page
   * @param widgetComponentMap {Object} Object objects like: widget_index: {component: '', width: 1}
   *
   * @returns {{xl: [], md: [], sm: [], lg: []}}
   */
  getLayout(enabledWidgets, widgetComponentMap) {
    const responsiveLayouts = { xl: [], lg: [], md: [], sm: [] }

    // inline method to reduce code when inserting rows during iteration and at the end of iteration
    const addRow = (row, rowWidth, maxRowWidth, key) => {
      // make sure the row has items
      if (row.length === 0) {
        return
      }

      // if there is no room, make the last widget stretch the full columns
      if (rowWidth < maxRowWidth) {
        row[row.length - 1].w += maxRowWidth - rowWidth
      }

      // add the row to the layout
      responsiveLayouts[key].push(...row)
    }

    // loop through grid sizes
    for (const breakpoint in this.gridSizes) {
      const maxRowWidth = this.gridSizes[breakpoint]

      // loop through widgets, add widget to row if it fits or add it to the next row
      let rowNumber = 0
      let rowWidth = 0
      let row = []
      enabledWidgets.forEach((id, i) => {
        // if the widget itself is wider than the max row width, like for sm breakpoint, use the max row width
        const widgetWidth = widgetComponentMap[id].width > maxRowWidth ? maxRowWidth : widgetComponentMap[id].width

        const baseCell = {
          i,
          id,
          cmp: widgetComponentMap[id].component,
          w: widgetWidth,
          h: 1,
          resize: false,
        }

        // add to the row if there is room
        if (rowWidth + widgetWidth <= maxRowWidth) {
          row.push({ ...baseCell, x: rowWidth, y: rowNumber })
        } else {
          // add the last row
          addRow(row, rowWidth, maxRowWidth, breakpoint)

          // add the widget to the next row
          rowWidth = 0
          rowNumber++
          row = [{ ...baseCell, x: rowWidth, y: rowNumber }]
        }

        // add the widget to the current row width
        rowWidth += widgetWidth
      })

      // add the last row
      addRow(row, rowWidth, maxRowWidth, breakpoint)
    }

    return responsiveLayouts
  },
}

export default widgets
