import jsonschema from 'jsonschema'
import { _ as agGridUtils } from '@ag-grid-community/core'
import ip6 from './ip6'

export default {
  copyToClipboard: text => {
    if (window.clipboardData && window.clipboardData.setData) {
      return window.clipboardData.setData('Text', text)
    } else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      const textarea = document.createElement('textarea')
      textarea.textContent = text
      textarea.style.position = 'fixed' // Prevent scrolling to bottom of page in Microsoft Edge.
      document.body.appendChild(textarea)
      textarea.select()
      try {
        return document.execCommand('copy') // Security exception may be thrown by some browsers.
      } catch (ex) {
        // eslint-disable-next-line no-console
        console.warn('Copy to clipboard failed.', ex)
        return false
      } finally {
        document.body.removeChild(textarea)
      }
    }
  },

  /**
   * Get the current browser size width.
   *
   * @returns {number}
   */
  getBrowserWidth() {
    if (self.innerWidth) {
      return self.innerWidth
    }
    if (document.documentElement && document.documentElement.clientWidth) {
      return document.documentElement.clientWidth
    }
    if (document.body) {
      return document.body.clientWidth
    }
  },

  /**
   * Get human readable time by convert seconds into hours, minutes, seconds.
   *
   * @param   {Number} seconds
   * @returns {string}
   */
  getReadableTime: seconds =>
    `${Math.floor(seconds / 3600)}h ${Math.floor(seconds / 60) % 60}m ${Math.round(seconds) % 60}s`,

  /**
   * Returns true if the given address is a valid IPv4 address
   * @param {string} address IPv4 address
   * @param {boolean} withCIDR true if address includes a CIDR range. i.e. 1.1.1.1/24
   * @returns
   */
  isIPv4AddressValid(address, withCIDR = false) {
    if (!address) return false
    if (withCIDR) {
      const cidrV4Regex =
        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$/
      return cidrV4Regex.test(address)
    }
    const ipV4Regex = /^(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$/
    return ipV4Regex.test(address)
  },

  /**
   * Returns true if the given address is a valid IPv6 address
   * @param {string} address IPv6 address
   * @param {boolean} withCIDR true if address includes a CIDR range. i.e. 2001:0db8:85a3:0000:0000:8a2e:0370:7334/24
   * @returns
   */
  isIPv6AddressValid(address, withCIDR = false) {
    if (!address) return false
    if (withCIDR) {
      const cidrV6Regex =
        /^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])){1}$/
      return cidrV6Regex.test(address)
    }
    const ipV6Regex =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
    return ipV6Regex.test(address)
  },

  /**
   * Returns true if the IPv4 range is valid
   * @param {string} rangeStart valid IPv4 address, start of the IP range
   * @param {string} rangeEnd valid IPv address, end of the IP range
   * @returns
   */
  isIPv4RangeValid(rangeStart, rangeEnd) {
    const start = this.ipv4ToLong(rangeStart)
    const end = this.ipv4ToLong(rangeEnd)
    return end > start
  },

  /**
   * Returns true if the IPv6 range is valid
   * @param {string} rangeStart valid IPv6 address, start of the IP range
   * @param {string} rangeEnd valid IPv6 address, end of the IP range
   * @returns
   */
  isIPv6RangeValid(rangeStart, rangeEnd) {
    const start = ip6.normalize(rangeStart).replace(/:/g, '')
    const end = ip6.normalize(rangeEnd).replace(/:/g, '')
    return end > start
  },

  ipv4ToLong(address) {
    const parts = address.split('.')
    return parts[0] * 16777216 + parts[1] * 65536 + parts[2] * 256 + parts[3] * 1
  },

  /**
   * Convert an ip6 address to a javascript BigInt type.
   *
   * @param address
   * @returns {bigint}
   */
  ipv6ToBigInt(address) {
    let binaryString = '0b'
    ip6
      .normalize(address)
      .split(':')
      .forEach(hextet => (binaryString += parseInt(hextet, 16).toString(2).padStart(16, '0')))

    return BigInt(binaryString)
  },

  /**
   * Convert any ip address (ipv4 or ipv6) to a javascript BigInt type.
   *
   * @param address
   * @returns {bigint}
   */
  ipAnyToBigInt(address) {
    // try to convert ip4
    if (this.isIPv4AddressValid(address)) {
      return BigInt(this.ipv4ToLong(address))
    }

    // try to convert ip6, normalize first
    if (this.isIPv6AddressValid(address)) {
      return this.ipv6ToBigInt(address)
    }

    return BigInt(0)
  },

  /**
   * Compare any ip address (ipv4 or ipv6) string, returns 1, 0, or -1.  Used for sorting.
   *
   * @param   {string} a
   * @param   {string} b
   * @returns {number}
   */
  compareIpAny(a, b) {
    a = this.ipAnyToBigInt(this.getIpForSorting(a))
    b = this.ipAnyToBigInt(this.getIpForSorting(b))

    return a === b ? 0 : a > b ? 1 : -1
  },

  /**
   * Compare two time intervals, composed of a time and unit, returns 1, 0, or -1. Used for sorting in dynamic blocklists' "Polling Interval" column.
   *
   * @param {number} aTime The count of units (as in A hours)
   * @param {string} aUnit The unit (days or minutes)
   * @param {number} bTime The count of units (as in B hours)
   * @param {string} bUnit The unit (days or minutes)
   * @returns {number}
   */
  compareTimeIntervals(aTime, aUnit, bTime, bUnit) {
    // NOTE: only have to use English here, under the hood is always English (and plural)
    const unitsToSeconds = {
      'minutes': 60,
      'hours': 60 * 60,
      'days': 60 * 60 * 24,
      'months': 60 * 60 * 24 * 31,
    }
    const a = aTime * unitsToSeconds[aUnit.toLowerCase()]
    const b = bTime * unitsToSeconds[bUnit.toLowerCase()]
    return a === b ? 0 : a > b ? 1 : -1
  },

  /**
   * Returns true if the given hostname address is valid
   * @param {string}} address
   * @returns
   */
  isHostnameValid(address) {
    const hostnameRegex =
      /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$/i
    return hostnameRegex.test(address)
  },

  /**
   * returns langdebug flag based on query string and local storage
   * @returns {boolean} true/false if debugging is enabled
   */
  langDebug() {
    // expects .../some/uri?langdebug=true
    const uri = window.location.search.substring(1)
    const params = new URLSearchParams(uri)
    if (params.has('langdebug')) {
      if (params.get('langdebug') === 'true') {
        // add langdebug to local storage
        window.localStorage.setItem('langdebug', true)
      } else {
        // remove langdebug from local storage
        window.localStorage.removeItem('langdebug')
      }
    }
    // return current value
    return window.localStorage.getItem('langdebug')
  },

  // possible comparison operators with the operator as the key, and the translation key as the value
  operators: {
    '==': 'is',
    '!=': 'is_not',
    '>': 'greater_than',
    '<': 'less_than',
    '>=': 'greater_or_equal',
    '<=': 'less_or_equal',
  },

  // ISO-3166 alpha2 country codes as listed on http://www.geonames.org/countries/
  country_codes: {
    'AD': 'Andorra',
    'AE': 'United Arab Emirates',
    'AF': 'Afghanistan',
    'AG': 'Antigua and Barbuda',
    'AI': 'Anguilla',
    'AL': 'Albania',
    'AM': 'Armenia',
    'AO': 'Angola',
    'AQ': 'Antarctica',
    'AR': 'Argentina',
    'AS': 'American Samoa',
    'AT': 'Austria',
    'AU': 'Australia',
    'AW': 'Aruba',
    'AX': 'Åland',
    'AZ': 'Azerbaijan',
    'BA': 'Bosnia and Herzegovina',
    'BB': 'Barbados',
    'BD': 'Bangladesh',
    'BE': 'Belgium',
    'BF': 'Burkina Faso',
    'BG': 'Bulgaria',
    'BH': 'Bahrain',
    'BI': 'Burundi',
    'BJ': 'Benin',
    'BL': 'Saint Barthélemy',
    'BM': 'Bermuda',
    'BN': 'Brunei',
    'BO': 'Bolivia',
    'BQ': 'Bonaire, Sint Eustatius, and Saba',
    'BR': 'Brazil',
    'BS': 'Bahamas',
    'BT': 'Bhutan',
    'BV': 'Bouvet Island',
    'BW': 'Botswana',
    'BY': 'Belarus',
    'BZ': 'Belize',
    'CA': 'Canada',
    'CC': 'Cocos (Keeling) Islands',
    'CD': 'DR Congo',
    'CF': 'Central African Republic',
    'CG': 'Congo Republic',
    'CH': 'Switzerland',
    'CI': 'Ivory Coast',
    'CK': 'Cook Islands',
    'CL': 'Chile',
    'CM': 'Cameroon',
    'CN': 'China',
    'CO': 'Colombia',
    'CR': 'Costa Rica',
    'CU': 'Cuba',
    'CV': 'Cabo Verde',
    'CW': 'Curaçao',
    'CX': 'Christmas Island',
    'CY': 'Cyprus',
    'CZ': 'Czechia',
    'DE': 'Germany',
    'DJ': 'Djibouti',
    'DK': 'Denmark',
    'DM': 'Dominica',
    'DO': 'Dominican Republic',
    'DZ': 'Algeria',
    'EC': 'Ecuador',
    'EE': 'Estonia',
    'EG': 'Egypt',
    'EH': 'Western Sahara',
    'ER': 'Eritrea',
    'ES': 'Spain',
    'ET': 'Ethiopia',
    'FI': 'Finland',
    'FJ': 'Fiji',
    'FK': 'Falkland Islands',
    'FM': 'Micronesia',
    'FO': 'Faroe Islands',
    'FR': 'France',
    'GA': 'Gabon',
    'GB': 'United Kingdom',
    'GD': 'Grenada',
    'GE': 'Georgia',
    'GF': 'French Guiana',
    'GG': 'Guernsey',
    'GH': 'Ghana',
    'GI': 'Gibraltar',
    'GL': 'Greenland',
    'GM': 'The Gambia',
    'GN': 'Guinea',
    'GP': 'Guadeloupe',
    'GQ': 'Equatorial Guinea',
    'GR': 'Greece',
    'GS': 'South Georgia and South Sandwich Islands',
    'GT': 'Guatemala',
    'GU': 'Guam',
    'GW': 'Guinea-Bissau',
    'GY': 'Guyana',
    'HK': 'Hong Kong',
    'HM': 'Heard and McDonald Islands',
    'HN': 'Honduras',
    'HR': 'Croatia',
    'HT': 'Haiti',
    'HU': 'Hungary',
    'ID': 'Indonesia',
    'IE': 'Ireland',
    'IL': 'Israel',
    'IM': 'Isle of Man',
    'IN': 'India',
    'IO': 'British Indian Ocean Territory',
    'IQ': 'Iraq',
    'IR': 'Iran',
    'IS': 'Iceland',
    'IT': 'Italy',
    'JE': 'Jersey',
    'JM': 'Jamaica',
    'JO': 'Jordan',
    'JP': 'Japan',
    'KE': 'Kenya',
    'KG': 'Kyrgyzstan',
    'KH': 'Cambodia',
    'KI': 'Kiribati',
    'KM': 'Comoros',
    'KN': 'St Kitts and Nevis',
    'KP': 'North Korea',
    'KR': 'South Korea',
    'KW': 'Kuwait',
    'KY': 'Cayman Islands',
    'KZ': 'Kazakhstan',
    'LA': 'Laos',
    'LB': 'Lebanon',
    'LC': 'Saint Lucia',
    'LI': 'Liechtenstein',
    'LK': 'Sri Lanka',
    'LR': 'Liberia',
    'LS': 'Lesotho',
    'LT': 'Lithuania',
    'LU': 'Luxembourg',
    'LV': 'Latvia',
    'LY': 'Libya',
    'MA': 'Morocco',
    'MC': 'Monaco',
    'MD': 'Moldova',
    'ME': 'Montenegro',
    'MF': 'Saint Martin',
    'MG': 'Madagascar',
    'MH': 'Marshall Islands',
    'MK': 'North Macedonia',
    'ML': 'Mali',
    'MM': 'Myanmar',
    'MN': 'Mongolia',
    'MO': 'Macao',
    'MP': 'Northern Mariana Islands',
    'MQ': 'Martinique',
    'MR': 'Mauritania',
    'MS': 'Montserrat',
    'MT': 'Malta',
    'MU': 'Mauritius',
    'MV': 'Maldives',
    'MW': 'Malawi',
    'MX': 'Mexico',
    'MY': 'Malaysia',
    'MZ': 'Mozambique',
    'NA': 'Namibia',
    'NC': 'New Caledonia',
    'NE': 'Niger',
    'NF': 'Norfolk Island',
    'NG': 'Nigeria',
    'NI': 'Nicaragua',
    'NL': 'Netherlands',
    'NO': 'Norway',
    'NP': 'Nepal',
    'NR': 'Nauru',
    'NU': 'Niue',
    'NZ': 'New Zealand',
    'OM': 'Oman',
    'PA': 'Panama',
    'PE': 'Peru',
    'PF': 'French Polynesia',
    'PG': 'Papua New Guinea',
    'PH': 'Philippines',
    'PK': 'Pakistan',
    'PL': 'Poland',
    'PM': 'Saint Pierre and Miquelon',
    'PN': 'Pitcairn Islands',
    'PR': 'Puerto Rico',
    'PS': 'Palestine',
    'PT': 'Portugal',
    'PW': 'Palau',
    'PY': 'Paraguay',
    'QA': 'Qatar',
    'RE': 'Réunion',
    'RO': 'Romania',
    'RS': 'Serbia',
    'RU': 'Russia',
    'RW': 'Rwanda',
    'SA': 'Saudi Arabia',
    'SB': 'Solomon Islands',
    'SC': 'Seychelles',
    'SD': 'Sudan',
    'SE': 'Sweden',
    'SG': 'Singapore',
    'SH': 'Saint Helena',
    'SI': 'Slovenia',
    'SJ': 'Svalbard and Jan Mayen',
    'SK': 'Slovakia',
    'SL': 'Sierra Leone',
    'SM': 'San Marino',
    'SN': 'Senegal',
    'SO': 'Somalia',
    'SR': 'Suriname',
    'SS': 'South Sudan',
    'ST': 'São Tomé and Príncipe',
    'SV': 'El Salvador',
    'SX': 'Sint Maarten',
    'SY': 'Syria',
    'SZ': 'Eswatini',
    'TC': 'Turks and Caicos Islands',
    'TD': 'Chad',
    'TF': 'French Southern Territories',
    'TG': 'Togo',
    'TH': 'Thailand',
    'TJ': 'Tajikistan',
    'TK': 'Tokelau',
    'TL': 'Timor-Leste',
    'TM': 'Turkmenistan',
    'TN': 'Tunisia',
    'TO': 'Tonga',
    'TR': 'Turkey',
    'TT': 'Trinidad and Tobago',
    'TV': 'Tuvalu',
    'TW': 'Taiwan',
    'TZ': 'Tanzania',
    'UA': 'Ukraine',
    'UG': 'Uganda',
    'UM': 'U.S. Outlying Islands',
    'US': 'United States',
    'UY': 'Uruguay',
    'UZ': 'Uzbekistan',
    'VA': 'Vatican City',
    'VC': 'St Vincent and Grenadines',
    'VE': 'Venezuela',
    'VG': 'British Virgin Islands',
    'VI': 'U.S. Virgin Islands',
    'VN': 'Vietnam',
    'VU': 'Vanuatu',
    'WF': 'Wallis and Futuna',
    'WS': 'Samoa',
    'XK': 'Kosovo',
    'YE': 'Yemen',
    'YT': 'Mayotte',
    'ZA': 'South Africa',
    'ZM': 'Zambia',
    'ZW': 'Zimbabwe',
    'XL': 'Local',
    'XU': 'Unknown',
  },

  /**
   * Method to get the a query string parameter from a URL name
   * From: http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
   * @param name - name of the query parameter to get
   * @param url - url. If not set, will use current windows's URL
   * @returns {*} - parameter value if found or null
   */
  getUrlParameterByName(name, url) {
    if (!url) {
      url = window.location.href
    }
    name = name.replace(/[[\]]/g, '\\$&')
    const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)')
    const results = regex.exec(url)

    if (!results) return null

    if (!results[2]) return ''

    return decodeURIComponent(results[2])
  },

  /**
   *
   * @returns generates guids
   */
  uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16),
    )
  },

  /**
   * validates if an email address is valid or not
   *
   * @param email - email to validate
   * @return - boolean
   */
  validateEmail(email) {
    const emailRegex = /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+$/
    return emailRegex.test(email)
  },

  /**
   * Used to validate an object to a schema, primarily used with importing in ME policy templates
   *
   * @param {Object} testObj
   * @param {Object} schema
   * @returns {boolean}
   */
  validateSchema(testObj, schema) {
    const result = jsonschema.validate(testObj, schema)
    return result.errors.length === 0
  },

  /**
   * Downloads the dynamic list content as CSV
   * @param {String} fileName - the dynamic list file name to be saved on disk
   * @param {String} content - the downloaded response content
   */
  processDynamicListDownload(fileName, content) {
    const lines = content.split('\n')
    const csv = lines.map(ip => `"${ip}"`).join('\n')
    const blob = new Blob([csv], { type: 'text/csv' })
    const url = window.URL.createObjectURL(blob)

    const el = document.createElement('a')
    el.setAttribute('href', url)
    el.setAttribute('download', fileName)
    el.style.display = 'none'
    document.body.appendChild(el)
    el.click()
    URL.revokeObjectURL(url)
    document.body.removeChild(el)
  },

  /**
   * return uptime into days, hours and minutes format
   * @param {String} time - time to be converted
   */
  formatUptime(time) {
    const numdays = Math.floor((time % 31536000) / 86400)
    const numhours = Math.floor(((time % 31536000) % 86400) / 3600)
    const numminutes = Math.floor((((time % 31536000) % 86400) % 3600) / 60)
    let uptime = ''

    if (numdays > 0) {
      uptime += numdays + 'd '
    }
    if (numhours > 0) {
      uptime += numhours + 'h '
    }
    if (numminutes > 0) {
      uptime += numminutes + 'm'
    }
    return uptime
  },

  /**
   * Get only the ip address from ip string
   *  e.g: for 1.1.1.1/23 will return 1.1.1.1
   *       for 2.2.2.2, 3.3.3.3/23 or 2.2.2.2/10, 4.4.4.4 will return 2.2.2.2
   *
   * @param   {string} ip
   * @returns {string}
   */
  getIpForSorting(ip) {
    if (!ip) return ip

    if (ip.includes(',')) {
      // If the ip string contains ',', keep only what's in front of it
      ip = ip.split(',')[0]
    }
    if (ip.includes('-')) {
      // If the ip string contains '-', keep only what's in front of it
      ip = ip.split('-')[0]
    }
    if (ip.includes('/')) {
      // If the ip string contains '/', keep only what's in front of it
      ip = ip.split('/')[0]
    }

    return ip
  },

  /**
   * Sort any two strings alpha numerically
   *
   * @param   {string} valueA
   * @param   {string} valueB
   * @param   {string} locale
   * @param   {?boolean} accentedCompare
   * @returns {number}
   */
  sortAlphaNumerically(valueA, valueB, locale, accentedCompare) {
    if (typeof valueA === 'string') {
      try {
        // using local compare also allows chinese comparisons
        return valueA.localeCompare(valueB, locale, { numeric: true, sensitivity: 'base' })
      } catch (e) {
        // if something wrong with localeCompare, e.g. not supported
        // by browser, then just continue with the quick one
        return valueA > valueB ? 1 : valueA < valueB ? -1 : 0
      }
    }

    // use ag-grid default comparator
    return agGridUtils.defaultComparator(valueA, valueB, accentedCompare)
  },
}
