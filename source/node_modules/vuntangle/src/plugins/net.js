/**
 * IP Subnet calculator utility
 */

import { Addr } from 'netaddr'

/**
 * Converts quad dotted IP address to a 32-bit binary string representation
 * e.g. "192.168.1.1" => "11000000101010000000000100000001"
 * @param {string} ip
 * @returns binary string representation of IP address
 */
const decimalToBinary = ip => {
  const decimalOctets = ip.split('.')
  const binaryOctets = []
  decimalOctets.forEach(dOctet => {
    const octet = parseInt(dOctet)
    // this condition is redundant because the ip is already validated
    if (octet < 0 || octet > 255 || octet % 1 !== 0) return
    binaryOctets.push(('000000000' + octet.toString(2)).slice(-8))
  })
  return binaryOctets.join('')
}

/**
 * Converts a 32-bit binary string representation to a quad dotted decimal IP address
 * e.g. "11000000101010000000000100000001" => "192.168.1.1"
 * @param {string} b string
 * @returns decimal quad dotted IP address
 */
const binaryToDecimal = b => {
  return (
    parseInt(b.slice(0, 8), 2) +
    '.' +
    parseInt(b.slice(8, 16), 2) +
    '.' +
    parseInt(b.slice(16, 24), 2) +
    '.' +
    parseInt(b.slice(24, 32), 2)
  )
}

/**
 * Returns the 32-bit binary string of a subnet mask
 * e.g. cidr = 24 => "11111111111111111111111100000000"
 * @param {number} cidr cidr integer 1 to 32
 * @returns binary subnet mask string
 */
const cidrToSubnetBinary = cidr => {
  let bin = ''
  const c = parseInt(cidr)
  for (let i = 0; i <= 31; i++) {
    bin += i < c ? '1' : '0'
  }
  return bin
}

/**
 * Computes a logical AND on 32-bit like strings
 * e.g.
 * "11000000101010000000001000000001"
 * "11111111111111111111111100000000"
 * ----------------------------------
 * "11000000101010000000001000000000"
 * @param {string} b1
 * @param {string} b2
 * @returns {string}
 */
const binaryAnd = (b1, b2) => {
  let bin = ''
  for (let i = 0; i <= 31; i++) {
    bin += b1[i] === '0' || b2[i] === '0' ? '0' : '1'
  }
  return bin
}

/**
 * Computes a logical OR on 32-bit like strings
 * e.g.
 * "11000000101010000000001000000001"
 * "11111111111111111111111100000000"
 * ----------------------------------
 * "11111111111111111111111100000001"
 * @param {string} b1
 * @param {string} b2
 * @returns {string}
 */
const binaryOr = (b1, b2) => {
  let bin = ''
  for (let i = 0; i <= 31; i++) {
    bin += b1[i] === '1' || b2[i] === '1' ? '1' : '0'
  }
  return bin
}

/**
 * Inverts a 32-bit like strings
 * e.g.
 * "11000000101010000000001000000001" to
 * "00111111010101111111110111111110"
 * @param {string} b
 * @returns string representing inverse binary input
 */
const binaryInverse = b => {
  let bin = ''
  for (let i = 0; i <= 31; i++) {
    bin += b[i] === '0' ? '1' : '0'
  }
  return bin
}

/**
 * Returns the IP class
 * @param {string} ip - the IP address
 * @returns IP class
 */
const getClass = ip => {
  if (ip.startsWith('0')) return 'A'
  if (ip.startsWith('10')) return 'B'
  if (ip.startsWith('110')) return 'C'
  if (ip.startsWith('1110')) return 'D'
  if (ip.startsWith('1111')) return 'E'
}

/**
 * Computes first available host for a given network address
 * @param {string} ip - the network IP address
 * @returns {string}
 */
const getFirstHost = ip => {
  const decimalOctets = ip.split('.')
  decimalOctets[3] = parseInt(decimalOctets[3]) + 1
  return decimalOctets.join('.')
}

/**
 * Computes last available host for a given network address
 * @param {string} ip - the broadcast IP address
 * @returns {string}
 */
const getLastHost = ip => {
  const decimalOctets = ip.split('.')
  decimalOctets[3] = parseInt(decimalOctets[3]) - 1
  return decimalOctets.join('.')
}

/**
 * IP validator
 * @param {string} ip - the IP address
 * @returns {boolean}
 */
const isValidIp = ip => {
  const ipV4Regex = /^(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))$/
  return ipV4Regex.test(ip)
}

/**
 * CIDR validator
 * @param {number} cidr - the CIDR value
 * @returns {boolean}
 */
const isValidCidr = cidr => {
  if (isNaN(cidr)) return false
  const c = parseInt(cidr)
  if (c < 0 || c > 32) return false
  return true
}

/**
 * Returns network info for an IP/cidr combination
 * - ip - the input IP as quad dotted decimal
 * - cidr - the input CIDR value
 * - class - the IP class computed based on first binary digits of the IP
 * - networkAddress - computed as logical binary AND of the IP and subnet mask
 * - subnetMask - computed from CIDR
 * - broadcastAddress - computed as binary OR between networkAddress binary and the inverse binary of the subnet mask
 * - totalAddresses - computed as 2^(32 - cidr)
 * - usableHosts - computed from totalAddresses - 2 (network and broadcast)
 * - firstHost - computed as next address after the network address
 * - lastHost - computed as the address right before the broadcast address
 * Note: for cidr = 31 or 32, the first and last hosts are returned as null
 *
 * @param {string} ip - the IP address
 * @param {number} cidr - CIDR value 1 - 32
 * @returns {object}
 */
const info = (ip, cidr) => {
  if (!isValidIp(ip) || !isValidCidr(cidr)) return

  const binaryIp = decimalToBinary(ip)
  const binarySubnet = cidrToSubnetBinary(cidr)
  const subnetIp = binaryToDecimal(binarySubnet)
  const binaryNetwork = binaryAnd(binaryIp, binarySubnet)
  const networkAddress = binaryToDecimal(binaryNetwork)
  const totalAddresses = 2 ** (32 - parseInt(cidr))
  const broadcastBinary = binaryOr(binaryNetwork, binaryInverse(binarySubnet))
  const broadcastAddress = binaryToDecimal(broadcastBinary)

  return {
    ip,
    cidr,
    class: getClass(binaryIp),
    networkAddress,
    subnetMask: subnetIp,
    broadcastAddress,
    totalAddresses,
    usableHosts: totalAddresses - 2,
    firstHost: cidr < 31 ? getFirstHost(networkAddress) : null,
    lastHost: cidr < 31 ? getLastHost(broadcastAddress) : null,
  }
}

/**
 * Returns if a given host falls into network range defined by an address and prefix (cidr)
 * @param {string} ip - the network IP address
 * @param {number} cidr - the network cidr (prefix)
 * @param {string} host - the host IP to be checked if in available hosts
 * @returns {boolean}
 */
const isHostInRange = (ip, cidr, host) => {
  if (!isValidIp(ip) || !isValidCidr(cidr) || !isValidIp(host)) return
  const netInfo = info(ip, cidr)
  if (!netInfo.firstHost || !netInfo.lastHost) return false
  if (
    decimalToBinary(netInfo.firstHost) <= decimalToBinary(host) &&
    decimalToBinary(netInfo.lastHost) >= decimalToBinary(host)
  )
    return true
  return false
}

/**
 * Checks if DHCP hosts range is valid
 * @param {string} rangeStart - dhcp starting range host
 * @param {number} rangeEnd - dhcp ending range host
 * @returns {boolean}
 */
const isValidDhcpRange = (rangeStart, rangeEnd) => {
  if (!isValidIp(rangeStart) || !isValidIp(rangeEnd)) return
  return decimalToBinary(rangeStart) < decimalToBinary(rangeEnd)
}

/**
 * Checks if two subnets are intersecting (overlapping)
 * @param {string} subnet1 - first subnet
 * @param {string} subnet2 - second subnet
 * @returns {boolean} true/false
 */
const subnetConflict = (subnet1, subnet2) => {
  const s1 = Addr(subnet1)
  const s2 = Addr(subnet2)
  const conflict = s1.intersect(s2)
  return !!conflict
}

export default { info, isHostInRange, isValidDhcpRange, subnetConflict }
