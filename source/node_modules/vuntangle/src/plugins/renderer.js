import categories from '../shared/SettingsWebFilter/categories.json'
import dates from '../plugins/dates'
import {
  protocols,
  priorities,
  families,
  countryCodes,
  outgoingThreatLevels,
  productivityLevels,
  riskLevels,
  dosProtocol,
} from '../constants'
import i18n from './vue-i18n'

const renderer = {
  ipProtocol: value => {
    return protocols[value] ? protocols[value] : value
  },

  dosIPProtocol: value => {
    return dosProtocol[value] ? dosProtocol[value] : value
  },

  interfaceName: (value, idNameMap) => {
    switch (parseInt(value)) {
      case 0:
        return i18n.t('unset')
      case 255:
        return i18n.t('local')
      default:
        return idNameMap?.[value] || i18n.t('unknown')
    }
  },

  wanRule: (value, idNameMap) => idNameMap?.[value] || i18n.t('unknown'),
  wanPolicy: (value, idNameMap) => idNameMap?.[value] || i18n.t('unknown'),
  policyName: (value, idNameMap) => idNameMap?.[value] || i18n.t('unknown'),
  configName: (value, idNameMap) => idNameMap?.[value] || i18n.t('unknown'),
  ruleName: (value, idNameMap) => {
    const rules = []
    value.forEach(rule => rules.push(idNameMap?.[rule] || i18n.t('unknown')))
    return rules
  },

  boolean: value => {
    if (value === null || value === undefined) {
      return ''
    }
    if (value === true || value === 'true' || value === 1) {
      return i18n.t('yes')
    }
    if (value === false || value === 'false' || value === 0) {
      return i18n.t('no')
    }
  },

  hex: value => {
    if (value === null || value === undefined) {
      return ''
    }
    return '0x' + ('00000000' + value.toString(16)).substr(-8)
  },

  shortenText: str => (str.length > 15 ? `${str.substr(0, 5)} ... ${str.substr(str.length - 5, str.length)}` : str),

  timeStamp: value => dates.formatDateFromApi(value),

  // imported from old ui
  timeRangeSeconds: sec => {
    if (sec === null || sec === undefined) {
      return ''
    }
    sec = Number(sec)
    const h = Math.floor(sec / 3600)
    const m = Math.floor((sec % 3600) / 60)
    const s = Math.floor((sec % 3600) % 60)

    const hDisplay = h > 10 ? h : '0' + h
    const mDisplay = m > 10 ? m : '0' + m
    const sDisplay = s > 10 ? s : '0' + s
    return hDisplay + ':' + mDisplay + ':' + sDisplay
  },

  // imported from old ui
  timeRangeMilliseconds: msec => {
    if (msec === null || msec === undefined) {
      return ''
    }
    msec = Number(msec)
    const sec = msec / 1000
    let millis = (msec % 1000) + ''
    while (millis.length < 3) {
      millis = '0' + millis
    }

    return renderer.timeRangeSeconds(sec) + '.' + millis
  },

  bytesRenderer: bytes => {
    if (bytes === null || bytes === undefined) {
      return ''
    }

    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let unitsItr = 0
    while ((bytes >= 1000 || bytes <= -1000) && unitsItr < 3) {
      bytes = bytes / 1000
      unitsItr++
    }
    if (unitsItr !== 0) {
      bytes = (Math.round(bytes * 100) / 100).toFixed(1)
    }
    return '<b>' + bytes + '</b> ' + units[unitsItr]
  },

  bytesSecRenderer: bytes => {
    if (bytes === null || bytes === undefined) {
      return ''
    }

    const units = ['B/s', 'kB/s', 'MB/s', 'GB/s']
    let unitsItr = 0
    while ((bytes >= 1000 || bytes <= -1000) && unitsItr < 3) {
      bytes = bytes / 1000
      unitsItr++
    }
    if (unitsItr !== 0) {
      bytes = (Math.round(bytes * 100) / 100).toFixed(1)
    }
    return '<b>' + bytes + '</b> ' + units[unitsItr]
  },

  packetsRenderer: packets => {
    if (packets === null || packets === undefined) {
      return ''
    }

    const units = ['', 'K', 'M', 'B']
    let unitsItr = 0
    while ((packets >= 1000 || packets <= -1000) && unitsItr < 3) {
      packets = packets / 1000
      unitsItr++
    }
    if (unitsItr !== 0) {
      packets = (Math.round(packets * 100) / 100).toFixed(1)
    }
    return '<b>' + packets + '</b> ' + units[unitsItr]
  },

  packetsSecRenderer: packets => {
    if (packets === null || packets === undefined) {
      return ''
    }

    const units = ['/s', 'K/s', 'M/s', 'B/s']
    let unitsItr = 0
    while ((packets >= 1000 || packets <= -1000) && unitsItr < 3) {
      packets = packets / 1000
      unitsItr++
    }
    if (unitsItr !== 0) {
      packets = (Math.round(packets * 100) / 100).toFixed(1)
    }
    return '<b>' + packets + '</b> ' + units[unitsItr]
  },

  familyRenderer: value => {
    return families[value] || value
  },

  interfaceType: value => {
    let type = ''
    switch (value) {
      case 1:
        type = 'WAN'
        break
      case 2:
        type = 'LAN'
        break
      case 3:
        type = i18n.t('unused')
        break
      default:
        type = i18n.t('unset')
    }
    return type
  },

  country: value => {
    return countryCodes[value]
  },

  tcpStateRenderer: value => {
    if (value === null || value === undefined) {
      return ''
    }
    // Added TCP_State's -1, 0 indicates No State for the session
    // bcz it's Uninitialised
    switch (value) {
      case -1:
      case 0:
        return 'NO_STATE'
      case 1:
        return 'SYN_SENT'
      case 2:
        return 'SYN_RECV'
      case 3:
        return 'ESTABLISHED'
      case 4:
        return 'FIN_WAIT'
      case 5:
        return 'CLOSE_WAIT'
      case 6:
        return 'LAST_ACK'
      case 7:
        return 'TIME_WAIT'
      case 8:
        return 'CLOSE'
      case 9:
        return 'SYN_SENT2'
      case 10:
        return 'MAX'
      case 11:
        return 'IGNORE'
      default:
        return value
    }
  },

  priorityNumToText: priority => {
    const textPriority = priorities[priority?.toString()]
    return i18n.t(textPriority)
  },

  incomingThreatLevel: level => {
    if (level === null || level === undefined) return ''
    level = parseInt(level)
    if (level > 0 && level <= 20) return i18n.t('high_risk')
    if (level > 20 && level <= 40) return i18n.t('suspicious')
    if (level > 40 && level <= 60) return i18n.t('moderate_risk')
    if (level > 60 && level <= 80) return i18n.t('low_risk')
    return i18n.t('trustworthy')
  },

  outgoingThreatLevel: level => {
    return outgoingThreatLevels[level]
  },

  // get the license limit (seats) in a human readable format
  licenseText: license =>
    license?.seats
      ? license.seats === 1000000
        ? i18n.t('unlimited')
        : `${license.seats} ${i18n.t('mbps')}`
      : i18n.t('not_licensed'),

  // returns the human readable reason of blocking/passing web filter
  webfilterReason: value => {
    let reason
    switch (value) {
      case 0:
        reason = i18n.t('web_filter_reason_pass_category')
        break
      case 1:
        reason = i18n.t('web_filter_reason_block_category')
        break
      case 2:
        reason = i18n.t('web_filter_reason_block_list')
        break
      case 3:
        reason = i18n.t('web_filter_reason_pass_list')
        break
    }
    return reason
  },

  // returns the category if blocked or passed via category
  webfilterCategory: catid => {
    if (catid === -1) return ''
    const cat = categories.find(c => c.id === catid)
    if (!cat) return ''
    return i18n.t(cat.name)
  },

  applicationProductivityLevel: value => i18n.t(productivityLevels[value]),

  applicationRiskLevel: value => i18n.t(riskLevels[value]),
}

export default renderer
