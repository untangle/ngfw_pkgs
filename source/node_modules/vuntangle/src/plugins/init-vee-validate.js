import { extend, setInteractionMode } from 'vee-validate'
import {
  required,
  email,
  alpha,
  max,
  min,
  confirmed,
  excluded,
  min_value as minValue,
  max_value as maxValue,
  integer,
  numeric,
  regex,
} from 'vee-validate/dist/rules'
import i18n from './vue-i18n'
import util from './util'
import net from './net'

const digitsRegex = /^[0-9]*$/
const portValidate = value =>
  digitsRegex.test(value) && minValue.validate(value, { min: 1 }) && maxValue.validate(value, { max: 65535 })
const vlanTagValidate = value =>
  digitsRegex.test(value) && minValue.validate(value, { min: 1 }) && maxValue.validate(value, { max: 4094 })
const macAddressRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/

export default function () {
  /**
   * Setting global validation integration mode
   *
   * there are 4 predefined validation integration modes
   * - aggressive (default)
   * - lazy
   * - passive
   * - eager
   *
   * "eager" mode seems to be most suitable
   */
  setInteractionMode('eager')

  extend('alpha', {
    ...alpha,
    message: (_, values) => i18n.t('alpha', values),
  })

  /**
   * Check the string only contains numbers, letters, dashes, underscores, and periods.
   */
  extend('alpha_dash_period', {
    validate: value => /^[a-zA-Z0-9-_.]+$/.test(value),
    message: (_, values) => i18n.t('alpha_dash_period', values),
  })

  /**
   * Check the string only contains numbers, letters, dashes, asterisks, and periods.
   */
  extend('alpha_star_period', {
    validate: value => /^[a-zA-Z0-9-.*]+$/.test(value),
    message: (_, values) => i18n.t('alpha_star_period', values),
  })

  extend('cidr', {
    validate: value => util.isIPv4AddressValid(value, true),
    message: (_, values) => i18n.t('cidr_validation', values),
  })

  extend('confirmed', {
    ...confirmed,
    message: (_, values) => i18n.t('confirmed', values),
  })

  extend('email', {
    validate: value => util.validateEmail(value) && !value.includes('&'),
    message: (_, values) => i18n.t('email', values),
  })

  /**
   * This validates a comma separated list of emails.
   */
  extend('email_comma_list', {
    validate(value) {
      const emails = value.split(',')
      for (const emailInput of emails) {
        if (!email.validate(emailInput.trim()) || value.includes('&')) {
          return false
        }
      }

      return true
    },
    message: (_, values) => i18n.t('email_comma_list', values),
  })

  extend('integer', {
    ...integer,
    message: (_, values) => i18n.t('integer', { value: values }),
  })

  extend('numeric', {
    ...numeric,
    message: (_, values) => i18n.t('numeric', { value: values }),
  })

  extend('ip', {
    params: ['multiple'],
    validate: (value, { multiple = false }) => {
      const list = multiple ? value.split(',') : [value]
      for (const item of list) {
        if (!util.isIPv4AddressValid(item.trim())) {
          return i18n.t('ip_v4_invalid')
        }
      }
      return true
    },
  })

  extend('ip_any', {
    validate: value => util.isIPv4AddressValid(value) || util.isIPv6AddressValid(value),
    message: (_, values) => i18n.t('ip_any', values),
  })

  /**
   * Validates Ipv4 or Ipv6 with or without CIDR
   *
   * | Name | Example | Description |
   * | Single Value | 1.2.3.4 | matches a single value |
   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |
   */
  extend('ip_any_cidr', {
    validate: value =>
      util.isIPv4AddressValid(value) ||
      util.isIPv6AddressValid(value) ||
      util.isIPv4AddressValid(value, true) ||
      util.isIPv6AddressValid(value, true),
    message: (_, values) => i18n.t('ip_any', values),
  })

  /**
   * Validates list Ipv4 or Ipv6 addresses with or without CIDR
   *
   * | Name | Example | Description |
   * | Single Value | 1.2.3.4 | matches a single value |
   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |
   * | List | 1.2.3.4,1.2.3.3/16 | matches any IP in the list |
   */
  extend('ip_any_cidr_list', {
    validate: value => {
      const list = value.split(',')
      for (const item of list) {
        const trimmedItem = item.trim()
        const isValidIPv4 = util.isIPv4AddressValid(trimmedItem) || util.isIPv4AddressValid(trimmedItem, true)
        const isValidIPv6 = util.isIPv6AddressValid(trimmedItem) || util.isIPv6AddressValid(trimmedItem, true)

        if (!(isValidIPv4 || isValidIPv6)) {
          return i18n.t('ip_any_list', [item])
        }
      }
      return true
    },
  })

  /**
   * Validates list of IP Addresses that are Ipv4 or Ipv6.
   *
   * | Name | Example | Description |
   * | Single Value | 1.2.3.4 | matches a single value |
   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |
   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |
   * | List | 1.2.3.4/24,1.2.3.5,1.2.3.5-1.2.3.8,2404:0068:0000:0000:0000:0000:0000:0000-2404:0068:0000:0000:0000:0000:0000:0001  | matches any IP that matches any IPv4 or IPv6 Expression in the list |
   */
  extend('ip_any_expression_cidr_list', value => {
    const list = value.split(',')
    for (const item of list) {
      const range = item.split('-')
      if (range.length > 2) {
        return i18n.t('ip_range', [item])
      }
      const [rangeStart, rangeEnd] = range
      const trimmedRangeStart = rangeStart.trim()
      const trimmedRangeEnd = rangeEnd && rangeEnd.trim()

      // validate single IP
      if (range.length === 1) {
        const isStartValidIPv4 =
          util.isIPv4AddressValid(trimmedRangeStart) || util.isIPv4AddressValid(trimmedRangeStart, true)
        const isStartValidIPv6 =
          util.isIPv6AddressValid(trimmedRangeStart) || util.isIPv6AddressValid(trimmedRangeStart, true)

        if (!(isStartValidIPv4 || isStartValidIPv6)) {
          return i18n.t('ip_any_list', [rangeStart])
        }

        continue
      }

      // validate IP range

      // start of range cannot be a CIDR address
      if (util.isIPv4AddressValid(trimmedRangeStart, true) || util.isIPv6AddressValid(trimmedRangeStart, true)) {
        return i18n.t('no_cidr_in_range', [rangeStart])
      }

      // validate start ip is correct format
      const isStartValidIPv4 = util.isIPv4AddressValid(trimmedRangeStart)
      const isStartValidIPv6 = util.isIPv6AddressValid(trimmedRangeStart)
      if (!(isStartValidIPv4 || isStartValidIPv6)) {
        return i18n.t('ip_any_list', [rangeEnd])
      }

      // end of range cannot be a CIDR address
      if (util.isIPv4AddressValid(trimmedRangeEnd, true) || util.isIPv6AddressValid(trimmedRangeEnd, true)) {
        return i18n.t('no_cidr_in_range', [rangeEnd])
      }

      // validate end ip is correct format
      const isEndValidIPv4 = util.isIPv4AddressValid(trimmedRangeEnd)
      const isEndValidIPv6 = util.isIPv6AddressValid(trimmedRangeEnd)
      if (!(isEndValidIPv4 || isEndValidIPv6)) {
        return i18n.t('ip_any_list', [rangeEnd])
      }

      // make sure start and end of range are the same version
      if ((isStartValidIPv4 && !isEndValidIPv4) || (!isStartValidIPv4 && isEndValidIPv4)) {
        return i18n.t('ip_range_same_version', [rangeStart, rangeEnd])
      }

      // make sure start IP is less than end IP
      if (isStartValidIPv4 && isEndValidIPv4 && !util.isIPv4RangeValid(trimmedRangeStart, trimmedRangeEnd)) {
        return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])
      }
      if (isStartValidIPv6 && isEndValidIPv6 && !util.isIPv6RangeValid(trimmedRangeStart, trimmedRangeEnd)) {
        return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])
      }
    }
    return true
  })

  /**
   * Ensure all IPs in a list are unique. Assumes IPs are valid
   */
  extend('ip_list_unique', value => {
    const list = value.split(',')
    let nonUniqueIP = ''
    const allItemsUnique = list.every((ip, index) => {
      const trimmedIP = ip.trim()
      const isUnique = list.every((otherIP, otherIndex) => otherIndex === index || otherIP.trim() !== trimmedIP)
      if (!isUnique) {
        nonUniqueIP = ip
      }
      return isUnique
    })
    if (!allItemsUnique) {
      return i18n.t('ip_unique', [nonUniqueIP])
    }
    return true
  })

  /**
   * Validates a field value against a provided list of values, to be unique (not found in the list)
   * If not unique (found in the list) provided translated message will be shown
   * Usage:
   *   <ValidationProvider v-slot="{ errors }" :rules="{ unique_insensitive: { list: [], message: $t('xx') } }">
   *   </ValidationProvider>
   */
  extend('unique_insensitive', {
    params: ['list', 'message'],
    validate(value, { list, message }) {
      if (!list && !list.length) {
        return true
      }
      // convert values to lowercase so the check is not case sensitive
      const listLowerCase = list.map(name => name.toLowerCase())

      // return the error message in case not unique
      if (listLowerCase.includes(value.toLowerCase())) {
        return message
      }
      return true
    },
  })

  /**
   * Validates Ipv4 expression.
   *
   * | Name | Example | Description |
   * | Single Value | 1.2.3.4 | matches a single value |
   * | Range | 1.2.3.4-1.2.3.100 | matches any IP in the range |
   * | CIDR subnet | 1.2.3.4/24 | matches any IP in the subnet |
   * | List | 1.2.3.4/24,1.2.3.5-1.2.3.8 | matches any IP that matches any IPv4 Expression in the list |
   */
  extend('ip_expression', {
    params: ['multiple'],
    /**
     * @param {string} value - the value to validate
     * @param {boolean} multiple - flag to control if value is comma separated or not
     * @returns {string|boolean} - validation result
     */
    validate(value, { multiple = true }) {
      const list = multiple ? value.split(',') : [value]
      for (const item of list) {
        // check for an invalid range
        const range = item.split('-')
        if (range.length > 2) {
          return i18n.t('ip_range', [item])
        }

        // check if IP was not inputted
        const [rangeStart, rangeEnd] = range
        if (!rangeStart.trim()) {
          return range.length === 2 ? i18n.t('ip_range', [item]) : i18n.t('ip_v4_invalid')
        }

        // check invalid IPv4 (with or without subnet)
        if (!util.isIPv4AddressValid(rangeStart.trim()) && !util.isIPv4AddressValid(rangeStart.trim(), true)) {
          return i18n.t('ip_value', [rangeStart])
        }

        // continue if range was not entered
        if (range.length === 1) {
          continue
        }

        // check if range end was not set
        if (!rangeEnd.trim()) {
          return i18n.t('ip_range', [item])
        }

        // check invalid IPv4 range end (with or without subnet)
        if (!util.isIPv4AddressValid(rangeEnd.trim()) && !util.isIPv4AddressValid(rangeEnd.trim(), true)) {
          return i18n.t('ip_value', [rangeEnd])
        }

        // if both range ips exists and are valid, check the range being valid rangeStart < rangeEnd
        if (!util.isIPv4RangeValid(rangeStart.trim(), rangeEnd.trim())) {
          return i18n.t('ip_range_end_lessthan_start', [rangeStart, rangeEnd])
        }
      }

      return true
    },
  })

  extend('ip_v6', {
    params: ['multiple'],
    validate: (value, { multiple = false }) => {
      const list = multiple ? value.split(',') : [value]
      for (const item of list) {
        if (!util.isIPv6AddressValid(item.trim())) {
          return i18n.t('ip_v6')
        }
      }
      return true
    },
  })

  /**
   * Validates Ipv6 expression.
   *
   * | Name | Example | Description |
   * | Single Value | 2001:db8:85a3:0:0:8a2e:370:7334 | matches a single value |
   * | Range | 2001:db8::-2001:db9:: | matches any IP in the range |
   * | CIDR subnet | 2001:db8::/64 | matches any IP in the subnet |
   * | List | 2001:db8::/64,2001:db8::-2001:db9:: | matches any IP that matches any IPv6 Expression in the list |
   */
  extend('ip_v6_expression', value => {
    const list = value.split(',')
    for (const item of list) {
      // check for an invalid range
      const range = item.split('-')
      if (range.length > 2) {
        return i18n.t('ip_v6_range', [item])
      }

      // check if IP was not inputted
      const [rangeStart, rangeEnd] = range
      if (!rangeStart.trim()) {
        return range.length === 2 ? i18n.t('ip_v6_range', [item]) : i18n.t('ip_v6')
      }

      // check invalid IPv6 (with or without subnet)
      if (!util.isIPv6AddressValid(rangeStart.trim()) && !util.isIPv6AddressValid(rangeStart.trim(), true)) {
        return i18n.t('ip_v6_value', [rangeStart])
      }

      // continue if range was not entered
      if (range.length === 1) {
        continue
      }

      // check if range end was not set
      if (!rangeEnd.trim()) {
        return i18n.t('ip_v6_range', [item])
      }

      // check invalid IPv6 range end (with or without subnet)
      if (!util.isIPv6AddressValid(rangeEnd.trim()) && !util.isIPv6AddressValid(rangeEnd.trim(), true)) {
        return i18n.t('ip_v6_value', [rangeEnd])
      }
    }

    return true
  })

  extend('mac_address', {
    validate: value => macAddressRegex.test(value),
    message: (_, values) => i18n.t('mac_address_validation', values),
  })

  extend('max', {
    ...max,
    message: (_, values) => i18n.t('max', values),
  })

  extend('max_value', {
    ...maxValue,
    message: (_, values) => i18n.t('max_value', { value: values.max }),
  })

  extend('min', {
    ...min,
    message: (_, values) => i18n.t('min', values),
  })

  /**
   * General validation function to check the minimum and maximum of minutes and/or hours.
   */
  extend('min_max_hours_minutes', {
    params: ['min', 'max', 'minutes', 'hours'],

    /**
     * Validate minutes and hours input are between a minimum minutes/hours and a maximum hours/minutes.  Used in
     * the inactivity logout period user account setting.
     *
     * @param {string} value    value of current field being changed, not really needed
     * @param {string} min      min value with 'M' or 'H' postfix for hours or minutes
     * @param {string} max      max value with 'M' or 'H' postfix for hours or minutes
     * @param {string} minutes  minutes inputted
     * @param {string} hours    hours inputted
     *
     * @returns {boolean}
     */
    validate(value, { min, max, minutes, hours }) {
      // convert everything to minutes
      const minMinutes = min.substr(-1).toUpperCase() === 'H' ? parseInt(min.slice(0, -1)) * 60 : parseInt(min)
      const maxMinutes = max.substr(-1).toUpperCase() === 'H' ? parseInt(max.slice(0, -1)) * 60 : parseInt(max)
      const inputMinutes = parseInt(hours, 10) * 60 + parseInt(minutes, 10)

      return inputMinutes >= minMinutes && inputMinutes <= maxMinutes
    },
    message: (_, { min, max }) => {
      const minValue = min.slice(0, -1)
      const maxValue = max.slice(0, -1)

      return i18n.t('min_max_hours_minutes', {
        minValue,
        minType:
          min.substr(-1).toUpperCase() === 'H'
            ? i18n.tc('hours', minValue).toLocaleLowerCase()
            : i18n.tc('minutes', minValue).toLocaleLowerCase(),
        maxValue,
        maxType:
          max.substr(-1).toUpperCase() === 'H'
            ? i18n.tc('hours', maxValue).toLocaleLowerCase()
            : i18n.tc('minutes', maxValue).toLocaleLowerCase(),
      })
    },
  })

  extend('min_value', {
    ...minValue,
    message: (_, values) => i18n.t('min_value', { value: values.min }),
  })

  /**
   * Check the string does not start with a period.  Used for hostname.
   */
  extend('not_start_period', {
    validate: value => value.charAt(0) === '.',
    message: (_, values) => i18n.t('not_start_period', values),
  })

  extend('phone', {
    validate(value) {
      // allows empty phone number
      if (value === null || value === '') {
        return true
      }
      // Number between 7 and 18 digits and it may contain symbols like: .()+- and spaces
      const pattern = new RegExp("^[0-9-.()+/'.\\s]{7,18}$")
      // trim whitespace and .()+- before and after the value
      if (pattern.test(value)) {
        value = value.replace(/\D/g, '')
        return true
      }
    },
    message: (_, values) => i18n.t('invalid_phone', values),
  })

  extend('port', {
    validate: portValidate,
    message: (_, values) => i18n.t('port_validation', values),
  })

  /**
   * Validates that the value is a proper port value, range, or list.
   */
  extend('port_expression', value => {
    const list = value.split(',')
    for (const item of list) {
      // check for an invalid range
      const range = item.split('-')
      const [rangeStart, rangeEnd] = range
      if (range.length > 2) {
        return i18n.t('port_range', [item])
      }

      // check if range start or port was not set
      if (!rangeStart.trim()) {
        return range.length === 2 ? i18n.t('port_range', [item]) : i18n.t('port_validation')
      }

      // check invalid starting port
      if (!portValidate(rangeStart.trim())) {
        return i18n.t('port_value', [rangeStart])
      }

      // continue if range was not entered
      if (range.length === 1) {
        continue
      }

      // check if range end was not set
      if (!rangeEnd.trim()) {
        return i18n.t('port_range', [item])
      }

      // check invalid port range end
      if (!portValidate(rangeEnd.trim())) {
        return i18n.t('port_value', [rangeEnd])
      }

      // check if start range value greater than end range value
      if (parseInt(rangeStart) > parseInt(rangeEnd)) {
        return i18n.t('port_range', [item])
      }
    }

    return true
  })

  extend('regex', {
    params: [...regex.params, 'translationKey'],
    validate: regex.validate,
    message: (_, { translationKey }) => i18n.t(translationKey),
  })

  /**
   * As opposed to the above, this simply checks if the text can be turned into a regular expression without errors.
   * It returns nothing about the regular expression itself (assuming it is valid)
   */
  extend('valid_regex', {
    validate(value) {
      let isValid = true
      try {
        RegExp(value)
      } catch (e) {
        isValid = false
      }
      return isValid
    },
    message: i18n.t('valid_regex'),
  })

  extend('required', {
    ...required,
    message: (_, values) => i18n.t('required', values),
  })

  /**
   * This validates an appliance UID
   */
  extend('uid', {
    validate(value) {
      // format validation for adding a ngfw appliance via uid
      const uidMatch = new RegExp(/\b([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})\b/g)
      // format validation for adding a MRW or WAF appliances via uid
      const guidMatch = new RegExp(
        /\b([A-Fa-f0-9]{8})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{4})-([A-Fa-f0-9]{12})\b/g,
      )
      return uidMatch.test(value) || guidMatch.test(value)
    },
    message: (_, values) => i18n.t('uid', values),
  })

  extend('unique', {
    ...excluded,
    message: (_, values) => i18n.t('unique', values),
  })

  extend('url', {
    validate(value) {
      // format validation that accepts URL with user:password in it
      const urlMatch = new RegExp(
        /^(https?:\/\/)?((([a-zA-Z0-9_\-.]+):([a-zA-Z0-9_\-.]+)@)?([a-zA-Z0-9_\-.]+))(:\d+)?(\/[^\s]*)?$/,
      )
      return urlMatch.test(value)
    },
    message: (_, values) => i18n.t('url', values),
  })

  extend('domain', {
    validate(value) {
      const re = /^(?!-)(?!.*-\.)([a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,}$/

      return re.test(value)
    },
    message: (_, values) => i18n.t('domain_validation', values),
  })

  extend('serial', {
    validate(value) {
      if (value.length < 11) {
        // Serial numbers are either 11 (q series) characters or 14 (all others)
        return false
      }
      // format validation for adding a Q Series via serial number
      const qSeriesMatch = new RegExp(/^CTW+\d{8}$/g, 'i')
      if (qSeriesMatch.test(value)) {
        return true
      }
      // if not a q series, check for formatting of others
      const val = value.replace(/-/g, '') // replace dashes that were used for old serial numbers
      if (val.length !== 14) {
        // Serial numbers length is exactly 14 characters
        return false
      }
      if (!new RegExp('^0[1-9]|1[0-2]$').test(val.substring(0, 2))) {
        // First 2 characters represent the month. Allowed: 01-12 / for zSeries, first 2 chars are 02
        return false
      }
      if (!new RegExp('^[0-9]{2}$').test(val.substring(2, 4))) {
        // Characters 3-4 represent the year. / for zSeries, they are 01
        return false
      }
      if (!new RegExp('^[1-9A-H]$').test(val.substring(4, 5))) {
        // Fifth character represents the model. Allowed: 1-9, and A-H
        return false
      }
      if (
        val.substring(5, 6) !== 'L' &&
        val.substring(5, 6) !== 'W' &&
        val.substring(5, 6) !== 'P' && // added for Z4Plus SN
        val.substring(5, 6) !== 'w' &&
        val.substring(5, 6) !== '0'
      ) {
        // Sixth character is the wireless flag. Allowed: L, W, w, 0 or P
        return false
      }
      if (!new RegExp('^[a-zA-Z]$').test(val.substring(6, 7))) {
        // Seventh character represents the revision. Allowed: a-z, A-Z
        return false
      }
      // Last 7 characters must all be numbers
      return new RegExp('^\\d{7}$').test(val.substring(7))
    },
    message: (_, values) => i18n.t('serial', values),
  })

  /**
   * This rule validates if the input is a valid host or ipv4.
   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked
   */
  extend('hostname', {
    validate(value) {
      return util.isHostnameValid(value)
    },
    message: () => i18n.t('hostname_ipv4'),
  })

  extend('hosts', {
    validate(value) {
      const isValid = value
        .split(',')
        .reduce((accumulator, currentValue) => accumulator + (util.isHostnameValid(currentValue.trim()) ? 0 : 1), 0)
      return isValid === 0
    },
    message: () => i18n.t('hostname_ipv4'),
  })

  /**
   * This rule validates if the input is a valid hostname, ipv4, or ipv6.
   * Technically an ipv4 address (incorrect values or not) could be a hostname so ipv4 isn't specifically checked
   */
  extend('hostname_ipv6', {
    validate(value) {
      return util.isHostnameValid(value) || util.isIPv6AddressValid(value)
    },
    message: () => i18n.t('hostname_ipv6'),
  })

  /**
   * Validate a website url domain matches an email address domain.
   *
   * @param {string} url
   * @param {string} email
   *
   * @returns {boolean}
   */
  extend('website_domain_match_email_domain', {
    params: ['email'],
    validate(url, { email }) {
      // make sure the email field was loaded
      if (email === undefined) {
        return true
      }

      // try to parse url from URL object
      let urlObj
      try {
        urlObj = new URL(url)
      } catch (ex) {
        urlObj = null
      }

      // get domain from URL object
      let websiteDomain = ''
      if (urlObj) {
        // if the hostname is 3 parts, remove the first part (ie. www)
        const hostnameParts = urlObj.hostname.split('.')
        websiteDomain = hostnameParts.length === 3 ? `${hostnameParts[1]}.${hostnameParts[2]}` : urlObj.hostname
      }

      // check website domain against email domain
      return websiteDomain === email.split('@').pop()
    },
    message: i18n.t('website_domain_must_match_email_domain'),
  })

  /**
   * This rule validates if the host IP falls in available hosts range
   * defined by an IP and CIDR
   */
  extend('host_in_range', {
    params: ['ip', 'cidr'],
    /**
     * @param {string} value - the host IP to be checked
     * @param {string} ip - the interface v4 static address
     * @param {number} cidr - the interface v4 static prefix
     * @returns {boolean}
     */
    validate(value, { ip, cidr }) {
      return net.isHostInRange(ip, cidr, value)
    },
    message: () => i18n.t('host_not_in_range'),
  })

  /**
   * This rule validates if DHCP hosts range is valid
   */
  extend('dhcp_range', {
    params: ['rangeStart', 'rangeEnd'],
    /**
     * @param {string} value - the host IP value
     * @param {string} rangeStart - the DHCP range first host
     * @param {string} rangeEnd - the DHCP range last host
     * @returns {boolean}
     */
    validate(value, { rangeStart, rangeEnd }) {
      if (rangeStart) return net.isValidDhcpRange(rangeStart, value)
      if (rangeEnd) return net.isValidDhcpRange(value, rangeEnd)
    },
    message: () => i18n.t('invalid_dhcp_range'),
  })

  /**
   * Password validator rule
   * it builds up a reg expression to which password is tested against
   * Validator supports:
   * - min chars for the password/secret
   * - min 1 digit
   * - min 1 uppercase letter
   * - min 1 lowercase letter
   * - min one special char from: @#$%^&*
   *
   * Sample usage
   * <ValidationProvider :rules="{ password: { minChars: 6, digit: true, special: false, uppercase: true, lowercase: true } }">
   */
  extend('password', {
    params: ['minChars', 'digit', 'special', 'uppercase', 'lowercase'],
    /**
     * @param {string} value - the password/secret
     * @param {number} minChars - the minimum length of the password
     *
     * @param {boolean} digit - require at least min 1 digit
     * @param {boolean} special - require at least 1 special character
     * @param {boolean} uppercase - require at least 1 Uppercase letter
     * @param {boolean} lowercase - require at least 1 lowercase letter
     * @returns {boolean}
     */
    validate(value, { minChars, digit, special, uppercase, lowercase }) {
      let re = '[a-zA-Z\\d!@#$%^&*\\s]'
      const digitRe = '(?=.*\\d)'
      const specialRe = '(?=.*[!@#$%^&*])'
      const upperRe = '(?=.*[A-Z])'
      const lowerRe = '(?=.*[a-z])'

      if (digit) re = digitRe + re
      if (special) re = specialRe + re
      if (minChars > 0) re = re + `{${minChars},}`
      if (uppercase) re = upperRe + re
      if (lowercase) re = lowerRe + re

      const reg = new RegExp(`^${re}$`)
      return reg.test(value)
    },
    message: (_, { minChars, digit, special, uppercase, lowercase }) => {
      let message = i18n.t('password_validation')

      // builds up an unordered message list with requirements
      message += '<ul>'
      if (minChars > 0) message += '<li>' + i18n.t('password_min_chars', [minChars]) + '</li>'
      if (digit) message += '<li>' + i18n.t('password_digit') + '</li>'
      if (uppercase) message += '<li>' + i18n.t('password_uppercase') + '</li>'
      if (lowercase) message += '<li>' + i18n.t('password_lowercase') + '</li>'
      if (special) message += '<li>' + i18n.t('password_special') + '</li>'
      message += '<li>' + i18n.t('password_special_list', ['!@#$%^&*']) + '</li>'
      message += '</ul>'

      return message
    },
  })

  /**
   * Validates that the value is a proper VLAN Tag value, range, or list.
   */
  extend('vlan_tag_expression', {
    params: ['multiple'],
    /**
     * @param {string} value - the value to validate
     * @param {boolean} multiple - flag to control if value is comma separated or not
     * @returns {string|boolean} - validation result
     */
    validate(value, { multiple = true }) {
      const list = multiple ? value.split(',') : [value]
      for (const item of list) {
        // check for an invalid range
        const range = item.split('-')
        const [rangeStart, rangeEnd] = range
        if (range.length > 2) {
          return i18n.t('vlan_tag_range', [item])
        }

        // check if range start or VLAN tag was not set
        if (!rangeStart.trim()) {
          return range.length === 2 ? i18n.t('vlan_tag_range', [item]) : i18n.t('vlan_tag_validation')
        }

        // check invalid starting vlan tag. Use the port regex as it's the same logic
        if (!vlanTagValidate(rangeStart.trim())) {
          return i18n.t('vlan_tag_value', [rangeStart])
        }

        // continue if range was not entered
        if (range.length === 1) {
          continue
        }

        // check if range end was not set
        if (!rangeEnd.trim()) {
          return i18n.t('vlan_tag_range', [item])
        }

        // check invalid VLAN tag range end
        if (!vlanTagValidate(rangeEnd.trim())) {
          return i18n.t('vlan_tag_value', [rangeEnd])
        }

        // check if start range value greater than end range value
        if (parseInt(rangeStart) > parseInt(rangeEnd)) {
          return i18n.t('vlan_tag_range', [item])
        }
      }

      return true
    },
  })

  // Validation rule for vlan network duplicate parent interface/vlanid
  extend('vlan_duplicate', {
    params: ['interfaceId', 'interfaces', 'boundInterfaceId', 'vlanId'],
    /**
     * @param {number} value - the bound interface id or vlan id
     * @param {number} interfaceId - current edited interface id (null if adding)
     * @param {array} interfaces - existing interfaces
     * @param {number|null} boundInterfaceId - the vlan bound interface
     * @param {number|null} vlanId - the vlan id
     * @returns {string|boolean}
     */
    validate(value, { interfaceId, interfaces, boundInterfaceId, vlanId }) {
      let invalid = false
      interfaces.forEach(intf => {
        // skip if editing or is not vlan or already found duplicate
        if (interfaceId === intf.interfaceId || intf.type !== 'VLAN' || invalid) return
        invalid =
          (!vlanId && intf.boundInterfaceId === boundInterfaceId && intf.vlanid === value) ||
          (!boundInterfaceId && intf.boundInterfaceId === value && intf.vlanid === vlanId)
      })
      return invalid ? i18n.t('vlan_duplicate_parent_vlan_id') : true
    },
  })

  // validates against local/remote gateway set both as 'any'
  extend('conflicting_any_gateways', {
    /**
     * @param {string} value
     * @param {string} local
     * @param {string} remote
     * @returns {boolean} validation result
     */
    params: ['local', 'remote'],
    validate(value, { local, remote }) {
      return !(local === '%any' && remote === '%any')
    },
    message: i18n.t('api_ipsec_local_remote_any'),
  })

  // validates bound interface address being set
  extend('disconnected_wan', {
    /**
     * @param {string} value
     * @param {Object} boundWan
     * @returns {boolean} validation result
     */
    params: ['boundWan'],
    validate(value, { boundWan }) {
      return !(value === 'wan' && boundWan?.address === '')
    },
    message: i18n.t('ipsec_disconnected_wan'),
  })

  // validate gateway IPs
  extend('validate_gateways', {
    /**
     * @param {string} value
     * @param {string} local
     * @param {string} remote
     * @returns {boolean} validation result
     */
    params: ['local', 'remote'],
    validate(value, { local, remote }) {
      return local !== remote
    },
    message: i18n.t('gateway_ip_conflict'),
  })

  extend('unique_wireguard_ipv4', {
    /**
     * @param {string} value
     * @param {string} allInterfaces
     * @returns {boolean} validationReult
     */
    params: ['allInterfaces', 'currentWireguardIntf'],
    validate(value, { allInterfaces, currentWireguardIntf }) {
      for (const currentInterface of allInterfaces) {
        if (
          currentInterface.type === 'WIREGUARD' &&
          currentInterface.interfaceId !== currentWireguardIntf.interfaceId
        ) {
          for (const wgAddress of currentInterface.wireguardAddresses) {
            if (wgAddress.address === value) {
              return i18n.t('ip_address_occupied', [currentInterface.name])
            }
          }
        }
      }
      return true
    },
  })

  extend('check_non_routeable_address', {
    validate(value) {
      return value !== '0.0.0.0'
    },
    message: i18n.t('deny_non_routeable_address'),
  })

  extend('check_static_route_metric', {
    validate(value) {
      return (
        digitsRegex.test(value) && minValue.validate(value, { min: 0 }) && maxValue.validate(value, { max: 4294967295 })
      )
    },
    message: i18n.t('invalid_static_route_metric'),
  })
}
