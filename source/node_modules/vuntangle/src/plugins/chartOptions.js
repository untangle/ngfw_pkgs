/**
 * Utilities for handling highcharts options
 */
import Highcharts from 'highcharts'
import merge from 'lodash/merge'
import i18n from './vue-i18n'
import renderer from './renderer'

// base options for the highcharts options
const fontFamily = 'Roboto, sans-serif'

// the generic base options used for all charts
const baseChartOptions = {
  chart: {
    animation: false,
    marginTop: 20,
    marginRight: 5,
    style: { fontFamily },
    type: 'pie', // to avoid initial xAxis cut-off for pies
    backgroundColor: 'transparent',
  },
  navigator: { enabled: false },
  rangeSelector: { enabled: false },
  scrollbar: { enabled: false },
  tooltip: {
    enabled: true,
    animation: false,
    outside: false,
    shared: true,
    followPointer: true,
    split: false,
    padding: 10,
    hideDelay: 0,
    backgroundColor: 'rgba(247, 247, 247, 0.95)',
    useHTML: true,
    xDateFormat: '%A, %b %e, %l:%M %p',
    headerFormat: `<p style="font-family: ${fontFamily};font-weight: bold; margin: 0 0 5px 0; color: #555;">
        {point.key}
      </p>`,
  },
  legend: {
    enabled: true,
    itemStyle: {
      fontFamily,
      fontSize: '11px',
      fontWeight: 300,
      width: '100px',
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
    },
    title: {
      style: { fontFamily },
    },
    labelFormatter() {
      return i18n.t(this.name)
    },
  },
  yAxis: {
    opposite: false,
    allowDecimals: false,
    gridLineColor: '#EEE',
    gridLineDashStyle: 'Dash',
    title: {
      align: 'high',
      offset: 0,
      reserveSpace: false,
      y: 3,
      rotation: 0,
      textAlign: 'left',
      style: {
        color: '#555',
        fontFamily,
        fontSize: '12px',
        fontWeight: 600,
      },
    },
    labels: {
      style: { fontFamily },
    },
  },
  plotOptions: {
    series: { animation: false },
    pie: { borderColor: '#fafafa' },
  },
  series: [],
}

/**
 * Get highcharts 'options'
 * @param {Object} report - report configuration
 * @param {Array} data - the report data
 * @param {Object} interfaceIdNameMap - the interface id-name map
 * @returns {Object}
 */
const getChartOptions = function (report, data, interfaceIdNameMap) {
  // get the colors for the series and rendering
  const colors = report.rendering.colors ? report.rendering.colors.replace(/ /g, '').split(',') : getDefaultColors()

  // get the series to determine the rendering
  const type = report.query.type
  const series =
    type === 'SERIES' || type === 'CATEGORIES_SERIES'
      ? getSeriesReportSeries(report, colors, data, interfaceIdNameMap)
      : getOtherReportSeries(report, colors, data)

  // get the highcharts options depending on the report type
  const reportTypeOptions =
    type === 'SERIES' || type === 'CATEGORIES_SERIES'
      ? getSeriesChartOptions(report.rendering, series.length)
      : getCategoriesChartOptions(report)

  // merge base options, dynamic options, report type options, colors, and series data
  return merge(
    {},
    baseChartOptions,
    {
      time: { useUTC: false },
      tooltip: {
        formatter(tooltip) {
          return tooltip.defaultFormatter.call(this, tooltip)
        },
        pointFormatter() {
          let format = `<span style="color: ${this.color}; margin-right: 2px;">\u25A0</span>
          <span style="font-weight: bold;">${renderer.shortenText(this.series.name)}</span> &rarr; `

          /**
           * NOTE:
           * `bytesRenderer` and `bytesSecRenderer` are already having units in it
           */
          switch (report.rendering?.units) {
            case 'bytes':
              format += renderer.bytesRenderer(this.y)
              break
            case 'bytes/s':
              format += renderer.bytesSecRenderer(this.y)
              break
            case 'ms':
              format += `${this.y.toFixed(2)} ${report.rendering?.units}`
              break
            default:
              format += `${this.y} ${report.rendering?.units}`
          }
          format += `<br/>`
          return format
        },
      },
    },
    reportTypeOptions,
    {
      colors,
      series,
    },
  )
}

function getDefaultColors() {
  const colors = [...Highcharts.getOptions().colors]

  // add untangle colors, move color order around
  // colors.push(vuetify.framework.theme.currentTheme.aristaBlue, colors[2], colors[1])
  // colors.splice(1, 2, vuetify.framework.theme.currentTheme.utGreen)

  return colors
}

/**
 * Get the highcharts series option for a 'series' report type.
 * @param {Object} report the report conf
 * @param {Array} colors
 * @param {Array} data
 * @param {Object} interfaceIdNameMap - the interface id-name map
 *
 * @returns {Array}
 */
function getSeriesReportSeries(report, colors, data, interfaceIdNameMap) {
  const series = {}
  let name = null

  data.forEach(point => {
    Object.keys(point).forEach(function (key) {
      if (key !== 'time_trunc') {
        name = key
        if (report.query?.queryCategories?.groupColumn === 'interface_id') {
          name = `${interfaceIdNameMap?.[key] || i18n.t('unknown')}  [${key}]`
        }
        if (!series[key]) {
          series[key] = { name: name !== '<nil>' ? name : i18n.t('unknown'), data: [] }
        } else {
          // null values get converted to 0 by default, unless `rendering.nulls` is true
          series[key].data.push([point.time_trunc, !report.rendering.nulls ? point[key] || 0 : point[key]])
        }
      }
    })
  })

  // sort by name before adding colors to keep graph legends consistent
  return Object.keys(series)
    .map(key => series[key])
    .sort((a, b) => (a.name === b.name ? 0 : String(a.name) > String(b.name) ? 1 : -1))
    .map((result, idx) => {
      const color = colors[idx] || colors[idx % colors.length]
      return Object.assign(result, {
        color,
        lineColor: color,
        fillColor: {
          linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
          stops: [
            [
              0,
              Highcharts.Color(color)
                .setOpacity(report.rendering?.topAreaOpacity || 0.7)
                .get('rgba'),
            ],
            [
              1,
              Highcharts.Color(color)
                .setOpacity(report.rendering?.bottomAreaOpacity || 0.1)
                .get('rgba'),
            ],
          ],
        },
      })
    })
}

/**
 * Get the highcharts series option for 'other' (non-series) report types.
 *
 * @param {Report} report - report conf
 * @param {Array}  colors
 * @param {Array}  data
 *
 * @returns {Array}
 */
function getOtherReportSeries(report, colors, data) {
  const normalizedData = []
  data.forEach(point => {
    const name = point[report.query.queryCategories.groupColumn] || i18n.t('unknown')
    normalizedData.push({
      name,
      y: point.value,
    })
  })

  let seriesData = []
  let others
  const slicesNumber = report.rendering?.slicesNumber || 10
  if (normalizedData.length > slicesNumber) {
    others = { name: 'Others', y: 0 }
    normalizedData.forEach((point, idx) => {
      if (idx >= slicesNumber) {
        others.y += point.y
      } else {
        seriesData.push(point)
      }
    })
  } else {
    seriesData = normalizedData
  }

  // sort data by value
  seriesData.sort((a, b) => (a.y === b.y ? 0 : a.y < b.y ? 1 : -1))

  // add others to the end of the data
  if (others) {
    seriesData.push(others)
  }

  // add colors
  seriesData.forEach((point, idx) => (point.color = colors[idx]))

  // return series data
  return [{ name: report.query.table.split(' ')[0], data: seriesData }]
}

/**
 * Get the highcharts options for a 'series' report type.
 * @param {Object} rendering - report rendering options
 * @param {Number} seriesLength
 * @returns {Object}
 */
function getSeriesChartOptions(rendering, seriesLength) {
  const plotOptions = {
    column: {
      stacking: rendering.stacking || undefined,
      colorByPoint: false,
      dataGrouping: {
        enabled: rendering.dataGroupingEnabled,
        approximation: rendering.dataGroupingApproximation,
        pointPadding: 0.2,
        groupPixelWidth: rendering.dataGroupingFactor * seriesLength,
      },
    },
  }

  const plotType = ['line', 'spline', 'area', 'areaspline']
  plotType.forEach(type => {
    plotOptions[type] = {
      lineWidth: rendering.lineWidth || 1,
      stacking: rendering.stacking || undefined,
      dashStyle: rendering.dashStyle || 'Solid',
      dataGrouping: {
        enabled: rendering.dataGroupingEnabled || true,
        approximation: rendering.dataGroupingApproximation || 'sum',
        groupPixelWidth: rendering.dataGroupingFactor * seriesLength || 30,
        dateTimeLabelFormats: {
          millisecond: ['%A, %b %e, %l:%M:%S.%L %p', '%A, %b %e, %l:%M:%S.%L %p', ' - %l:%M:%S.%L %p'],
          second: ['%A, %b %e, %l:%M:%S %p', '%A, %b %e, %l:%M:%S %p', ' - %l:%M:%S %p'],
          minute: ['%A, %b %e, %l:%M %p', '%A, %b %e, %l:%M %p', ' - %l:%M %p'],
          hour: ['%A, %b %e, %l:%M %p', '%A, %b %e, %l:%M %p', ' - %l:%M %p'],
          day: ['%A, %b %e, %Y', '%A, %b %e', ' - %A, %b %e, %Y'],
          week: ['Week from %A, %b %e, %Y', '%A, %b %e', ' - %A, %b %e, %Y'],
          month: ['%B %Y', '%B', ' - %B %Y'],
          year: ['%Y', '%Y', ' - %Y'],
        },
      },
    }
  })

  return {
    chart: {
      type: rendering.type,
      zoomType: 'x',
      marginBottom: undefined,
    },
    plotOptions,
    legend: {
      layout: 'horizontal',
      floating: true,
      align: 'center',
      y: 10,
    },
    xAxis: {
      style: { fontFamily },
      categories: undefined,
      dateTimeLabelFormats: {
        second: '%l:%M:%S %p',
        minute: '%l:%M %p',
        hour: '%l:%M %p',
        day: '%Y-%m-%d',
        week: '%e. %b',
        month: "%b '%y",
        year: '%Y',
      },
      labels: {
        style: { fontFamily },
        autoRotation: false,
      },
    },
    yAxis: {
      title: { text: i18n.t(rendering.units) || '' },
      labels: {
        style: { fontFamily },
        formatter() {
          return rendering.units === 'bytes' || rendering.units === 'bytes/s'
            ? renderer.bytesRenderer(this.value)
            : this.value
        },
      },
    },
  }
}

/**
 * Get the highcharts options for a 'categories' report type.
 * @param {Object} report - report config
 * @param {Object} report.rendering - rendering options
 * @returns {Object}
 */
const getCategoriesChartOptions = ({ rendering }) => ({
  chart: {
    type: rendering.type,
    zoomType: undefined,
  },
  plotOptions: {
    pie: {
      innerSize: (rendering.donutInnerSize || 0) + '%',
      borderWidth: rendering.borderWidth || 1,
      edgeColor: '#fafafa',
      edgeWidth: rendering.borderWidth || 1,
      size: '100%',
      dataLabels: {
        style: { fontFamily },
        distance: 10,
        formatter() {
          if (rendering.column === 'web_filter_catid') {
            // show web filter category name instead of category ID
            this.point.name = renderer.webfilterCategory(this.point.name)
          }
          return renderer.shortenText(this.point.name)
        },
      },
    },
    column: { colorByPoint: true },
  },
  legend: {
    layout: 'vertical',
    align: 'left',
    verticalAlign: 'top',
    floating: true,
    labelFormatter() {
      return `<strong>${renderer.shortenText(this.name)}</strong>`
    },
  },
  xAxis: {
    labels: {
      style: { fontFamily },
    },
    visible: rendering.type === 'column',
  },
  yAxis: {
    labels: {
      style: { fontFamily },
    },
    visible: rendering.type === 'column',
  },
})

export default { baseChartOptions, getChartOptions }
