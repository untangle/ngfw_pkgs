import {
  interfaceTypeOptionsAsString,
  productivityLevelOptions,
  riskLevelOptions,
  protocolOptions,
  daysOfWeekOptions,
  daysOfWeekOrder,
  protocols,
} from '../../constants'
import { ConditionTarget, ConditionType as Condition, OperatorType as Operator, Type } from './constants'

/**
 * Conditions configurations based on their type:
 *
 * operators [required] - array of possible operators for condition type
 * component [required] - the component used to edit the condition value
 * objectType [required if MATCH ops] - the object type associated with the condition for MATCH operators
 * objectGroupType [required if IN ops] - the object group type associated with the condition for IN operators
 * text [required] - the translation key of the condition
 * short_text [optional] - the translation key of the condition without prefix Source/Dest
 * target [required] - the condition target as SOURCE/DEST/OTHER
 * multiple [optional] - if true, multiple values can be selected from an select or autocomplete field
 */

export default Object.freeze({
  [Condition.Application]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Application',
    objectType: Type.ObjectApplication,
    objectGroupType: Type.ObjectApplicationGroup,
    text: 'application_object',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationName]: {
    operators: [Operator.Equal],
    component: 'Application',
    objectType: Type.ObjectApplicationControlList,
    objectGroupType: Type.ObjectApplicationControlListGroup,
    text: 'application_name',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationNameInferred]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'Application',
    objectType: Type.ObjectApplicationControlList,
    objectGroupType: Type.ObjectApplicationControlListGroup,
    text: 'application_name_inferred',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationCategory]: {
    operators: [Operator.Equal],
    component: 'Application',
    text: 'application_category',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationCategoryInferred]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'Application',
    text: 'application_category_inferred',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationProductivity]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: productivityLevelOptions,
    text: 'application_productivity',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationProductivityInferred]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: productivityLevelOptions,
    text: 'application_productivity_inferred',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationRisk]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: riskLevelOptions,
    text: 'application_risk',
    target: ConditionTarget.Other,
  },
  [Condition.ApplicationRiskInferred]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: riskLevelOptions,
    text: 'application_risk_inferred',
    target: ConditionTarget.Other,
  },

  [Condition.ClientAddress]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Address',
    objectType: Type.ObjectIpAddress,
    objectGroupType: Type.ObjectIpAddressGroup,
    text: 'source_address',
    short_text: 'address',
    target: ConditionTarget.Source,
  },
  // CD-4836: hide Address Type for now
  /*  [Condition.SourceAddressType]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: addressTypeOptions,
    text: 'source_address_type',
  }, */
  [Condition.ClientApplication]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Application',
    objectType: Type.ObjectApplication,
    objectGroupType: Type.ObjectApplicationGroup,
    text: 'source_application',
    short_text: 'application',
    target: ConditionTarget.Source,
  },
  [Condition.ClientDnsHint]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'DnsHint',
    objectType: Type.ObjectHostname,
    objectGroupType: Type.ObjectHostnameGroup,
    text: 'source_dns_cache',
    short_text: 'dns_cache',
    target: ConditionTarget.Source,
  },
  [Condition.ClientGeoIp]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Geoip',
    objectType: Type.ObjectGeoip,
    objectGroupType: Type.ObjectGeoipGroup,
    text: 'source_geoip',
    short_text: 'geoip',
    target: ConditionTarget.Source,
  },
  [Condition.SourceInterface]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Interface',
    text: 'source_interface_zone',
    short_text: 'interface',
    // For in/not in or match/not match we match on the Zone object. For ==/!= then we match on the name directly
    objectType: Type.ObjectInterfaceZone,
    objectGroupType: Type.ObjectInterfaceZoneGroup,
    target: ConditionTarget.Source,
  },
  [Condition.ClientInterfaceType]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: interfaceTypeOptionsAsString,
    text: 'source_interface_type',
    short_text: 'interface_type',
    target: ConditionTarget.Source,
  },
  [Condition.ClientPort]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'PortNumber',
    text: 'source_port',
    short_text: 'port',
    target: ConditionTarget.Source,
  },
  [Condition.ClientService]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'ValueObject',
    objectType: Type.ObjectService,
    objectGroupType: Type.ObjectServiceGroup,
    text: 'source_service',
    short_text: 'service',
    target: ConditionTarget.Source,
  },

  [Condition.ServerAddress]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Address',
    objectType: Type.ObjectIpAddress,
    objectGroupType: Type.ObjectIpAddressGroup,
    text: 'destination_address',
    short_text: 'address',
    target: ConditionTarget.Destination,
  },
  // CD-4836: hide Address Type for now
  /*  [Condition.DestinationAddressType]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: addressTypeOptions,
    text: 'destination_address_type',
  }, */
  [Condition.ServerApplication]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Application',
    objectType: Type.ObjectApplication,
    objectGroupType: Type.ObjectApplicationGroup,
    text: 'destination_application',
    short_text: 'application',
    target: ConditionTarget.Destination,
  },
  [Condition.ServerDnsHint]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'DnsHint',
    objectType: Type.ObjectHostname,
    objectGroupType: Type.ObjectHostnameGroup,
    text: 'destination_dns_cache',
    short_text: 'dns_cache',
    target: ConditionTarget.Destination,
  },
  [Condition.ServerGeoIp]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Geoip',
    objectType: Type.ObjectGeoip,
    objectGroupType: Type.ObjectGeoipGroup,
    text: 'destination_geoip',
    short_text: 'geoip',
    target: ConditionTarget.Destination,
  },
  [Condition.DestinationInterface]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Interface',
    text: 'destination_interface_zone',
    short_text: 'interface',
    // For in/not in or match/not match we match on the Zone object. For ==/!= then we match on the name directly
    objectType: Type.ObjectInterfaceZone,
    objectGroupType: Type.ObjectInterfaceZoneGroup,
    target: ConditionTarget.Destination,
  },
  [Condition.ServerInterfaceType]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: interfaceTypeOptionsAsString,
    text: 'destination_interface_type',
    short_text: 'interface_type',
    target: ConditionTarget.Destination,
  },
  [Condition.ServerPort]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'PortNumber',
    text: 'destination_port',
    short_text: 'port',
    target: ConditionTarget.Destination,
  },
  [Condition.ServerService]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'ValueObject',
    objectType: Type.ObjectService,
    objectGroupType: Type.ObjectServiceGroup,
    text: 'destination_service',
    short_text: 'service',
    target: ConditionTarget.Destination,
  },

  // temporarily removed these conditions part of CD-4814
  /*
  [Condition.UnoApplicationName]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueText',
    text: 'uno_application_name',
  },
  [Condition.UnoServiceName]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueText',
    text: 'uno_service_name',
  },
  [Condition.UnoHostname]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueText',
    text: 'uno_hostname',
  },

  [Condition.AgniUserId]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueText',
    text: 'agni_user_id',
  },
  [Condition.AgniUserGroup]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueText',
    text: 'agni_user_group',
  },
  */
  [Condition.IpProtocol]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueAutocomplete',
    values: protocolOptions,
    multiple: true,
    text: 'ip_protocol',
    target: ConditionTarget.Other,
    // alpha sort protocols
    sorter: data => data.sort((a, b) => (protocols[a]?.toUpperCase() < protocols[b]?.toUpperCase() ? -1 : 1)),
  },
  // CD-4834: hide Limit Rate for now
  /*  [Condition.LimitRate]: {
    operators: [Operator.Greater, Operator.GreaterOrEqual, Operator.Less, Operator.LessOrEqual],
    component: 'LimitRate',
    text: 'limit_rate',
  }, */

  // new conditions

  // CD-4833: hide Hostname condition for now
  /*  [Condition.Hostname]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'Hostname',
    objectType: Type.ObjectHostname,
    objectGroupType: Type.ObjectHostnameGroup,
    text: 'hostname',
  }, */

  [Condition.User]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'ValueObject',
    objectType: Type.ObjectUser,
    objectGroupType: Type.ObjectUserGroup,
    text: 'user',
    target: ConditionTarget.Other,
  },

  [Condition.Service]: {
    operators: [Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'ValueObject',
    objectType: Type.ObjectService,
    objectGroupType: Type.ObjectServiceGroup,
    text: 'service',
    target: ConditionTarget.Other,
  },

  [Condition.VlanTag]: {
    operators: [Operator.Equal, Operator.NotEqual, Operator.Match, Operator.NotMatch, Operator.In, Operator.NotIn],
    component: 'VlanTag',
    objectType: Type.ObjectVlanTag,
    objectGroupType: Type.ObjectVlanTagGroup,
    text: 'vlan_tag',
    target: ConditionTarget.Other,
  },

  [Condition.DayOfWeek]: {
    operators: [Operator.Equal, Operator.NotEqual],
    component: 'ValueSelect',
    values: daysOfWeekOptions,
    text: 'day_of_week',
    multiple: true,
    short_text: 'day_of_week',
    target: ConditionTarget.Other,
    // natural order weekdays sorter
    sorter: data => data.sort((a, b) => daysOfWeekOrder[a] - daysOfWeekOrder[b]),
  },

  [Condition.TimeOfDay]: {
    operators: [Operator.GreaterOrEqual, Operator.LessOrEqual, Operator.Greater, Operator.Less],
    component: 'ValueTime',
    text: 'time_of_day',
    short_text: 'time_of_day',
    target: ConditionTarget.Other,
  },
})
