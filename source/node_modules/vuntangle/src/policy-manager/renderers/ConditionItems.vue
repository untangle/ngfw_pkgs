<!--
  Component rendering a set of the condition items based on their SOURCE, DEST, OTHER belonging
-->
<template>
  <span style="word-break: break-word">
    <span v-for="(item, index) in items" :key="index">
      <span class="pm-condition-border">
        {{ withPrefix ? item.type : item.shortType }}
        <span class="font-weight-bold"> {{ item.op }} </span>
        <template v-if="item.value">{{ item.value }}</template>
        <template v-else-if="item.objects && item.objects.length">
          <span v-if="item.objects.length > 1">( </span>
          <span v-for="(obj, idx) in item.objects" :key="idx">
            <object-renderer :object="obj" />
            <span v-if="idx < item.objects.length - 1" class="text-uppercase font-weight-bold"> {{ $t('or') }} </span>
          </span>
          <span v-if="item.objects.length > 1"> )</span>
        </template>
        <template v-else><v-icon color="error" class="mb-1">mdi-help-box</v-icon></template>
      </span>
      <span v-if="index < items.length - 1" class="text-uppercase font-weight-bold">
        {{ $t('and') }}
        <br v-if="breakAnd" />
      </span>
    </span>
    <template v-if="any">
      <span v-if="hasGroupConditions">{{ $vuntangle.$t('with_group_conditions') }}</span>
      <span v-else>{{ any }}</span>
    </template>
  </span>
</template>
<script>
  import { ConditionTarget } from '../config/constants'
  import ObjectRenderer from './ObjectRenderer.vue'

  export default {
    components: { ObjectRenderer },
    props: {
      // the condition or multiple conditions items
      items: { type: Array, default: () => [] },
      // whether to use short type or long type name (e.g. 'Address' or 'Source Address')
      withPrefix: { type: Boolean, default: false },
      // whether to break line after ANDs, by default true for the grid cells
      breakAnd: { type: Boolean, default: false },
      // the condition target, e.g. SOURCE/DEST/OTHER
      target: { type: String, default: undefined },
      // whether to show `Any`
      useAny: { type: Object, default: () => ({ source: true, dest: true }) },
      // whether to show `With Group Conditions`
      hasGroupConditions: { type: Boolean, default: false },
    },
    computed: {
      /**
       * Returns `any` string based on target
       */
      any: ({ items, target, useAny, $i18n }) => {
        if (!items.length || (items.length === 1 && !items[0].type)) {
          if (target === ConditionTarget.Source && useAny.source) return $i18n.t('any_source')
          if (target === ConditionTarget.Destination && useAny.dest) return $i18n.t('any_destination')
          if (!target) return $i18n.t('any')
        }
      },
    },
  }
</script>
