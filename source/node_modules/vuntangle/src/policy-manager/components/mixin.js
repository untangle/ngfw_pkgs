import {
  mapData,
  filterConditionItems,
  conditionType,
  shortConditionType,
  equalsConditionValue,
  actionValue,
} from '../util'
import { Type, ActionType } from '../config/constants'
import { countryCodes } from '../../constants'

export default {
  props: {
    boxSettings: {
      type: Object,
      required: true,
    },
    fetching: {
      type: Boolean,
      default: false,
    },
  },

  computed: {
    policyManager: ({ boxSettings }) => boxSettings.policy_manager,
    // a id based map of objects, conditions, rules ....
    mappedPolicyData: ({ policyManager }) => mapData(policyManager),
  },

  methods: {
    /**
     * Returns computed conditions for display in grid specific to a target SOURCE/DEST/OTHER corresponding to
     * grid `source`/`dest`/`other` fields
     * Outputs:
     * [
     *   {
     *     type: "Source Address", // the translated condition type
     *     shortType: "Address" // the short translated condition type (without source/dest prefix)
     *     op: "Match" // the translated condition operator
     *     value: "1.2.3.4" // the condition item value in case of equal operators
     *     objects: [ // array of condition objects computed for grid display in case of Match/In operators
     *       { name: "Object name", isGroup: true, tooltip: "Object tooltip/value" }
     *       ...
     *     ]
     *   }
     * ]
     * @param {Array} ids - array of condition objects ids
     * @param {String} target - the items target type: SOURCE/DEST/OTHER
     * @returns Array
     */
    conditionsValue(ids, target) {
      const conditions = this.policyManager.conditions.filter(
        c => ids.includes(c.id) && c.type !== Type.ObjectConditionGroup,
      )
      const items = conditions.map(cond => cond.items).flat()
      const filteredItems = filterConditionItems(items, target)
      return filteredItems.map(item => ({
        type: conditionType(item.type),
        shortType: shortConditionType(item.type, target),
        op: this.$t(item.op),
        ...(item.value && { value: equalsConditionValue(item) }),
        ...(item.object && { objects: item.object?.map(id => this.inflateObject(id)) }),
      }))
    },

    /**
     * Returns the conditions groups value for display inside grid
     * @param {Array} ids - array of condition objects ids
     * @returns Array
     */
    conditionGroupsValue(ids) {
      const groups = this.policyManager.conditions.filter(
        c => ids.includes(c.id) && c.type === Type.ObjectConditionGroup,
      )
      if (!groups?.length) return ''

      const value = []
      groups.forEach(group => value.push(this.objectValue(group)))
      return value
    },

    /**
     * Computes the tooltip of an object or object group used in conditions columns
     * @param {Object} object - etm object
     * @returns String
     */
    getTooltip(object) {
      if (object.type.includes('group')) {
        return object.items
          .map(id => this.inflateObject(id))
          .map(item => `${item.name} (${item.tooltip})`)
          .join(', ')
      }
      return this.objectValue(object)
    },

    /**
     * Returns an object ready for grid display in the form
     * {
     *   name: "The object name",
     *   isGroup: true // bool
     *   tooltip: "Computed tooltip for the object"
     * }
     * @param {String} id - object id
     * @returns
     */
    inflateObject(id) {
      const object = this.mappedPolicyData?.[id]
      return {
        name: object.name,
        isGroup: object.type.includes('group'),
        tooltip: this.getTooltip(object),
      }
    },

    /**
     * Computes an object value to be represented inside grids as tooltip
     * @param {Object} object - the etm Object
     * @returns String
     */
    objectValue(object) {
      const items = object.items
      if (object.type.includes('group')) {
        return object.items.map(id => this.inflateObject(id))
      } else {
        switch (object.type) {
          case Type.ObjectGeoip:
            return items.map(code => countryCodes[code]).join(', ')
          case Type.ObjectApplication:
            return items
              .map(
                item => `${this.$t('port_number')}: ${item.port} - ${this.$t('ip_addresses')}: ${item.ips.join(',')}`,
              )
              .join(', ')
          case Type.ObjectService:
            return items
              .map(
                item => `${this.$t('port_number')}: ${item.port} - ${this.$t('protocol')}: ${item.protocol.join(',')}`,
              )
              .join(', ')
          default:
            return items.join(', ')
        }
      }
    },

    /**
     * Computes the grid display of a rule action as expected by the `action` grid column definition
     * {
     *    text: "Some conf name", // the text
     *    id: '1234-5678...', // optional, e.g. the id of a configurations/wan policy
     *    icon: 'mdi-something...', // the prepend icon font
     *    iconColor: 'green', // optional, an icon color
     * }
     * @param {Object} action - the rule action
     * @returns Object
     */
    ruleActionValue(action) {
      let configuration
      if (action.type === ActionType.WanPolicy || action.type === ActionType.Configuration) {
        const object = this.mappedPolicyData[action.configuration_id || action.policy]
        configuration = {
          name: object?.name,
          id: object?.id,
        }
      }

      return actionValue(action, configuration)
    },

    /**
     * Computes the grid display of policies associated with a rule/condition/template for `policies` grid column field
     * [
     *   {
     *     id: "1234-5678...", // the policy id
     *     name: "mfw.example.com", // the policy name
     *   }
     *   ...
     * ]
     * @param {Object} id - the rule/condition/template id
     * @returns Array
     */
    associatedPolicyValue(ruleId) {
      return this.policyManager.policies
        .filter(policy => policy.rules.includes(ruleId))
        .map(p => ({ id: p.id, name: p.name }))
    },
  },
}
